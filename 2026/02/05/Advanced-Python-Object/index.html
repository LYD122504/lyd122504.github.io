<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
<meta name="google-site-verification" content="yGZtoctpv_RvqHFSVUN8MfwIraR1EkJ8pEmc5Azxuss" />
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-center-atom.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":"default"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"./public/search.xml"};
  </script>

  <meta name="description" content="Classes and Objects Objects面向对象编程其实就像是基于行为的自下而上的建模.一个对象则会包含一些内部状态和一些对内部状态的操作.因此,对于一个对象而言,其中包含的数据和行为是密不可分的,数据是对象的属性,而行为则是体现了对象的特性.">
<meta property="og:type" content="article">
<meta property="og:title" content="Advanced Python-Classes and Objects">
<meta property="og:url" content="http://example.com/2026/02/05/Advanced-Python-Object/index.html">
<meta property="og:site_name" content="还施水阁">
<meta property="og:description" content="Classes and Objects Objects面向对象编程其实就像是基于行为的自下而上的建模.一个对象则会包含一些内部状态和一些对内部状态的操作.因此,对于一个对象而言,其中包含的数据和行为是密不可分的,数据是对象的属性,而行为则是体现了对象的特性.">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2026-02-05T15:31:38.000Z">
<meta property="article:modified_time" content="2026-02-26T15:43:39.059Z">
<meta property="article:author" content="Li Yaoda">
<meta property="article:tag" content="Python">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2026/02/05/Advanced-Python-Object/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Advanced Python-Classes and Objects | 还施水阁</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>
    <a target="_blank" rel="noopener" href="https://github.com/LYD122504" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">还施水阁</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2026/02/05/Advanced-Python-Object/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220328/liyaoda.jpg">
      <meta itemprop="name" content="Li Yaoda">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="还施水阁">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Advanced Python-Classes and Objects
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2026-02-05 23:31:38" itemprop="dateCreated datePublished" datetime="2026-02-05T23:31:38+08:00">2026-02-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2026-02-26 23:43:39" itemprop="dateModified" datetime="2026-02-26T23:43:39+08:00">2026-02-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Advanced-Python/" itemprop="url" rel="index"><span itemprop="name">Advanced Python</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Classes-and-Objects"><a href="#Classes-and-Objects" class="headerlink" title="Classes and Objects"></a>Classes and Objects</h1><p><a id="org704c65d"></a></p>
<h2 id="Objects"><a href="#Objects" class="headerlink" title="Objects"></a>Objects</h2><p>面向对象编程其实就像是基于行为的自下而上的建模.一个对象则会包含一些内部状态和一些对内部状态的操作.因此,对于一个对象而言,其中包含的数据和行为是密不可分的,数据是对象的属性,而行为则是体现了对象的特性.</p>
<span id="more"></span>
<p>Python中一般用class声明语句来定义一个新的对象.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,x,y</span>):</span><br><span class="line">        self.x=x</span><br><span class="line">        self.y=y</span><br><span class="line">        self.health=<span class="number">100</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">move</span>(<span class="params">self,dx,dy</span>):</span><br><span class="line">        self.x+=dx</span><br><span class="line">        self.y+=dy</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">damage</span>(<span class="params">self,pts</span>):</span><br><span class="line">        self.health-=pts</span><br></pre></td></tr></table></figure>
<p>从上面我们可以看出类其实是一系列的函数,从而提供对对象示例的不同的操作方式.这里我们需要强调的是,class声明语句只是提供了类的定义方式,并不提供一个可以操作的对象.在程序中,我们需要对类做实例化得到对象示例,才可以调用方法进行相关操作.</p>
<p>每个实例都具有他自己的局部数据,这个数据是每个实例单独占有的,其他的实例不能随意访问.实例数据的初始化一般是基于__init__函数,换言之任意存储在self对象的数值都是实例数据.对于实例属性的数量或类型没有任何限制.实例方法则是指应用在对象实例的函数,一般都是在类声明语句中已经给出了相关定义.这里需要注意的是实例方法的第一个参数一般都是对象.按惯例而言,实例一般会记为self,但这个只是一个习惯,并不是很重要,可以用其他的名字来代替.实例方法其实就是普通函数的定义,只是约定俗称将实例对象作为第一个参数 传入.</p>
<p>对象的属性指的是通过.来访问的.例如</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a.x <span class="comment"># 实例属性</span></span><br><span class="line">Player.move <span class="comment"># 类属性</span></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line">math.pi <span class="comment"># 模块属性</span></span><br></pre></td></tr></table></figure>
<p>在Python中类本身并不会创建一个新的作用域,因此在类的方法内部调用其他方法时,必须显式地通过self来引用实例方法,否则Python会去全局作用域中查找同名函数,从而可能导致NameError或调用错误的函数.在Python中,作用域规则遵循LEGB(Local-Enclosing-Global-Builtin).类的代码块不是一个封闭作用域,类中定义的方法是独立的函数,他的局部作用域只包含自己的参数和内部变量,方法内部无法直接调用类中定义的其他方法或属性,除非通过self(实例)来访问.</p>
<p><a id="org69ce5ba"></a></p>
<h2 id="Manipulating-Instances"><a href="#Manipulating-Instances" class="headerlink" title="Manipulating Instances"></a>Manipulating Instances</h2><p>对实例属性的操作一般是三个形式:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">obj.attr <span class="comment"># Get an attribute</span></span><br><span class="line">obj.attr=value <span class="comment"># Set an attribute</span></span><br><span class="line"><span class="keyword">del</span> obj.attr <span class="comment"># Delete an attribute</span></span><br></pre></td></tr></table></figure>
<p>一旦实例被程序创建,那么对于实例的属性可以自由的添加和删除.对实例属性的操作,存在如下的几个属性访问函数,</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>getattr(obj,’name’)</td>
<td>obj.name</td>
</tr>
<tr>
<td>setattr(obj,’name’,value)</td>
<td>obj.name=value</td>
</tr>
<tr>
<td>delattr(obj,’name’)</td>
<td>del obj.name</td>
</tr>
<tr>
<td>hasattr(obj,’name’)</td>
<td>Tests if attribute exists</td>
</tr>
</tbody>
</table>
</div>
<p>这里我们需要注意的是getattr()具有一个比较常用的默认参数值,</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x=<span class="built_in">getattr</span>(obj,<span class="string">&#x27;x&#x27;</span>,<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
<p>如果属性不存在,返回的默认值.如果不提供且属性不存在,会抛出AttributeError.</p>
<p>前面我们提到了实例的属性不止有数据还有方法,因此我们需要简要介绍一下实例方法的调用.方法的调用其实是分为两步的,第一步需要先通过.操作符查找到实例的方法对象,第二步则是通过()操作符来调用方法.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s=Stock(<span class="string">&#x27;ACME&#x27;</span>,<span class="number">50</span>,<span class="number">91.1</span>)</span><br><span class="line">c=s.cost <span class="comment"># 查找并返回方法对象</span></span><br><span class="line"><span class="built_in">print</span>(c()) <span class="comment"># 调用方法</span></span><br></pre></td></tr></table></figure>
<p>当我们通过一个实例访问他的方法,例如obj.method,即使尚未调用,这个方法已经是一个bound method了,因为他已经绑定了该实例作为self.bound method只出现在实例访问方法,如果是通过类名访问的话,那么获得的对象是普通的函数对象,而不是绑定方法.绑定方法可以通过__self__属性来访问绑定的实例对象属性,通过__func__属性来访问绑定方法的函数属性.因此从这两个角度来说,我出门可以得知调用绑定函数的方法其实就是通过上面的属性完成的,</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c.__func__(c.__self__)</span><br></pre></td></tr></table></figure>
<p><a id="org751343b"></a></p>
<h2 id="Static-and-Class-Method"><a href="#Static-and-Class-Method" class="headerlink" title="Static and Class Method"></a>Static and Class Method</h2><p>前面我们提到了类的定义,它包含了类的实例化对象所共同使用的属性定义.只需要在类定义中定义一次,就可以在所有实例中使用,他会在实例创建的时候被调用,从而为实例创建属性.类属性指的是在__init__函数中定义的实例属性以外定义的变量,可以通过类名调用类变量,同时也可以通过实例名调用类变量.这里需要注意的是,类变量是可以被所有的实例调用,并且对于类变量的修改有如下几种情况,</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dogs</span>:</span><br><span class="line">    species = <span class="string">&quot;Canis familiaris&quot;</span></span><br><span class="line">    owner=[]</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dogs</span>:</span><br><span class="line">    species = <span class="string">&quot;Canis familiaris&quot;</span></span><br><span class="line">    owner=[]</span><br><span class="line">d1=Dogs()</span><br><span class="line">d2=Dogs()</span><br><span class="line">d1.species=<span class="string">&#x27;Wolf&#x27;</span> <span class="comment"># 创建同名的实例属性</span></span><br><span class="line"><span class="built_in">print</span>(d1.species) <span class="comment"># 返回Wolf</span></span><br><span class="line"><span class="built_in">print</span>(d2.species) <span class="comment"># 返回类属性</span></span><br><span class="line"><span class="built_in">print</span>(Dogs.species) <span class="comment"># 返回类属性</span></span><br><span class="line">Dogs.species=<span class="string">&#x27;Wolf&#x27;</span> <span class="comment"># 可以修改类属性</span></span><br><span class="line">d1.owner.append(<span class="string">&quot;John&quot;</span>) <span class="comment"># 可变类变量,可以通过实例修改内容并影响所有实例</span></span><br><span class="line"><span class="built_in">print</span>(d1.owner)</span><br><span class="line"><span class="built_in">print</span>(d2.owner)</span><br><span class="line"><span class="built_in">print</span>(Dogs.owner)</span><br></pre></td></tr></table></figure>
<p>在这里我们需要额外补一句,如果类中设置了__str__方法,那么print函数会自动调用类中定义的__str__方法,而如果str方法没有被定义,那么会查找类是否定义了__repr__方法,如果也没有,那么就会返回&lt;__main__.ClassName object&gt;.除了上面提到的一些修改类变量的方法,我们也可以通过类继承的方式来修改类变量.</p>
<p>除了类变量以外,还可以对于类定义类方法.类方法是直接操作类自身,与普通的函数不同的是,类方法需要用@classmethod装饰器定义.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SomeClass</span>:</span><br><span class="line">    debug=<span class="literal">False</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,x</span>):</span><br><span class="line">        self.x=x</span><br><span class="line"><span class="meta">        @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">yow</span>(<span class="params">cls</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;SomeClass.yow&#x27;</span>,cls)</span><br></pre></td></tr></table></figure>
<p>这里和实例方法类似,类方法中类名会以第一个参数的形式传入.类方法的主要作用其实是可以定义一些不同于__init__函数的初始化函数,如</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span>:</span><br><span class="line">    datefmt=<span class="string">&#x27;&#123;year&#125;-&#123;month&#125;-&#123;day&#125;&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,year,month,day</span>):</span><br><span class="line">        self.year=year</span><br><span class="line">        self.month=month</span><br><span class="line">        self.day=day</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.datefmt.<span class="built_in">format</span>(year=self.year,month=self.month,day=self.day)</span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">today</span>(<span class="params">cls</span>):</span><br><span class="line">        tm=time.localtime()</span><br><span class="line">        <span class="keyword">return</span> cls(tm.tm_year,tm.tm_mon,tm.tm_mday)</span><br></pre></td></tr></table></figure>
<p>类方法也可以在一些类继承的情况下解决较为复杂的问题.</p>
<p>除了类变量和类方法以外,类的定义域中还可以存在静态方法的定义.静态方法虽然也是类定义的一部分,但是他其实不会对类或实例进行操作.如果在类中定义了两个同名的函数,那么后面定义的函数定义会覆盖先前函数的定义,这是因为类会创建一个临时的命名空间,只能存在一个同名对象,因此同名标识符的后续赋值会覆盖先前绑定的对象.与前面提到的实例方法和类方法不同的是,静态方法不存在暗含的self(实例)和cls(类)参数.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SomeClass</span>:</span><br><span class="line">    debug=<span class="literal">False</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,x</span>):</span><br><span class="line">        self.x=x</span><br><span class="line"><span class="meta">        @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">yowv1</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;SomeClass.yow&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>静态方法的核心价值是命名空间组织和逻辑分组.适用于无状态的辅助函数,与类职责相关但不依赖实例或类的状态.使用静态方法可以提升代码可读性以及模块的内聚性.如果函数不需要考虑实例或类的状态,那么可以定义为静态方法;如果函数未来需要访问类的状态或者支持类继承,那么需要定义为类方法.</p>
<p>综上,类变量通常用于保存全局参数,这个参数在所有实例之间共享.子类继承基类后可以重写相关类变量从而改变类方法行为.类方法最常用是实现备用构造函数.我们常见的类方法名需要有from一词,例如</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d=<span class="built_in">dict</span>.fromkeys([<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>],<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(d)</span><br></pre></td></tr></table></figure>
<p><a id="orgdbc1495"></a></p>
<h2 id="Class-and-Encapsulation"><a href="#Class-and-Encapsulation" class="headerlink" title="Class and Encapsulation"></a>Class and Encapsulation</h2><p>类的主要作用是封装数据和对象的内部实现,而同时类也会提供对外的公共接口,用来操纵对象.因此在Python中区分对象内部实现和对外接口十分重要.但是和C/C++通过语法规定强制执行私有/公有,Python的私有封装是通过对属性的命名来约定俗成的指示属性的预期用途.因为Python默认程序员在编程中有义务遵守私有和公有协议,故而并没有做很强制的约束.</p>
<p>用_引导的属性名表示这个属性是私有变量,但是虽然名义上是私有变量,我们仍然可以调用并修改他.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name</span>):</span><br><span class="line">        self._name=name</span><br><span class="line">b=Base(<span class="string">&#x27;Guido&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(b._name)</span><br><span class="line">b._name=<span class="string">&#x27;Dave&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(b._name)</span><br></pre></td></tr></table></figure>
<p>在继承中,子类仍然可以访问父类的私有属性.实际上,_只不过是一个命名约定,表示他约定这个属性只在内部可用,但是不会阻止外部访问.为了避免出现私有属性被外界随意调用,我们可以使用__来引导变量.他与单下划线引导的变量不同的是,Python会使用名称修饰,因此我们不能通过__name的方式直接调用他,而是需要使用_cls__name来调用变量.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name</span>):</span><br><span class="line">        self.__name=name</span><br><span class="line">b=Base(<span class="string">&#x27;Guido&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(b._Base__name) <span class="comment"># &#x27;Guido&#x27;</span></span><br><span class="line">b._name=<span class="string">&#x27;Dave&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(b._name) <span class="comment"># &#x27;Dave&#x27;</span></span><br></pre></td></tr></table></figure>
<p>上面我们调用_name变量能够返回一个变量,其实是因为在上面的赋值语句中,在实例中创建了一个_name变量.所以就算用子类继承父类,也不能利用__name来调用修改变量,如果一定要修改也只能使用_Parent__name的形式.</p>
<p>对于某些需要考虑变量类型的情况下,我们需要使用引入访问器方法,在私有属性上加上get/set函数,但是不幸的是会破坏已有的代码.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Stock</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, shares, price</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.set_shares(shares)</span><br><span class="line">        self.price = price</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_shares</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self._shares</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_shares</span>(<span class="params">self, value</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(value, <span class="built_in">int</span>):</span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">&#x27;Expected an int&#x27;</span>)</span><br><span class="line">        self._shares = value</span><br></pre></td></tr></table></figure>
<p>我们希望可以加上类型判断后,并不会影响代码结构,因此引入了property装饰器.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Stock</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, shares, price</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.shares=shares</span><br><span class="line">        self.price = price</span><br><span class="line"><span class="meta">        @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">shares</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self._shares</span><br><span class="line"><span class="meta">    @shares.setter</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">shares</span>(<span class="params">self,value</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(value,<span class="built_in">int</span>):</span><br><span class="line">            self._shares=value</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">&#x27;Expected int&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>我们普通的访问属性会自动触发调用方法,例如我们访问shares属性,则会自动访问property装饰的shares方法;通过对shares的赋值,则会自动访问shares.setter装饰的shares初始化方法.所以我们可以知道property装饰器,其实可以把函数也给装饰成普通变量属性的形式,也就是</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Stock</span>:</span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">cost</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.price*self.shares</span><br></pre></td></tr></table></figure>
<p>如果我们正在创建对象并且希望对象的各个属性具有一致的接口.</p>
<p>对于__slots__属性的使用,应该保持谨慎态度,虽然他能够减少内存消耗,但是他在继承上可能会有十分复杂的情况,如果一定要使用,建议用在简单的数据结构类中.</p>
<p><a id="orgba09807"></a></p>
<h2 id="Inheritance"><a href="#Inheritance" class="headerlink" title="Inheritance"></a>Inheritance</h2><p>继承可以认为是为了扩展现有的对象的方式.我们一般称新类为派生类或子类;父类为基类或超类,父类一般是通过子类后面的括号指定.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parents</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span>(<span class="title class_ inherited__">Parents</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>继承一般有两个作用,一是向已有代码中添加新的方法,二则是重写父类方法.如果在子类中重写父类方法时需要使用父类方法,那么我们需要利用super()来调用子类的父类.使用子类继承的时候,我们必须先对父类进行初始化.类的继承其实建立了一个类型关系,我们可以通过isinstance来判断相应的关系,我们可以认为继承定义的子类对象其实是父类对象的一个特殊版本.其实Python提供了object类,可以认为Python的任意对象都是object的子类.不止于单继承,我们可以提供多个父类,从而实现多重继承的子类,其会继承多个父类的特性,但是多重继承由于MRO的存在,需要谨慎使用.综上,继承可用做代码的自定义/可扩展特性,向现有代码添加内容,执行自定义处理.</p>
<p><a id="org0f760cd"></a></p>
<h2 id="Special-Method"><a href="#Special-Method" class="headerlink" title="Special Method"></a>Special Method</h2><p>类通过修改或自定义特殊方法的方式,来定义对象的几乎全部行为.对象有两种字符串模式:str函数会返回适合打印的字符串文本;repr函数会返回具备编程开发信息的字符串文本.repr函数返回的是一个字符串,其可以通过eval函数重新创建一个相应的地政对象.若不存在,这样的字符串则以尽可能易读的形式表示字符串.</p>
<p>实例的创建实际上是分成两步:</p>
<ol>
<li><p>先创建一个未初始化的类实例对象</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d=Date.__new__(Date)</span><br></pre></td></tr></table></figure>
</li>
<li><p>再调用初始化函数对类实例对象做初始化操作</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d.__init__(<span class="number">2026</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>因此我们可以通过调用类的__new__方法来自定义一些跳过初始化的创建函数,代码如下所示</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span>:</span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">today</span>(<span class="params">cls</span>):</span><br><span class="line">        tm=time.localtime()</span><br><span class="line">        self=cls.__new__(cls)</span><br><span class="line">        self.year=tm.tm_year</span><br><span class="line">        self.month=tm.tm_mon</span><br><span class="line">        self.day=tm.tm_mday</span><br><span class="line">        <span class="keyword">return</span> self</span><br></pre></td></tr></table></figure>
<p>我们首先需要表明的是,在程序中随意修改类的__new__方法并不被提倡,但我们会在后续中提及某些场景下修改__new__方法的情况.在此我们先介绍一下,__new__方法在类中是以静态方法的形式出现的.这是因为new方法先于实例创建而存在,因此他并不能是实例方法,而new方法不被定义为类方法的原因是,如果是类方法,那么Python就会自动将调用他的类作为第一个参数绑定进入,这可能会影响代码的灵活性,而staticmethod则可以显式的传入一个类对象参数,方便开发者自由决定.</p>
<p>我们继续更详细的介绍new方法的相关用法.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls, *args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;run the new of dog&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>().__new__(cls) </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;run the init of dog&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(self)</span><br><span class="line">        <span class="built_in">print</span>(self.__class__)</span><br><span class="line">a = Dog()</span><br></pre></td></tr></table></figure>
<p>上述代码的运行流程是,先查找Dog中的new方法,如果没有找到那就会进一步查找父类的new方法,一直查找到object的new方法.上面的代码中我们查找到Dog中的new方法,其中他会调用super().__new__(cls),也就是调用父类的new方法来创建cls类.这里我们需要注意的是,父类的new方法是可以创建子类实例的,这其实可以认为子类是父类的一种特例.调用父类的new方法中我们可以发现他其实是显式调用了cls类本身,而在init方法中则是显式调用了self实例对象本身.因此new和init还有一个更为重要的区别是,new方法必须要返回一个类对象实例,而init方法则可以没有返回值.</p>
<p>__new__(cls[,&#x2026;])是对象实例化的时候,所调用的第一个方法,他会返回一个未初始化的类对象实例.而init方法则是用于初始化实例,因此在调用init方法之前,必须要调用new方法.new方法的语法结构如下所示,</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__new__(cls[,*args,**kwargs])</span><br></pre></td></tr></table></figure>
<p>这表明__new__方法的参数至少要有一个类参数,代表实例化的类.这个参数在实例化由Python解释器提供或用户自行显式提供,而后面的参数则会直接传递给init函数.new方法对当前类做实例化,并将实例返回,传给init函数的self,但new方法不代表会自动调用init,只有返回当前类的实例才会调用当前类的初始化.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, *args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;run the init of A&quot;</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls, *args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;run thr new of A&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">object</span>.__new__(B, *args, **kwargs)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;run the init of B&quot;</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls, *args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;run the new of B&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">object</span>.__new__(cls)</span><br><span class="line">a = A()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(a))</span><br><span class="line">b = B()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(b))</span><br></pre></td></tr></table></figure>
<p>这个代码运行的结果是a不会调用类A的初始化,因为a实际上是B类实例,并不会调用类A的初始化函数.其实不仅如此,哪怕创建的实例是父类的实例,也是不会调用初始化函数的,如下所示</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Parent.__init__ called&quot;</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls, *args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Parent.__new__ called for <span class="subst">&#123;cls&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>().__new__(cls)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span>(<span class="title class_ inherited__">Parent</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Child.__init__ called&quot;</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls, *args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Child.__new__: returning Parent instance!&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>().__new__(Child, *args, **kwargs)</span><br><span class="line">c = Child()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;type(c):&quot;</span>, <span class="built_in">type</span>(c))</span><br></pre></td></tr></table></figure>
<p>这里的结果其实也是子类不会自动调用初始化方法,因为他生成的是父类实例,而非子类.</p>
<p>我们一般不会修改new方法,但是如果我们希望继承一些不可变的数据类时(如int,str,tuple),修改new方法可以提供一个自定义这些类的实例化过程的途径.我们罗列一些需要修改new方法的场景以及相应实现.</p>
<ol>
<li><p>实现单例模式</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Single</span>:</span><br><span class="line">   __instance=<span class="literal">None</span></span><br><span class="line"><span class="meta">   @staticmethod</span></span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls,name,age</span>):</span><br><span class="line">       <span class="keyword">if</span> <span class="keyword">not</span> cls.__instance:</span><br><span class="line">          cls.__instance=<span class="built_in">super</span>().__new__(cls)</span><br><span class="line">       <span class="keyword">return</span> cls.__instance</span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,age</span>):</span><br><span class="line">      self.name=name</span><br><span class="line">      self.age=age</span><br><span class="line">a=Single(<span class="string">&#x27;James&#x27;</span>,<span class="number">41</span>)</span><br><span class="line">b=Single(<span class="string">&#x27;Hinton&#x27;</span>,<span class="number">36</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(a)==<span class="built_in">id</span>(b)) <span class="comment"># True 	   </span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>虽然他只有一个实例,但是我们发现其实他是经过了两次初始化,为了避免初始化的覆盖问题,我们可以进一步加上一个flag来标注只允许一次初始化.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Single</span>:</span><br><span class="line">   __instance=<span class="literal">None</span></span><br><span class="line">   __first_init=<span class="literal">False</span></span><br><span class="line"><span class="meta">   @staticmethod</span></span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls,name,age</span>):</span><br><span class="line">       <span class="keyword">if</span> <span class="keyword">not</span> cls.__instance:</span><br><span class="line">          cls.__instance=<span class="built_in">super</span>().__new__(cls)</span><br><span class="line">       <span class="keyword">return</span> cls.__instance</span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,age</span>):</span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">not</span> self.__first_init:</span><br><span class="line">         self.name=name</span><br><span class="line">         self.age=age</span><br><span class="line">         self.__first_init=<span class="literal">True</span></span><br><span class="line">a=Single(<span class="string">&#x27;James&#x27;</span>,<span class="number">41</span>)</span><br><span class="line">b=Single(<span class="string">&#x27;Hinton&#x27;</span>,<span class="number">36</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(a)==<span class="built_in">id</span>(b)) <span class="comment"># True 	   </span></span><br></pre></td></tr></table></figure>
<p>这里面我们其实可以发现一个十分有趣的现象,就是我们直接用了self.__instance来调用相应的属性,而我们在前面提到过这样的属性名会做一个名称修饰,从而导致真实的变量名应该是_class__instance.这是因为这个过程其实是在编译过程中完成的名称修饰,而这些调用本身都是在类定义内部,所以在做编译的时候会整体上的做名称修饰,故而可以直接形式上的调用.</p>
<ol>
<li><p>不可变类型子类化(如int,str,tuple)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PositiveInt</span>(<span class="title class_ inherited__">int</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls,value</span>):</span><br><span class="line">        <span class="keyword">if</span> value&lt;<span class="number">0</span>:</span><br><span class="line">            value=<span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>().__new__(cls,value)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UpperStr</span>(<span class="title class_ inherited__">str</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls, content</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>().__new__(cls, content.upper())</span><br><span class="line">x=PositiveInt(-<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line">s = UpperStr(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(s)  <span class="comment"># &quot;HELLO&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>自定义实例创建逻辑(如对象池,类型转换等)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls,shape_type,*args</span>):</span><br><span class="line">        <span class="keyword">if</span> shape_type==<span class="string">&#x27;circle&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>().__new__(Circle)</span><br><span class="line">        <span class="keyword">elif</span> shape_type==<span class="string">&#x27;square&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>().__new__(Square)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>().__new__(cls)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span>(<span class="title class_ inherited__">Shape</span>): <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Square</span>(<span class="title class_ inherited__">Shape</span>): <span class="keyword">pass</span></span><br><span class="line">obj = Shape(<span class="string">&quot;circle&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(obj))</span><br></pre></td></tr></table></figure>
</li>
<li><p>控制实例数量(对象池)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LimitedInstances</span>:</span><br><span class="line">    _pool = []</span><br><span class="line">    _<span class="built_in">max</span> = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(cls._pool) &lt; cls._<span class="built_in">max</span>:</span><br><span class="line">            instance = <span class="built_in">super</span>().__new__(cls)</span><br><span class="line">            cls._pool.append(instance)</span><br><span class="line">            <span class="keyword">return</span> instance</span><br><span class="line">         <span class="keyword">return</span> cls._pool[<span class="built_in">len</span>(cls._pool) % cls._<span class="built_in">max</span>]</span><br><span class="line">a=LimitedInstances()</span><br><span class="line">b=LimitedInstances()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(a))</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>Python中除了new方法的创建类实例以外,也有__del__方法,其是类对象的一个析构函数.但一般来说他不会调用,当且仅当类对象的引用数为0,也就是程序中用不到这样的类对象的时候才会触发.因此我们需要把他和del操作符区分开,</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__del__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;删除引用&#x27;</span>)</span><br><span class="line">t=Test() <span class="comment"># refcount=1</span></span><br><span class="line">c=t <span class="comment"># refcount=2</span></span><br><span class="line"><span class="keyword">del</span> t <span class="comment"># refcount=1</span></span><br><span class="line"><span class="keyword">del</span> c <span class="comment"># refcount=0, 调用__del__函数</span></span><br></pre></td></tr></table></figure>
<p>我们用一些代码简要介绍一下del方法的用法,因为我们修改del函数的情况非常之少,所以我们会在后面简要提及.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__del__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;实例对象:%s&quot;</span>%self.name,<span class="built_in">id</span>(self))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;python解释器开始回收%s对象了&quot;</span> % self.name)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;类对象&quot;</span>,<span class="built_in">id</span>(Person))</span><br><span class="line">zhangsan  = Person(<span class="string">&quot;张三&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;实例对象张三:&quot;</span>,<span class="built_in">id</span>(zhangsan))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;------------&quot;</span>)</span><br><span class="line">lisi  = Person(<span class="string">&quot;李四&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;实例对象李四:&quot;</span>,<span class="built_in">id</span>(lisi))</span><br></pre></td></tr></table></figure>
<p>这里我们虽然没有对实例进行删除操作,但是由于在程序结束的时候会自动释放所有程序的占用内存,故而会在程序最后调用del方法.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;__init__方法被调用&#x27;</span>)</span><br><span class="line">        self.__name = name</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__del__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;__del__方法被调用&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s对象马上被干掉了...&quot;</span>%self.__name)</span><br><span class="line">dog = Animal(<span class="string">&quot;Dogs&quot;</span>)</span><br><span class="line"><span class="keyword">del</span> dog</span><br><span class="line">cat = Animal(<span class="string">&quot;Cats&quot;</span>)</span><br><span class="line">cat2 = cat</span><br><span class="line">cat3 = cat</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;---马上 删除cat对象&quot;</span>)</span><br><span class="line"><span class="keyword">del</span> cat</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;---马上 删除cat2对象&quot;</span>)</span><br><span class="line"><span class="keyword">del</span> cat2</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;---马上 删除cat3对象&quot;</span>)</span><br><span class="line"><span class="keyword">del</span> cat3</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;程序2秒钟后结束&quot;</span>)</span><br><span class="line">time.sleep(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>上面的程序中的dog对象因为他只有一个引用数,故而在删除自身后会直接调用del方法,但是由于cat对象做了两次赋值,因此其引用数变成了3,我们需要逐步删除已有的引用,最后才会调用del方法.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">t=Test()</span><br><span class="line"><span class="built_in">print</span>(sys.getrefcount(t))</span><br><span class="line">c=t</span><br><span class="line"><span class="built_in">print</span>(sys.getrefcount(t))</span><br><span class="line"><span class="keyword">del</span> c</span><br><span class="line"><span class="built_in">print</span>(sys.getrefcount(t))</span><br><span class="line"><span class="keyword">del</span> t</span><br></pre></td></tr></table></figure>
<p>Python的sys模块中提供了一个可以读取对象引用数的函数,但值得注意的是,他的引用数读取实际上是比实际的引用数大1的,这是因为测试这个对象引用数的函数本身其实就是对象的一个引用.del方法的危险在于他的调用时机不确定,执行环境不完整,异常不可控,用它去做必须释放的资源在Python中是一个设计错误.因为del依赖的是垃圾回收机制,而不是作用域结束,如果出现了引用环,如</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = BadExample()</span><br><span class="line">a.self = a   <span class="comment"># 引用环</span></span><br></pre></td></tr></table></figure>
<p>这样就算我们del a,他的引用数还是1,不会调用del方法.</p>
<p>为了避免出现上面的这个情况,Python引入了弱引用的概念.弱引用表示引用某个对象但是不会增加相应的引用计数.Python提供了weakref模块来实现相应的功能,他可以用于处理复杂的对象关系和内存管理问题的内存泄露问题.但由于他的使用可能十分复杂,因此我们并不推荐经常使用这个模块.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,value</span>):</span><br><span class="line">        self.value=value</span><br><span class="line">        self.prev=<span class="literal">None</span></span><br><span class="line">        self.<span class="built_in">next</span>=<span class="literal">None</span></span><br><span class="line">a=Node(<span class="number">1</span>)</span><br><span class="line">b=Node(<span class="number">2</span>)</span><br><span class="line">a.<span class="built_in">next</span>=b</span><br><span class="line">b.prev=a</span><br><span class="line"><span class="keyword">del</span> a</span><br><span class="line"><span class="keyword">del</span> b</span><br></pre></td></tr></table></figure>
<p>这里我们即使删除了a,b,内存中仍然还是会保留对象a和b的内存占用,这是因为他们存在一个互相引用的现象.Python的变量和C/C++不同,Python的变量并没有绑定内存,而只是一个引用副本,故而释放引用副本并不会影响内存,所以即使我们释放了a的引用,其实a引用的内存仍然存在.弱引用的作用就是打破这个引用循环使部分引用不增加引用计数,让对象能在无强引用时立即被回收.我们在此介绍一些典型场景和代码实例:</p>
<ol>
<li><p>观察者模式是一种行为型设计模式,它定义了一种一对多的依赖关系,当一个对象的状态发生改变时,其所有依赖者都会收到通知并自动更新.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> weakref</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Subject</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self._observers=[] <span class="comment"># 存储弱存储</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">attach</span>(<span class="params">self,observer</span>):</span><br><span class="line">        self._observers.append(weakref.ref(observer))</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">notify</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 清理已死亡的对象</span></span><br><span class="line">        alive=[]</span><br><span class="line">        <span class="keyword">for</span> ref <span class="keyword">in</span> self._observers:</span><br><span class="line">            obs=ref()</span><br><span class="line">            <span class="keyword">if</span> obs <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                obs.update()</span><br><span class="line">                alive.append(ref)</span><br><span class="line">                self.observers=alive</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Observer</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name</span>):</span><br><span class="line">        self.name=name</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;self.name&#125;</span> received update&quot;</span>)</span><br><span class="line">subject = Subject()</span><br><span class="line">obs1 = Observer(<span class="string">&quot;A&quot;</span>)</span><br><span class="line">obs2 = Observer(<span class="string">&quot;B&quot;</span>)</span><br><span class="line">subject.attach(obs1)</span><br><span class="line">subject.attach(obs2)</span><br><span class="line">subject.notify()  <span class="comment"># A, B 收到通知</span></span><br><span class="line"><span class="keyword">del</span> obs1  <span class="comment"># obs1 被回收</span></span><br><span class="line">subject.notify()  <span class="comment"># 仅 B 收到通知，obs1 自动清理</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>这里使用弱引用的优势在于Subject不会阻止Observer被回收,从而避免观察者泄露.</p>
<ol>
<li><p>缓存(Cache)避免缓存本身成为内存泄露源.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> weakref</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WeakCache</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># key → weakref to value</span></span><br><span class="line">        <span class="comment"># 当 value 无其他强引用时自动消失</span></span><br><span class="line">        self._cache=weakref.WeakValueDictionary()</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self,key</span>):</span><br><span class="line">        <span class="keyword">return</span> self._cache.get(key)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set</span>(<span class="params">self,key,value</span>):</span><br><span class="line">        self._cache[key]=value</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">cache=WeakCache()</span><br><span class="line">obj=A()</span><br><span class="line">cache.<span class="built_in">set</span>(<span class="string">&quot;key1&quot;</span>,obj)</span><br><span class="line"><span class="built_in">print</span>(cache.get(<span class="string">&quot;key1&quot;</span>))</span><br><span class="line"><span class="keyword">del</span> obj</span><br><span class="line"><span class="built_in">print</span>(cache.get(<span class="string">&quot;key1&quot;</span>))</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>他的优势是缓存不会延长对象生命周期,适合”透明缓存”场景.其中的weakref.WeakValueDictionary,表示字典的值为弱引用.</p>
<ol>
<li><p>树/图结构中的父-子反向引用</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> weakref</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, value, parent=<span class="literal">None</span></span>):</span><br><span class="line">        self.value = value</span><br><span class="line">        self.parent = weakref.ref(parent) <span class="keyword">if</span> parent <span class="keyword">else</span> <span class="literal">None</span>  <span class="comment"># 弱引用</span></span><br><span class="line">        self.children = []</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add_child</span>(<span class="params">self, child</span>):</span><br><span class="line">        child.parent = weakref.ref(self)  <span class="comment"># 子→父为弱引用</span></span><br><span class="line">        self.children.append(child)</span><br><span class="line"><span class="comment"># 使用</span></span><br><span class="line">root = TreeNode(<span class="string">&quot;root&quot;</span>)</span><br><span class="line">child = TreeNode(<span class="string">&quot;child&quot;</span>, parent=root)</span><br><span class="line">root.add_child(child)</span><br><span class="line"><span class="keyword">del</span> root  <span class="comment"># root 可被回收（child.parent 是弱引用，不阻止回收）</span></span><br><span class="line"><span class="comment"># child 仍存活（有局部变量引用）</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>其优势为子节点持有父节点的弱引用,避免父子互相强引用形成循环.</p>
<p>上面我们提到了del方法存在一些缺点,所以对于某些必须被释放的资源,我们选择使用with语句来取代del方法.with语句的结构如下所示:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> obj <span class="keyword">as</span> val: <span class="comment"># val=obj.__enter__()</span></span><br><span class="line">    statements</span><br><span class="line">    statements</span><br><span class="line">    <span class="comment"># obj.__exit__(ty,val,tb)</span></span><br></pre></td></tr></table></figure>
<p>这里我们可以自定义修改obj的entry/exit方法.给出如下的代码示例,</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Manager</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__enter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Entering&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__exit__</span>(<span class="params">self,ty,val,tb</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Leaving&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> ty:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;An exception occurred&#x27;</span>)</span><br><span class="line">m=Manager()</span><br><span class="line"><span class="keyword">with</span> m:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello World!&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>注意,ty,val,tb这三个参数包含尚未处理的异常信息(如果有的话).</p>
<p><a id="orgb03b918"></a></p>
<h2 id="Abstract-Base-Class"><a href="#Abstract-Base-Class" class="headerlink" title="Abstract Base Class"></a>Abstract Base Class</h2><p>面向对象编程的重要特点就是在于代码复用和代码可拓展.类通常可以被认为是一种设计规范或编程接口.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">IStream</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">read</span>(<span class="params">self, maxbytes=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError()</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">write</span>(<span class="params">self, data</span>):</span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError()</span><br></pre></td></tr></table></figure>
<p>此类一般不会直接实例化,而是作为其他对象的基类.因此我们可以将接口定义为抽象基类(Abstract Base Class,ABC),其中抽象基类的一些实现需要从Python的abc模块中继承,如下所示</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABC,abstractmethod</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IStream</span>(<span class="title class_ inherited__">ABC</span>):</span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">read</span>(<span class="params">self,maxtypes=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">write</span>(<span class="params">self,data</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>抽象基类是不能够实例化的,因为他其实只是提供了一些方法的占用,需要在继承中重定义方法实现.除非所有抽象方法都被完整的实现,不然是无法实例化类对象.这其实是可以帮助开发者捕获因疏忽带来的编程错误.不仅如此,传统角度来说,我们如果希望判别对象是否为我们期待的接口,需要手动逐个检查验证方法是否存在且是否可调用,</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">write_data</span>(<span class="params">data, stream</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> (<span class="built_in">hasattr</span>(stream, <span class="string">&#x27;read&#x27;</span>) <span class="keyword">and</span> <span class="built_in">callable</span>(stream.read) <span class="keyword">and</span></span><br><span class="line">            <span class="built_in">hasattr</span>(stream, <span class="string">&#x27;write&#x27;</span>) <span class="keyword">and</span> <span class="built_in">callable</span>(stream.write)):</span><br><span class="line">        <span class="keyword">raise</span> TypeError(<span class="string">&#x27;Expected a Stream with read() and write() methods&#x27;</span>)</span><br><span class="line">    ...</span><br><span class="line"><span class="comment">#+END_SR</span></span><br><span class="line">这一流程十分复杂且极其容易遗漏,而抽象基类则可以十分方便的简化上述的类型检测,如下所示</span><br><span class="line"><span class="comment">#+BEGIN_SRC python</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">write_data</span>(<span class="params">data,stream</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(stream,IStream):</span><br><span class="line">        <span class="keyword">raise</span> TypeError(<span class="string">&#x27;Expected a Stream with read() and write() methods&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>在抽象基类中,存在一种比较常见的用法就是处理器类.我们有些时候会在代码中实现一些通用算法,然后将一些关键或可拓展的步骤委托给外部提供的处理器对象.这个方式其实就是策略设计模式.策略设计模式表示在程序中定义了一系列算法或策略,并将每个算法封装在独立的类中,使得它们可以互相替换.通过使用策略模式,可以在代码运行时根据需要选择不同的算法封装对象,而不需要修改客户端代码.他的优点是降低了算法类的职责,使各个算法可以独立变化并相互替换.而且使得增加新算法十分容易,降低对原有系统的侵入,从而使得程序可扩展可维护性增强.但是缺点就是程序功能不断丰富的过程中,程序从局部来看变的更复杂了.</p>
<p>我们给出一个简单的处理器类的代码示例</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">print_table</span>(<span class="params">records,fields,formatter</span>):</span><br><span class="line">    formatter.headings(fields)</span><br><span class="line">    <span class="keyword">for</span> r <span class="keyword">in</span> records:</span><br><span class="line">        rowdata=[<span class="built_in">getattr</span>(r,fieldname,<span class="string">&#x27;undef&#x27;</span>) <span class="keyword">for</span> fieldname <span class="keyword">in</span> fields]</span><br><span class="line">        formatter.row(rowdata)</span><br></pre></td></tr></table></figure>
<p>上面的代码中formatter其实就是一个处理器类,他在print_table里面被不断调用,因此使用处理器类的关键在于算法的关键步骤委托给独立的处理器类,从而实现代码的解耦.处理器类和抽象基类一样,都是具有自己的类定义,一般来说他只需要包含需要实现或者自定义的方法.处理器类在Python标准库中极为常见,他的优势是提供了代码的灵活性;处理器类和代码实现解耦;处理器类在其他的代码上下文中可复用.</p>
<p>抽象基类的另一个特例在于构造模板类.模板类实现通用算法,但是将某些特殊化步骤委托给子类实现.如</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CSVParser</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">parse</span>(<span class="params">self, filename</span>):</span><br><span class="line">        records = []</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(filename) <span class="keyword">as</span> f:</span><br><span class="line">            rows = csv.reader(f)</span><br><span class="line">            self.headers = <span class="built_in">next</span>(rows)</span><br><span class="line">            <span class="keyword">for</span> row <span class="keyword">in</span> rows:</span><br><span class="line">                record = self.make_record(row)  <span class="comment"># 需子类实现的步骤</span></span><br><span class="line">                records.append(record)</span><br><span class="line">        <span class="keyword">return</span> records</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">make_record</span>(<span class="params">self, row</span>):</span><br><span class="line">        <span class="keyword">raise</span> RuntimeError(<span class="string">&#x27;Must implement&#x27;</span>)  <span class="comment"># 未实现时抛出错误</span></span><br></pre></td></tr></table></figure>
<p>这种类是无法直接是用的,必须通过子类继承来补充缺失的功能.如下所示</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DictCSVParser</span>(<span class="title class_ inherited__">CSVParser</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">make_record</span>(<span class="params">self, row</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dict</span>(<span class="built_in">zip</span>(self.headers, row))</span><br><span class="line">parser = DictCSVParser()</span><br><span class="line">portfolio = parser.parse(<span class="string">&#x27;portfolio.csv&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>他的核心思想是用户仅需定义小型子类提供缺失部分,大部分功能由基类提供.但实际上,上面的这个结构通过模板类和子类的结构从代码角度来看其实十分复杂,其实可以直接用函数回调的方式直接替代.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">parse_csv</span>(<span class="params">filename, make_record</span>):</span><br><span class="line">    records = []</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(filename) <span class="keyword">as</span> f:</span><br><span class="line">        rows = csv.reader(f)</span><br><span class="line">        headers = <span class="built_in">next</span>(rows)</span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> rows:</span><br><span class="line">            record = make_record(headers, row)  <span class="comment"># 用户传入回调函数</span></span><br><span class="line">            records.append(record)</span><br><span class="line">    <span class="keyword">return</span> records</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">make_record</span>(<span class="params">headers, row</span>):  <span class="comment"># 用户实现</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>因为模板模式可能会过于复杂,而函数的回调会更加简洁.</p>
<p><a id="orgeed8e3f"></a></p>
<h2 id="Advanced-Inheritance"><a href="#Advanced-Inheritance" class="headerlink" title="Advanced Inheritance"></a>Advanced Inheritance</h2><p>继承是代码复用(定制与扩展)的工具,子类可以对父类已有的方法进行自定义修改与扩展.多重继承会使得子类继承所有父类的特性.Python允许协作式多重继承,子类可以显式安排多个父类协作.子类定义时父类的顺序十分重要,他会直接影响父类在方法解释顺序也就是MRO中的顺序.调用子类属性的时候,会在他的MRO中寻找相应的属性.此外,super()函数会按照MRO依次调用父类的方法,形成协作,这里需要注意的是super()不一定是父类,而是MRO的下一个类.例如,</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABC,abstractmethod</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TableFormatter</span>(<span class="title class_ inherited__">ABC</span>):</span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">headings</span>(<span class="params">self,headers</span>):</span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError()</span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">row</span>(<span class="params">self,rowdata</span>):</span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TextTableFormatter</span>(<span class="title class_ inherited__">TableFormatter</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">headings</span>(<span class="params">self,headers</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27; &#x27;</span>.join(<span class="string">&#x27;%10s&#x27;</span> % h <span class="keyword">for</span> h <span class="keyword">in</span> headers))</span><br><span class="line">        <span class="built_in">print</span>((<span class="string">&#x27;-&#x27;</span>*<span class="number">10</span>+<span class="string">&#x27; &#x27;</span>)*<span class="built_in">len</span>(headers))</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">row</span>(<span class="params">self,rowdata</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27; &#x27;</span>.join(<span class="string">&#x27;%10s&#x27;</span> % d <span class="keyword">for</span> d <span class="keyword">in</span> rowdata))</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UpperHeadersMixin</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">headings</span>(<span class="params">self,headers</span>):</span><br><span class="line">        <span class="built_in">super</span>().headings([h.upper() <span class="keyword">for</span> h <span class="keyword">in</span> headers])</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UpperHeadersFormatter</span>(UpperHeadersMixin,TextTableFormatter):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>这里的UpperHeadersMixin类的heading方法调用了super方法,他其实并不一定代表UpperHeadersMixin的父类,因为我们会在UpperHeadersFormatter里调用,所以他其实是表示在MRO顺序下往后的某一个类,未必是他自己的父类. Mixin是专门向其他类定义添加额外功能而设计的类.其核心思想是用户实现基础功能后,Mixin可自动补充额外的函数功能.他的主要作用是可以减少代码重复,减少需要编写的代码量.他的典型用途是为基本对象添加可选功能(如线程支持,持久化等),用户通过组合不同部件装配所需对象.</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Python/" rel="tag"># Python</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2026/01/28/Advanced-Python-Data/" rel="prev" title="Advanced Python-Data Handling">
      <i class="fa fa-chevron-left"></i> Advanced Python-Data Handling
    </a></div>
      <div class="post-nav-item">
    <a href="/2026/02/10/Advanced-Python-Inside/" rel="next" title="Advanced Python-Inside Python Objects">
      Advanced Python-Inside Python Objects <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Classes-and-Objects"><span class="nav-number">1.</span> <span class="nav-text">Classes and Objects</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Objects"><span class="nav-number">1.1.</span> <span class="nav-text">Objects</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Manipulating-Instances"><span class="nav-number">1.2.</span> <span class="nav-text">Manipulating Instances</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Static-and-Class-Method"><span class="nav-number">1.3.</span> <span class="nav-text">Static and Class Method</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Class-and-Encapsulation"><span class="nav-number">1.4.</span> <span class="nav-text">Class and Encapsulation</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Inheritance"><span class="nav-number">1.5.</span> <span class="nav-text">Inheritance</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Special-Method"><span class="nav-number">1.6.</span> <span class="nav-text">Special Method</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Abstract-Base-Class"><span class="nav-number">1.7.</span> <span class="nav-text">Abstract Base Class</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Advanced-Inheritance"><span class="nav-number">1.8.</span> <span class="nav-text">Advanced Inheritance</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Li Yaoda"
      src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220328/liyaoda.jpg">
  <p class="site-author-name" itemprop="name">Li Yaoda</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">58</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/LYD122504" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;LYD122504" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:302536585@qq.com" title="E-Mail → mailto:302536585@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2026</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Li Yaoda</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
