<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Lecture series on graph theory 3</title>
    <url>/2022/05/20/Graph3/</url>
    <content><![CDATA[<p>Given a graph G, <span class="math inline">\(T=\{v|d_G(v)\equiv1\
mod\ 2\}\)</span>, a subgraph P is called a parity subgraph if <span
class="math display">\[
d_P(v)\equiv\left\{
\begin{aligned}
&amp;0\ mod\ 2,\ v\not\in T\\
&amp;1\ mod\ 2,\ v\in T
\end{aligned}
\right.\qquad i.e.\ d_P(v)\equiv d_G(v)
\]</span> <span class="math inline">\(G-E(P)\)</span> is an even
subgraph <font color='red'>( i.e. every vertex of G-E(P) has even
degree)<br>Problem: To find a parity subgraph with the minimum number of
edges.</font></p>
<span id="more"></span>
<p>More general, let <span class="math inline">\(T\subset V(G)\)</span>,
a set of edges <span class="math inline">\(J\)</span> is called a <span
class="math inline">\(T\)</span>-join if all the edges of <span
class="math inline">\(J\)</span> induce a subgraph, s.t. <span
class="math inline">\(d_J(v)\equiv1\ mod\ 2\Leftrightarrow v\in
T\)</span>, <font color='red'>A parity subgraph of G is a <span
class="math inline">\(T\)</span>-join of G where <span
class="math inline">\(T=\{v|d_G(v)\equiv1\ mod\ 2\}\)</span><br>Problem:
To find a <span class="math inline">\(T\)</span>-join with the minimum
number of edges.</font></p>
<p><strong>Bipartite Graph</strong></p>
<p>A graph is bipartite if its vertex set can be partitioned into two
sets X and Y such that every edge of G joins a vertex of X and a vertex
of Y.</p>
<p><font color='red'>For example.</font></p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220226/2022-05-22_185717.5b3liqdtj4g0.jpg"
alt="2022-05-21_121856" />
<figcaption aria-hidden="true">2022-05-21_121856</figcaption>
</figure>
<p><strong>Proposition. A graph is bipartite <span
class="math inline">\(\Leftrightarrow\)</span> it has no odd
cycles</strong></p>
<hr />
<p><strong>Proof</strong></p>
<p><span class="math inline">\(\Rightarrow\)</span> Let <span
class="math inline">\(G\)</span> be a bipartite graph and let <span
class="math inline">\((X,Y)\)</span> be a bipartition of <span
class="math inline">\(G\)</span>. Color vertices in X by red and
vertices in Y by blue. Let <span class="math inline">\(C\)</span> be a
cycle. Then the red vertices and blue vertices appear alternatively on
<span class="math inline">\(C\)</span>. So <span
class="math inline">\(C\)</span> has an even number of vertices.
Therefore, <span class="math inline">\(G\)</span> has no odd cycles.</p>
<p><span class="math inline">\(\Leftarrow\)</span> Let v be a vertex of
<span class="math inline">\(G\)</span>. Let <span
class="math inline">\(X=\{x|d_G(x,v)\equiv0(mod\ 2)\}\)</span> and <span
class="math inline">\(Y=\{y|d_G(y,v)\equiv 1(mod\ 2)\}\)</span></p>
<p>Since <span class="math inline">\(G\)</span> has no odd cycle, there
is no edges joining two vertices from the same part. So G is
bipartite.</p>
<hr />
<p><font color='red'>Every part in the bipartition induce the graph
without edges.</font></p>
<p>A vertex subset <span class="math inline">\(I\)</span> of <span
class="math inline">\(V(G)\)</span> is independent if <span
class="math inline">\(G\)</span> has no edges joining any two vertices
of <span class="math inline">\(I\)</span>.</p>
<p>The maximum cardinality of independent sets is called the independent
number of <span class="math inline">\(G\)</span>.</p>
<p><font color='red'>Problem: Determine the independent number of a
given graph <span class="math inline">\(G\)</span> (NPC)</font></p>
<p>If G is bipartite, the its independent number <span
class="math inline">\(\alpha(G)\geq\frac{n}{2}\)</span>.</p>
<p><font color='red'><strong>(The Four color problem) Every graph drawn
on the plane without crossing edges has a vertex partition into four
independent sets.<br>According to the above, if G is a plane graph,
<span class="math inline">\(\alpha(G)\geq\frac{\lvert
V(G)\rvert}{4}\)</span></strong></font></p>
<hr />
<p><strong>Second Proof of the Mantel's Theorem</strong></p>
<p><font color='red'>Recall: Let G be an n-vertex graph without
triangle, then <span class="math inline">\(\lvert
E(G)\rvert\leq\frac{n^2}{4}\)</span></font></p>
<p>Let x be a vertex of G such that <span
class="math inline">\(d_G(x)=\Delta(G)\)</span>. So <span
class="math inline">\(N_G(x)\)</span> is an independent set of G. <span
class="math display">\[
\lvert E(G)\rvert\leq\sum_{y\not\in N_G(x)}d_G(y)\leq(n-d_G(x))\Delta
(G)=(n-d_G(x))d_G(x)\leq\frac{n^2}{4}
\]</span> and equality holds <span class="math inline">\(\Leftrightarrow
n-d_G(x)=d_G(x),\ i.e.\ d_G(x)=\frac{n}{2}\)</span></p>
<hr />
<p><strong>Degenerated Graph</strong></p>
<p>A graph G is k-degenerate if every subgraph of G has a vertex of
degree at most k. <font color='red'>A tree is 1-degenerate</font></p>
<p>A graph G is k-colorable if the vertex of G can be colored by k
different colors such that any vertex subset with same color is an
independent set. i.e. the vertex set of G can be partitioned into k
independent subsets.</p>
<p><strong>Proposition: A k-degenerated graph is
(k+1)-colorable</strong></p>
<hr />
<p><strong>Proof.</strong> Let G be k-degenerate graph. Then G has a
vertex v of degree at most k.</p>
<p>Use induction on the number of vertex.</p>
<p>The inductive hypothesis implies that <span
class="math inline">\(G-v\)</span> is (k+1)-colorable. All vertices in
<span class="math inline">\(N_G(x)\)</span> have been colored by at most
k different colors in any (k+1)-coloring of G-v. Then color v by the
(k+1)th color. So G is (k+1)-colorable.</p>
<hr />
<p><font color='red'>1-factor is a spanning subgraph in which every
vertex has degree one.</font></p>
<p><font color='red'>1-degenerate graph is a tree(or a
forest)</font></p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220226/2022-05-21_190614.g013sfif35c.jpg"
alt="2022-05-21_190614" />
<figcaption aria-hidden="true">2022-05-21_190614</figcaption>
</figure>
<p><strong>Corollary. Every graph G is <span
class="math inline">\((\Delta(G)+1)\)</span>-degenerate</strong></p>
<p><strong>Def. A Planar graph is a graph with a drawing on the plane
<span class="math inline">\(\mathbb{R}^2\)</span></strong> . A connected
region of <span class="math inline">\(\mathbb{R}^2-G\)</span> is a face
of G.</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220226/2022-05-21_191223.3jzn0lp4vyg0.jpg"
alt="2022-05-21_191223" />
<figcaption aria-hidden="true">2022-05-21_191223</figcaption>
</figure>
<p><strong>Thm(Euler Formula) Let G be a planar graph, and let n,m and f
be the numbers of vertex,edges and faces of G, Then </strong> <span
class="math display">\[
n-m+f=2
\]</span> <strong>Proposition. Every planar graph is
5-degenerate</strong></p>
<hr />
<p><strong>Proof.</strong> Let G be a planar graph. It suffices to show
that G has a vertex of degree at most five. Without loss of generality,
assume that G is a maximal planar graph (<font color='red'>i.e. every
face is bounded by a triangle</font>). Otherwise, we can add edges to G
to keep it to be a planar graph.</p>
<p>Since every edge appears on the boundaries of two faces and every
face contains exactly three edges, it follows that <span
class="math display">\[
3f=2m\Rightarrow f=\frac{2}{3}m
\]</span> Let <span class="math inline">\(\delta=\delta(G)\)</span>, the
minimum degree of G, then <span class="math display">\[
\delta n\leq\sum_{x\in V(G)}d_G(x)=2m\Rightarrow n\leq\frac{2}{\delta}m
\]</span> By Euler's Formula: <span
class="math inline">\(n-m+f=2\)</span> <span class="math display">\[
2=n-m+\frac{2}{3}m\leq(\frac{2}{\delta}-\frac{1}{3})m
\]</span> Therefore, <span
class="math inline">\(\frac{2}{\delta}-\frac{1}{3}&gt;0\Rightarrow
\delta&lt;6\Leftrightarrow \delta\leq5\)</span></p>
<p>Every planar graph has a vertex of degree at most 5, which implies a
planar graph is 5-degenerate.</p>
<hr />
<p><strong>Corollary. Every planar graph is 6-colorable.</strong></p>
<p><font color='red'>Actually we can use Kempe chain to prove the
proposition that every planar graph is 5-colorable.<br>Problem:What kind
of Eulerian graphs having an even-cycle
decomposition?<br>Conjecture(Akiyama,1980s) Every planar graph with n
vertices has an induced 2-degenerate graph with at least n/2
vertices.<br>Conjecture(Albertson&amp;Berman,1970s) Every planar graph
with n vertices has an induced 1-degenerate graph with at least n/2
vertices.</font></p>
<p><strong>Matrices and Graphs</strong></p>
<p><img
src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220226/2022-05-21_235307.fn17ct60tvc.jpg" /></p>
<p><font color='red'>A is a symmetric matrix and because we only
consider simple graphs, its diagonal elements are all zero.</font></p>
<p><img
src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220226/2022-05-21_235516.2htdkwuxlpy0.jpg" /></p>
<p>A square matrix A is symmetric if <span
class="math inline">\(A^T=A\)</span></p>
<p>A scalar <span class="math inline">\(\lambda\)</span> is eigenvalue
of A if there exists a non-zero vector <span
class="math inline">\(\vec{X}\)</span>, s.t. <span
class="math inline">\(A\vec{X}=\lambda\vec{X}\)</span> and <span
class="math inline">\(\vec{X}\)</span> is called an eigenvector of A
with respect to <span class="math inline">\(\lambda\)</span>.</p>
<p>A basis <span class="math inline">\(B\)</span> of a vector space is
orthonormal if <span class="math inline">\(||\vec{X}||=1\)</span> for
any <span class="math inline">\(\vec{X}\in B\)</span>, and <span
class="math inline">\(&lt;\vec{X_1},\vec{X_2}&gt;=0\)</span> for any
<span class="math inline">\(\vec{X_1},\vec{X_2}\in B\)</span></p>
<p><strong>Thm. Let A be a real symmetric <span
class="math inline">\((n\times n)\)</span>-matrix. Then A is a
diagonizable and <span class="math inline">\(\mathbb{R}^n\)</span> has
orthonormal basis of eigenvectos of A</strong> <span
class="math display">\[
A\sim\left(\begin{matrix}
   \lambda_1 &amp; \dots &amp;0\\
   \vdots &amp; \ddots &amp;\vdots\\
   0 &amp; \dots &amp;\lambda_n\\
  \end{matrix}\right)
\]</span></p>
<p><strong>Proposition. All eigenvalues of a real symmetric <span
class="math inline">\((n\times n)\)</span>-matrix is real</strong></p>
<hr />
<p><strong>Proof</strong> We assume that A is a <span
class="math inline">\(n\times n\)</span> matrix, <span
class="math inline">\(\lambda\)</span> is an eignevalue of A.</p>
<p>Assume that <span class="math inline">\(\vec{X}\)</span> is an
eigenvector of <span class="math inline">\(\lambda\)</span>, Then <span
class="math display">\[
\begin{aligned}
\lambda||\vec{X}||&amp;=&lt;\lambda\vec{X},\vec{X}&gt;=&lt;A\vec{X},\vec{X}&gt;=\vec{X^T}A\vec{X}\\&amp;=\vec{X^T}A^T\vec{X}=(A\vec{X})^T\vec{X}=&lt;\vec{X},A\vec{X}&gt;=\bar{\lambda}||\vec{X}||
\end{aligned}
\]</span> So <span
class="math inline">\(\lambda=\bar{\lambda}\Rightarrow\lambda\)</span>
is real.</p>
<hr />
<p>A real symmetric matrix A is positive semi-definite if ,for all <span
class="math inline">\(\vec{X}\in\mathbb{R}^n\)</span>, <span
class="math inline">\(\vec{X}^TA\vec{X}\geq0\)</span> and A is positive
definite if <span
class="math inline">\(\vec{X}^TA\vec{X}&gt;0\)</span></p>
<p><strong>Proposition. All eigenvalues of a positive semi-definite
<span class="math inline">\(\Leftrightarrow\ \exists\)</span> a matrix
B, s.t. <span class="math inline">\(A=B^TB\)</span></strong></p>
<hr />
<p><strong>Proof.</strong><span
class="math inline">\(\Rightarrow\)</span> We assume that A is a
positive semi-definite matrix.</p>
<p>Then A is diagonaizable and assume that <span
class="math inline">\(A=Q^TDQ\)</span> where D is a diagonable matrix
with eigenalues on its diagonal. Note that all egienvalues of A are
non-negative. <span class="math display">\[
A=Q^TDQ=Q^TD^{\frac{1}{2}}D^\frac{1}{2}Q=(\sqrt{D}Q)^T(\sqrt{D}Q)=B^TB,\quad
where\ B=\sqrt{D}Q
\]</span> <span class="math inline">\(\Leftarrow\)</span> Let <span
class="math inline">\(A=B^TB\)</span>.</p>
<p>Then for any <span
class="math inline">\(\vec{X}\in\mathbb{R}^n\)</span>, <span
class="math inline">\(\vec{X}^TA\vec{X}=\vec{X}^TB^TB\vec{X}=(B\vec{X})^TB\vec{X}=||B\vec{X}||\geq0\)</span></p>
<p>So A is positive semi-definite.</p>
]]></content>
      <categories>
        <category>Graph Theory</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Operation Research</tag>
      </tags>
  </entry>
  <entry>
    <title>Lecture series on graph theory 1</title>
    <url>/2022/03/28/Graph1/</url>
    <content><![CDATA[<p>Def. A graph is a <font color=red>discrete structure/combinational
structure</font> consisting of vertices and edges which connect to a
pair of vertices.</p>
<p>Usually, a vertex is represented by a dot and an edge is represented
by a line (straight or curved) joining two vertices.</p>
<span id="more"></span>
<p><img
src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220226/2022-02-26_212559.jpg" /></p>
<center>
<font color=red size=4>The green points mean crossing of the
edges,rather than vertices  </font>
</center>
<p>A vertex is incident with an edge if the edge join the vertex to
another vertex, which is also called the end of the edge.</p>
<p>Two vertices are adjacent to each other if there is an edge joinging
them.</p>
<p><img
src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220226/2022-02-26_214218.jpg" /></p>
<center>
<font color=red size=4>We say that the vertex v is incident with the
edge e<br>The vertex u is adjacent to the vertex v because uv is an edge
of G</font>
</center>
<p>A graph is simple if there is at most one edge between any two
vertices and there is no edge joining a vertex itself.</p>
<p><img
src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220226/2022-03-28_185112.jpg" /></p>
<p>In short, a graph is simple if and only if it has no multi-edges and
no loops.Next, unless otherwise specified, we will discuss simple graphs
by default.</p>
<p>For any given simple graph <span
class="math inline">\(G(V,E)\)</span>，V is the vertex set and E is the
edge set. <span class="math display">\[
if\ \lvert V\rvert=n,\lvert E\rvert\leq\binom{n}{2}
\]</span> A graph is complete if the graph has an edge between every
pair of vertices.A complete graph of n vertices is usually denoted by
<span class="math inline">\(K_n\)</span></p>
<p><img
src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220226/2022-03-28_185902.jpg" /></p>
<p>The degree of a vertex v of G, denoted by <span
class="math inline">\(d_G(v)\)</span>, is the number of edges incident
with it.</p>
<p>The maximum degree of G is defined as <span
class="math inline">\(\Delta(G):=\max\{d_G(x)|v\in V(G)\}\)</span></p>
<p>The minimum degree of G is defined as <span
class="math inline">\(\delta G:=\min\{d_G(v)|v\in V(G)\}\)</span></p>
<p>The average degree of G is defined as <span
class="math inline">\(d(G):=\frac{\lvert E(G)\rvert}{\lvert
V(G)\rvert}\)</span>, this index is used to measure the density of the
graph.According to this index, graph can be divided into dense graph and
sparse graph</p>
<p>A neighbor of v in G is a vertex joined to v by an edge of G.The
neighborhood of a vertex v in G is the set of all neighbors of v in G,
denoted by <span class="math inline">\(N_G(v)=\{u|u\in V(G),uv\in
E(G)\}\)</span>.We have <span class="math inline">\(d_G(v)=\lvert
N_G(v)\rvert\)</span> easily.</p>
<p><img
src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220226/2022-03-28_185933.jpg" /></p>
<p><font color=red>This picture shows the multi-level neighbors of v. If
u is both a second-level neighbor and a third-level neighbor of v, it is
classified as a second-level neighbor. <br>Here we give the set
representation of neighbors: <br><span
class="math inline">\(N_1(v)=N_G(v),N_2(v)=N_G(N_1(v))-N_1(v)\cup\{v\},\
N_3(v)=N_G(N_2(v))-N_1(v)\)</span><br>and if <span
class="math inline">\(w\in N_3(v),\ distance(w,v)=3\)</span></font></p>
<p>A graph is even if every vertex of G has an even degree.</p>
<p><img src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220226/2022-03-28_185942.jpg" style="zoom:50%;" /></p>
<p><strong>Proposition(Handshaking Lemma)<br>Every graph has an even
number of vertices with odd degree.</strong></p>
<p>Proof.</p>
<p>Let <span class="math display">\[
\left\{\begin{aligned}X&amp;=\{x|x\in V(G)\ and\
d_G(x)\equiv0(mod\ 2)\}\\Y&amp;=\{y|y\in V(G)\ and\
d_G(y)\equiv1(mod\ 2)\}\end{aligned}\right.
\]</span> Then,<span class="math inline">\(\sum_{x\in
X}d_G(x)+\sum_{y\in Y}d_G(y)=2\lvert E(G)\rvert\)</span></p>
<p>So, <span class="math inline">\(\sum_{y\in Y}d_G(y)\equiv0(mod\
2)\)</span>.It follows immediately that <span
class="math inline">\(\lvert Y\rvert\equiv0(mod\ 2)\)</span></p>
<p>So the proposition holds.</p>
<p>Question:Let G be an n-vertex graph.How many edges will force G to
have a triangle?(Mantel's Theorem)</p>
<p>Def A walk of G is <font color=red>a sequence of vertices and edges
of G</font>such that (i)both the first element and the last element of
the sequence are vertices and (ii) any two consecutive elements in the
sequence contains one vertex and one edge which are incident with each
other.</p>
<p><img
src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220226/2022-03-28_200038.jpg" /></p>
<p><font color=red>We give two different walks: <span
class="math inline">\(w_{1}=v_1e_1v_2e_2v_3e_2v_2e_1v_1,\ 
w_2=v_2e_2v_3e_3v_4e_4v_2\)</span><br>For walk,vertex can be repeated,
edge can be repeated.</font></p>
<p>A walk is open if the first vertex is not equal to the last vertex.
<font color=red><span
class="math inline">\(w_0=v_2e_2v_3e_3v_4e_4v_2e_1v_1\)</span></font></p>
<p>A walk is a trail if it does not have repeated edges.
<font color=red><span class="math inline">\(w_0\)</span> is a
trail</font></p>
<p>A trail is a path if it does not have repeated vertices.</p>
<p><font color=red><span
class="math inline">\(w_3=v_1e_1v_2e_2v_3e_3v_4=v_1v_2v_3v_4\)</span> is
a path</font></p>
<p>A cycle is a closed trail( or path) without repeated vertices
(vertices and edges) <font color =red>except the first vertex and the
last vertex. <span
class="math inline">\(w_4=v_2e_2v_3e_3v_4e_4v_2\)</span></font></p>
<p>A graph is connected if for any two vertices x and y, there is a path
joining x and y.</p>
<p><img
src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220226/2022-03-28_200053.75zqcj50zpw0.jpg" /></p>
<p>A subgraph H of G is a graph with <span
class="math inline">\(V(H)\subset V(G),E(H)\subset E(G)\)</span></p>
<p>A maximal connected subgraph of G is called a connected component.
<font color=red>Maximal means anything bigger than it is not
connected</font></p>
<p>An edge e of G is bridge or cut-edge if #connected components of
G-e&gt;#connected components of G</p>
<p><img src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220226/2022-03-28_200107.7d9xw8946f80.jpg" style="zoom:67%;" /></p>
<p><font color=red>#connected components of G-<span
class="math inline">\(e_1\)</span>=3&gt;2=#connected components of
G<br>Both <span class="math inline">\(e_1\)</span> and<span
class="math inline">\(e_2\)</span> are bridges/cut-edges</font></p>
<p><strong>Thm(BJJ,Fan)<br>Every graph without bridges has a family of
cycles which covers every edge exactly 2k times for any integer <span
class="math inline">\(k\ge2\)</span></strong></p>
<p>A subgraph H is spanning if <span
class="math inline">\(V(H)=V(G)\)</span></p>
<p>A subgraph H is induced by <font color=red> <span
class="math inline">\(S\subset V(G)\)</span></font>, if <span
class="math inline">\(V(H)=S\)</span> and for any two vertices <span
class="math inline">\(x,y\in S\)</span>, <span
class="math inline">\(xy\in E(H)\Leftrightarrow xy\in E(G)\)</span></p>
<p>A subgraph H is induced by <font color=red> <span
class="math inline">\(S\subset E(G)\)</span></font>, if <span
class="math inline">\(E(H)=S\)</span> and <span
class="math inline">\(v\in V(H)\)</span>a if and only if v is incident
with an edge in S.</p>
<p><img
src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220226/2022-03-28_213047.4nctxwr5lzc0.jpg" /></p>
<p>Let <span class="math inline">\(x,y\in V(G)\)</span>, the distance
between x and y in G is the length of the shortest path joining x and y,
denoted by <span class="math inline">\(dist_G(x,y)\)</span>. In other
words, <span class="math display">\[
dist_G(x,y)=\min\{\lvert E(P)\rvert\big|P\ is\ a\ path\ joining\ x\ and\
y\}
\]</span>
<img src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220226/2022-03-28_215149.3o033gismx60.jpg" style="zoom:67%;" /></p>
<p><font color=red><span class="math inline">\(dist_G(x,y)=k\)</span>,
this means finding a shortest path between any two vertices x and y is
easy</font></p>
<p><font color=red>However, finding a longest path between any two
vertices x and y.Given an integer k, is there an (x,y)-path with length
k?They are NPC problems</font></p>
]]></content>
      <categories>
        <category>Graph Theory</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Operation Research</tag>
      </tags>
  </entry>
  <entry>
    <title>Lecture series on graph theory 2</title>
    <url>/2022/03/28/Graph2/</url>
    <content><![CDATA[<p>First, we try to prove the Mantel's Theorem, which was presented as a
question in the last blog post.</p>
<p><strong>Thm(Mantel's Theorem)<br>Let G be a graph with n vertices. If
G does not contain a triangle, then</strong> <span
class="math display">\[
\lvert E(G)\rvert\leq\frac{n^2}{4}
\]</span> Before the proof begin, we introduce what triangle means.</p>
<span id="more"></span>
<p><img
src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220226/2022-03-29_220946.jpg" /></p>
<p><font color=red><span
class="math inline">\(C=v_1v_2v_3v_4v_5v_1\)</span> is a
5-cycle.Generally, k-cylce has k vertices.Specially, we call a 3-cycle
as a triangle</font></p>
<p>Now, let's take a few examples to find potential patterns which may
help to prove this theorem.</p>
<p><img
src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220226/63DEEBC1B5B34ABA2048219295C11EF6.jpg" /></p>
<p><font color=red>In general, we can divide n vertices into two groups,
then we add all edges between two groups.Because there is no edge
joining the vertices from the same side, if there is a cycle in graph,
it must be an even cycle, such as alternating left-hand and right-hand
sides.<br>If n is even, #edges=<span
class="math inline">\(\frac{n}{2}\cdot\frac{n}{2}=\frac{n^2}{4}\)</span>,
if n is odd, #edges=<span
class="math inline">\(\frac{n+1}{2}\cdot\frac{n-1}{2}=\frac{n^2-1}{4}\leq\frac{n^2}{4}\)</span></font></p>
<hr />
<p><strong>Proof of the Mantel's Theorem</strong></p>
<p>Let G be an n-vertex graph without a triangle.</p>
<p><img
src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220226/2022-03-29_225536.jpg" /></p>
<p><span class="math inline">\(\forall x,y\in V(G)\)</span>, if <span
class="math inline">\(xy\in E(G)\)</span>, <span
class="math inline">\(N_G(x)\cap N_G(y)=\emptyset\)</span> because G has
no triangle.</p>
<p>Because <span class="math inline">\(N_G(x)\cup N_G(y)\subset
V(G)\)</span>, <span class="math inline">\(d_G(x)+d_G(y)\leq
n\)</span></p>
<p>From the above formula, we have <span class="math display">\[
\sum_{xy\in E(G)}(d_G(x)+d_G(y))\leq\sum_{xy\in E(G)}n=n\cdot\lvert
E(G)\rvert \tag{1}
\]</span> <img
src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220226/2022-03-29_225550.4v4nzok1fwc0.jpg" /></p>
<p>We find that <span class="math inline">\(d_G(x)\)</span> appears in
<span
class="math inline">\(d_G(x)+d_G(y_1),d_G(x)+d_G(y_2),\dots,d_G(x)+d_G(y_{d_G(x)})\)</span>
<span class="math display">\[
So\ \sum_{xy\in E(G)}(d_G(x)+d_G(y))=\sum_{x\in V(G)}d_G(x)\cdot
d_G(x)=\sum_{x\in V(G)}d_G(x)^2\tag{2}
\]</span> From (1) &amp; (2), we have <span class="math display">\[
\sum_{x\in V(G)}d_G(x)^2\leq n\cdot\lvert E(G)\rvert\tag{3}
\]</span> According to the relationship between degree and edge: <span
class="math inline">\(\sum_{x\in V(G)}d_G(x)=2\lvert E(G)\rvert\)</span>
and the Cauchy-Schwarz inequality:<span
class="math inline">\((\sum_{k=1}^n a_k^2)(\sum_{k=1}^n
b_k^2)\geq(\sum_{k=1}^na_kb_k)^2\)</span>, we have <span
class="math display">\[
\sum_{x\in V(G)}d_G(x)^2\geq \frac{(\sum_{x\in
V(G)}d_G(x))^2}{n}=\frac{4\lvert E(G)\rvert^2}{n}\tag{4}
\]</span> From (3) &amp; (4), <span class="math inline">\(\frac{4\lvert
E(G)\rvert^2}{n}\leq \sum_{x\in V(G)}d_G(x)^2\leq n\cdot \lvert
E(G)\rvert\)</span> which implies <span class="math inline">\(\lvert
E(G)\rvert \leq\frac{n^2}{4}\)</span></p>
<hr />
<p>If a graph G has more than <span
class="math inline">\(\frac{n^2}{4}\)</span> edges, then G has a
triangle.</p>
<p><font color=red>Furthermore, we can extend the triangle to k-cycle
and obtain the Erdős-Gallai's Theorem <br>We can also extend the
triangle to a complete graph with k vetices, which are called k-clique
and obtain the Turán's Theorem</font></p>
<p>Tree: A tree is a connected graph without cycles.</p>
<p><strong>Proposition: Every tree with at least two vetices has at
least two vertices of degree one</strong></p>
<hr />
<p><strong>Proof</strong></p>
<p>Let P be the longest path of G. Then both end vertices of P have
degree one in G.If not, we suppose that <span
class="math inline">\(u,v\in V(P),\ uv\in E(P)\)</span> and u is the end
vertex of P, but <span class="math inline">\(d_G(u)&gt;1\)</span>.</p>
<p>Case 1:</p>
<p><img
src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220226/2022-04-04_204919.4qpcnrekreg0.jpg" /></p>
<p><span class="math inline">\(w\not\in V(P)\)</span> and <span
class="math inline">\(wu\in E(G)\)</span>,then <span
class="math inline">\(\tilde{P}=P+wu\)</span> is longer than P. This
contradicts the fact that P is the longest path.</p>
<p>Case 2:</p>
<p><img
src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220226/2022-04-04_204927.tn63688yr68.jpg" /></p>
<p><span class="math inline">\(w\in V(P),w\not=v\)</span> and <span
class="math inline">\(wu\in E(G)\)</span>, then we can find that there
is a cycle. This contradicts the fact that G is a tree.</p>
<hr />
<p>A vertex of a tree is a leaf if it has degree one.</p>
<p><strong>Proposition: A connected graph with n vertices is a tree if
and only if it has n-1 edges. </strong></p>
<hr />
<p><strong>Proof</strong></p>
<p><span class="math inline">\(\Rightarrow\)</span> n=1, G has no
edges.</p>
<p>Now, we assume that it is correct for a tree with n-1 vertices to
have n-2 edges.From this assumption, we want to deduce that a tree with
n vertices has n-1 edges.</p>
<p>Since <span class="math inline">\(n\ge2\)</span>, G has a vertex v of
degree one. Let u be the only neighbor of v in G. Because G is a tree
with n vertices, G-v is a tree with n-1 vertices. According to the
asssumption,<span class="math inline">\(\lvert
E(G-v)\rvert=(n-1)-1\)</span>. <span class="math display">\[
\lvert E(G)\rvert=\lvert E(G-v)\rvert+1=(n-1)-1+1=n-1
\]</span> <span class="math inline">\(\Leftarrow\)</span> Let G be a
connected graph with n vertices and n-1 edges. We claim that G has a
vertex of degree one.</p>
<p>We prove this claim first.If not, <span class="math inline">\(\forall
x\in V(G)\)</span>, assume <span
class="math inline">\(d_G(x)\ge2\)</span></p>
<p>Then we have <span class="math inline">\(\lvert
E(G)\rvert=\frac{1}{2}\sum_{x\in V(G)}d_G(x)\ge\frac{1}{2}\cdot2\lvert
V(G)\rvert=n&gt;n-1\)</span> which contradicts that <span
class="math inline">\(\lvert E(G)\rvert=n-1\)</span>. The contradiction
implies the claim holds.</p>
<p>From this claim, G has a vertex of degree one. Use the induction on
G-v. Since G-v has n-1 vertices and <span
class="math inline">\((n-1)-1\)</span> edges. By inductive hypothsis,
G-v is a tree and has no cycles.Since v is a degree one vertex, G has no
cycles. Therefore, G is a tree.</p>
<hr />
<p><strong>Corollary: Every graph with minimum degree at least two
contains a cycle.</strong></p>
<p>A spanning tree of G is a connected spanning subgraph of G without
cycles.</p>
<p><font color=red>Problem: counting the number of edge-disjoint
spanning trees in a graph.<br>If the number of edge-disjoint spanning
trees is large, the graph is well-connected. (Related to
edge-connectivity of the graph)</font></p>
<p>Now we introduce two classic search algorithms in graph theory.</p>
<p>A breadth-first-search tree of a graph (BFS-tree)</p>
<p><img src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220226/2022-04-05_111757.6pnsx44gbus0.jpg" style="zoom: 50%;" /></p>
<ol type="i">
<li><p>Start at <span class="math inline">\(x=x_0\)</span> and join x to
all neighbors of x, Let <span
class="math inline">\(N_1=N_G(x)\)</span></p></li>
<li><p>For each <span class="math inline">\(y\in N_i\)</span>, join y to
all neighbors of y without creating cycles and let <span
class="math inline">\(N_{i+1}=\cup_{y\in N_i}N_G(y)\)</span></p></li>
</ol>
<p>The algorithm will take <span class="math inline">\(O (\lvert
V\rvert+\lvert E\rvert)\)</span> steps to find a BFS-tree rooted at
<span class="math inline">\(x_0\)</span>.</p>
<p>A deepth-first-search tree of a graph (DFS-tree)</p>
<p><img src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220226/微信图片_20220405111924.6g6tlxqwfto0.jpg" style="zoom:15%;" /></p>
<ol type="i">
<li><p>Start at <span class="math inline">\(x=x_0\)</span> and <span
class="math inline">\(T_0=\{x_0\}\)</span></p></li>
<li><p>Join x to one of its neighbor <span class="math inline">\(x_1\in
N_G(x_0)\)</span> and<span
class="math inline">\(T_1=\{x_0,x_1\}\)</span></p></li>
<li><p>If <span class="math inline">\(N_i=N_G(x_i)\backslash
T_i\not=\emptyset\)</span>, then join <span
class="math inline">\(x_i\)</span> to a vertex <span
class="math inline">\(x_{i+1}\in N_i\)</span> and let <span
class="math inline">\(T_{i+1}=T_i\cup\{x_{i+1}\}\)</span> and <span
class="math inline">\(x_{i+1}\to x_i\)</span></p></li>
</ol>
<p>If <span class="math inline">\(N_i=N_G(x_i)\backslash
T_i=\emptyset\)</span>, then set <span class="math inline">\(x_{i-1}\to
x_{i}\)</span> and <span
class="math inline">\(N_{i-1}=N_G(x_{i-1})\backslash T_i\to N_i\)</span>
and continue.</p>
<p>Eulerian graph:</p>
<p><font color=red>Problem: Let G be a graph.When does G have a closed
trail which contains all edges of G?</font></p>
<p>A closed trail is Eulerian if the trail go through all edges of G. A
graph is called Eulerian if it has an Eulerian trail.</p>
<p><strong>Proposition: Every Eulerian graph is a connected graph which
has only even-degree vertices</strong></p>
<hr />
<p><strong>Proof</strong> Let G be an Eulerian graph. Then G has an
Eulerian trail, denoted by <span
class="math inline">\(T=v_1e_1v_2e_2\cdots v_me_mv_1\)</span>. So G is
connected.</p>
<p>Now, orient the edges of G along the trail T such that, for an edge
<span class="math inline">\(e_i\)</span> in T, orient <span
class="math inline">\(e_i\)</span> from <span
class="math inline">\(v_i\)</span> to <span
class="math inline">\(v_{i+1}\)</span>. Since T has no repeated edges,
every edge receives exactly one orientation. For each vertex <span
class="math inline">\(v_i\)</span>, T visits <span
class="math inline">\(v_i\)</span> and then leaves <span
class="math inline">\(v_i\)</span>, which implies <span
class="math display">\[
\# edges\ oriented\ towards\ v_i=\#edges\ oriented\ away\ from\ v_i
\]</span> But the degree of <span class="math inline">\(v_i\)</span>
satisfies <span class="math display">\[
\begin{aligned}
d_G(v_i)&amp;=\# edges\ oriented\ towards\ v_i+\#edges\ oriented\ away\
from\ v_i\\
&amp;\equiv0(mod\ 2)
\end{aligned}
\]</span> So every vertex of G has an even degree.</p>
<hr />
<p>A cycle decomposition D of a graph G is a set of egde-disjoint cycles
<span class="math inline">\(D=\{C_1,C_2,\dots,C_k\}\)</span> such
that<br />
<span class="math display">\[
\cup_{C_i\in D}E(C_i)=E(G)
\]</span> <strong>Proposition: Every even graph has a cycle
decomposition.</strong></p>
<hr />
<p><strong>Proof</strong> Let G be an even graph. Suppose to the
contrary that G does not have a cycle decomposition.</p>
<p>Assume G is a minimal counterexample.If G has a vertex v of degress
zero, the G-v is a subgraph of G and hence is not a counterexample. So
G-v has a cycle decomposition. So does G, a contradiction to that G is a
counterexample.</p>
<p>So assume that<span class="math inline">\(\delta(G)\ge2\)</span>.
Then by corollary, G has a cycle C. Then, G-E(C) is an even subgraph of
G. So G-E(C) has a cycle decomposition D. Then, <span
class="math inline">\(D\cup\{C\}\)</span> is a cycle-decomposition of G,
which contradicts that G is a counterexample. So prop. holds.</p>
<hr />
<p><font color='red'>Corollary: Every Eulerian graph has a cycle
decomposition.</font></p>
<p><font color='red'>（conjecture,Hajos,1968）All Eulerian graph with n
vertex. How many cycles in a cycle decomposition D?<span
class="math inline">\(\lvert
D\rvert\le\frac{n-1}{2}\)</span>?</font></p>
]]></content>
      <categories>
        <category>Graph Theory</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Operation Research</tag>
      </tags>
  </entry>
  <entry>
    <title>Lecture series on graph theory 4</title>
    <url>/2022/05/22/Graph4/</url>
    <content><![CDATA[<p><strong>Proposition. The adjacency matrix of a graph is a real
symmetric matrix.</strong></p>
<span id="more"></span>
<p><img
src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220226/2022-05-22_131847.16yosr9l8xs0.jpg" /></p>
<p><font color='red'>Here we broefly discuss the topic of random
matrices.<br>Probability of adjacent connection between <span
class="math inline">\(R_j\)</span> and <span
class="math inline">\(C_j\)</span>, <span
class="math inline">\(P(R_j\sim C_j)=\frac{1}{2}\)</span>, <span
class="math inline">\(\ P(R_j\not\sim C_j)=\frac{1}{2}\)</span></font>
<span class="math display">\[
P(A(G)\ is \ invertible)=P(M\ is\ invertible)
\]</span> <strong>Thm Let G be a graph. The number of walks from <span
class="math inline">\(v_i\)</span> to <span
class="math inline">\(v_j\)</span> of length k is equal to the <span
class="math inline">\((i,j)\)</span>-entry of <span
class="math inline">\((A(G))^k\)</span></strong></p>
<hr />
<p><strong>Proof</strong></p>
<p>Let <span class="math inline">\(A(G)=(a_{ij})_{n\times n}\)</span>.
Then <span class="math inline">\((i,j)\)</span>-entry of <span
class="math inline">\((A(G))^k\)</span> is given by <span
class="math display">\[
[(A(G))^k]_{ij}=\sum a_{ii_1}a_{i_1i_2}\cdots a_{i_{k-1}j}
\]</span> where the sum ranges over all sequences <span
class="math inline">\((i_1,i_2,\dots,i_{k-1})\)</span> with <span
class="math inline">\(i_t\in[n]=\{1,2,\dots,n\}\)</span> <span
class="math display">\[
\begin{aligned}
(A(G))^2_{ij}&amp;=(A(G)\cdot
A(G))_{ij}=\sum_{i_1=1}^na_{ii_1}a_{i_1j}\\
(A(G))^3_{ij}&amp;=((A(G))^2\cdot
A(G))_{ij}=\sum_{i_2=1}^n(\sum_{i_1=1}^na_{ii_1}a_{i_1i_2})a_{i_2j}=\sum_{i_1,i_2=1}^{n}a_{ii_1}a_{i_1i_2}a_{i_2j}\\
\end{aligned}
\]</span> By the definition of adjacency matrix, <span
class="math inline">\(a_j=1\Leftrightarrow v_iv_j\in E(G)\)</span></p>
<p>It follows that the summand <span
class="math inline">\(a_{ii_1}a_{i_1i_2}\cdots a_{i_{k-1}j}\)</span> is
1 <span class="math inline">\(\Leftrightarrow\ v_iv_{i_1}v_{i_2}\cdots
v_{i_{k-1}}v_j\)</span> is a walk of length k. Hence the summing over
all <span class="math inline">\((i_1,\cdots,i_{k-1})\)</span> just gives
the total number of walks of length k from <span
class="math inline">\(v_i\)</span> to <span
class="math inline">\(v_j\)</span></p>
<hr />
<p>A(G) is <span class="math inline">\(n\times n\)</span> symmetric
matrix. All n eigenvalues of A(G) are real. Assume the n eigenvalues
satisfy <span class="math display">\[
\lambda_1\geq\lambda_2\geq\cdots\geq\lambda_n
\]</span> <font color='red'>Note that <span
class="math inline">\(\lambda_1+\lambda_2+\cdots+\lambda_n=0\)</span>,some
eigenvalues could be negative.<br>If G is a bipartite graph, the
eigenvalues are symmetric about origin.</font></p>
<p><strong>Thm Let G be a graph with eigenvalues <span
class="math inline">\(\lambda_1,\cdots,\lambda_n\)</span>. Then the
number of closed walks in G of length k is given by</strong> <span
class="math display">\[
w_G(k)=\lambda_1^k+\cdots+\lambda_n^k
\]</span></p>
<hr />
<p><strong>Proof</strong></p>
<p>Let G be a graph with adjacency matrix A(G). Then it follows from the
above theorem that <span class="math display">\[
w_G(k)=\sum_{i=1}^n[(A(G))^k]_{ii}=tr(A(G)^k)
\]</span> Since A(G) has <span class="math inline">\(\lambda_i\)</span>
as an eigenvalue with <span
class="math inline">\(i\in\{1,2,\cdots,n\}\)</span>, the matrix <span
class="math inline">\(A(G)^k\)</span> has eigenvalue <span
class="math inline">\(\lambda_i^k\)</span>for <span
class="math inline">\(i\in\{1,2,\cdots,n\}\)</span></p>
<p><font color='red'><span
class="math inline">\(A(G)\vec{v_i}=\lambda_i\vec{v_i},\quad
A(G)^k\vec{v_i}=A(G)^{k-1}A(G)\vec{v_i}=A(G)^{k-1}\lambda\vec{v_i}=\lambda_i^k\vec{v_i}\)</span></font></p>
<p>Then, <span
class="math inline">\(tr(A(G)^k)=\sum_{i=1}^n\lambda_i^k\)</span>, so
<span
class="math inline">\(w_G(k)=tr(A(G)^k)=\sum_{i=1}^n\lambda_i^k\)</span></p>
<hr />
<p><strong>Incidence matrix and Laplacian matrix</strong></p>
<p>Let G be a graph s.t. <span
class="math inline">\(V(G)=\{v_1,v_2,\cdots,v_n\}\)</span> and <span
class="math inline">\(E(G)=\{e_1,e_2,\cdots,e_m\}\)</span> <span
class="math display">\[
B(G)=(b_{ij})_{n\times m}\ where\
b_{ij}=\left\{\begin{aligned}&amp;1\quad v_i\ is\ incident\ with\ e_j\\
&amp;0\quad v_i\ isn&#39;t\ incident\ with\ e_j\end{aligned}\right.
\]</span> <img
src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220226/2022-05-22_162156.x0o95v76evk.jpg" /></p>
<p><font color='red'>We can find that evey column has two non-zero
entries.</font></p>
<p><img
src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220226/2022-05-22_162610.6c5zcmwtfbc0.jpg" /></p>
<p><font color='red'>We can find that each column of <span
class="math inline">\(\vec{B}\)</span> has one entry of 1, one entry of
-1 and other entry of 0.Therefore, add all entries in column and get
0</font></p>
<p><img
src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220226/2022-05-22_163017.jpg" /></p>
<p><span class="math inline">\(D(G)\)</span> is a diagonal matrix whose
diagonal entries are the degrees of vertices.</p>
<p>Laplacian matrix of G: <span class="math inline">\(L(G)=
D(G)-A(G)=\vec{B}\cdot\vec{B}^T\)</span></p>
<p><strong>Proposition. Let G be a graph. Then L(G) is positive
semi-definite and consequently, all eigenvalues of L(G) are real and
non-negative.</strong> <span class="math display">\[
\beta_1\geq\beta_2\geq\cdots\geq\beta_n\geq0
\]</span> <span class="math inline">\(\tau(G)\)</span>= the total number
of spanning trees in G.</p>
<p><strong>Thm(Matrix Tree Theorem) Let G be a graph with vertices <span
class="math inline">\(v_1,\dots,v_n\)</span>. Then <span
class="math inline">\(\tau(G)=det(L_0(G))\)</span> where <span
class="math inline">\(L_0(G)\)</span> is obtained from <span
class="math inline">\(L(G)\)</span> by deleting the i-th row and i-th
column for any <span
class="math inline">\(i\in[n]=\{1,2,\dots,n\}\)</span></strong></p>
<hr />
<p><strong>Proof.</strong></p>
<p><img
src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220226/2022-05-22_174049.4vsowf7szwq0.jpg" /></p>
<p>If T is a spanning tree, either <span class="math inline">\(e\in
T\)</span> or <span class="math inline">\(e\not\in T\)</span>.</p>
<p>An edge e of G is said to be contracted if it is deleted and its ends
are identified, the resulting graph is denoted by <span
class="math inline">\(G\cdot e\)</span>.</p>
<p><img
src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220226/2022-05-22_174508.6er13gzch2o0.jpg" /></p>
<p>If <span class="math inline">\(e\not\in T\)</span>, T is a spanning
tree of G-e; if <span class="math inline">\(e\in T\)</span>, <span
class="math inline">\(T\cdot e\)</span> is a spanning tree of <span
class="math inline">\(G\cdot e\)</span>.</p>
<p>Therefore, <span class="math inline">\(\tau(G)=\tau(G-e)+\tau(G\cdot
e)\)</span></p>
<p>Use induction on the number of edges of G.</p>
<p>If G has no edges and n=1, so <span
class="math inline">\(\tau(G)=1=det(L_0(G))\)</span> where <span
class="math inline">\(L_0(G)\)</span> is a <span
class="math inline">\(0\times 0\)</span> matrix with determinant 1 by
convenience.</p>
<p>If <span class="math inline">\(n&gt;1\)</span>, then <span
class="math inline">\(\tau(G)=0\)</span>, and <span
class="math inline">\(L_0(G)\)</span> is a 0-matrix in which every entry
is 0. So <span class="math inline">\(\tau(G)=det(L_0(G))\)</span> .</p>
<p>Therefore, the statement holds for <span
class="math inline">\(|E(G)|=0\)</span>.</p>
<p>Assume the statement holds all graph with number of edges less than
<span class="math inline">\(|E(G)|\)</span>.</p>
<p>By recordering the vertices of G, we may assume that <span
class="math inline">\(i=1\)</span> and <span
class="math inline">\(v_1v_2\in E(G)\)</span>, Let <span
class="math inline">\(e=v_1v_2\)</span>. Then <span
class="math inline">\(\tau(G)=\tau(G-e)+\tau(G\cdot e)\)</span>.</p>
<p>By inductive hypothesis, <span
class="math inline">\(\tau(G-e)=det(L_0(G-e))\)</span> and <span
class="math inline">\(\tau(G\cdot e)=det(L_0(G\cdot e))\)</span>.</p>
<p>Assume <span
class="math inline">\(L_0(G)=\begin{pmatrix}d_2&amp;P\\P^T&amp;R\end{pmatrix}\)</span>
obtained from <span
class="math inline">\(L(G)=\left(\begin{array}{c:c:c}d_1&amp;1&amp;\cdots\\\hdashline1&amp;d_2&amp;P\\\hdashline\vdots&amp;P^T&amp;R\end{array}\right)\)</span>
by deleting the first row and the first column.</p>
<p>Then <span
class="math inline">\(L_0(G-e)=\begin{pmatrix}d_2-1&amp;P\\P^T&amp;R\end{pmatrix}\)</span>
and <span class="math inline">\(L_0(G\cdot e)=R\)</span></p>
<p>Note that <span
class="math inline">\(L_0(G)=L_0(G-e)+\begin{pmatrix}1&amp;\vec{0}\\\vec{0}^T&amp;R\end{pmatrix}\)</span></p>
<p>Using the Laplace expansion along the first row, <span
class="math display">\[
det(L_0(G))=det(L_0(G-e))+det(L_0(G\cdot e))=\tau(G-e)+\tau(G\cdot
e)=\tau(G)
\]</span></p>
<hr />
<p><strong>Thm Let G be a connected graph with n vertices. Suppose that
the eigenvalues of L(G) are <span
class="math inline">\(\mu_1\geq\mu_2\geq\cdots\geq\mu_{n-1}\geq\mu_n=0\)</span>.
Then</strong> <span class="math display">\[
\tau(G)=\frac{1}{n}\mu_1\mu_2\cdots\mu_{n-1}
\]</span></p>
<hr />
<p><strong>Proof</strong></p>
<p>Let <span class="math inline">\(L(G)\)</span> be the Laplacian matrix
and let <span class="math display">\[
det(L(G)-\lambda
I)=(\mu_1-\lambda)(\mu_2-\lambda)\cdots(\mu_n-\lambda)=-\lambda(\mu_1-\lambda)(\mu_2-\lambda)\cdots(\mu_{n-1}-\lambda)
\]</span> So the cofficient of <span
class="math inline">\(\lambda\)</span> term is <span
class="math inline">\(-\mu_1\mu_2\cdots\mu_{n-1}\)</span>. Note that,
consider <span class="math inline">\(L(G)-\lambda I\)</span>.</p>
<p>Add all rows of <span class="math inline">\(L(G)-\lambda I\)</span>
except the first row to the first row, and let <span
class="math inline">\(M(\lambda)\)</span> be the new resulting
matrix.</p>
<p>Then <span class="math inline">\(det(M(\lambda))=det(L(G)-\lambda
I)\)</span> and the first row of <span
class="math inline">\(M(\lambda)=[-\lambda,-\lambda,\cdots,-\lambda]\)</span>.</p>
<p>Let <span class="math inline">\(N(\lambda)\)</span> be the resulting
matrix obtained from <span class="math inline">\(M(\lambda)\)</span> by
factoring out <span class="math inline">\(-\lambda\)</span>.</p>
<p>Then <span class="math inline">\(M(\lambda)=-\lambda
N(\lambda)\)</span> and <span
class="math inline">\(det(M(\lambda))=-\lambda det(N(\lambda))\)</span>,
So <span class="math display">\[
det(L(G)-\lambda I)=-\lambda det(N(\lambda))
\]</span> Therefore, the cofficient of <span
class="math inline">\(\lambda\)</span> term in <span
class="math inline">\(det(L(G)-\lambda I)\)</span>is equal to <span
class="math inline">\(-det(N(0))\)</span>.</p>
<p>Add all columns of <span class="math inline">\(N(0)\)</span> except
the first column to the first column.</p>
<p><font color='red'>(Note that <span
class="math inline">\(i^{th}\)</span>-row <span
class="math inline">\((i&gt;1)\)</span> of <span
class="math inline">\(N(0)\)</span> is the same as the  <span
class="math inline">\(i^{th}\)</span>-row <span
class="math inline">\((i&gt;1)\)</span> of <span
class="math inline">\(L(G)\)</span></font></p>
<p>Then the first column of the new matrix is <span
class="math inline">\(\left[\begin{matrix}n&amp;0&amp;0&amp;\cdots&amp;0\end{matrix}\right]^T\)</span>.</p>
<p>Use Laplace expansion along the <span
class="math inline">\(1^{st}\)</span> column, <span
class="math inline">\(det(N(0))=n\cdot det(L_0(G))\)</span> <span
class="math display">\[
n\cdot det(L_0(G))=(-1)\cdot(-\mu_1\mu_2\cdots\mu_{n-1})\Rightarrow
det(L_0(G))=\frac{1}{n}\mu_1\mu_2\cdots\mu_{n-1}
\]</span> By previous theorem, <span class="math display">\[
\tau(G)=\frac{1}{n}\mu_1\mu_2\cdots\mu_{n-1}
\]</span></p>
<hr />
]]></content>
      <categories>
        <category>Graph Theory</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Operation Research</tag>
      </tags>
  </entry>
  <entry>
    <title>Lecture series on graph theory 6</title>
    <url>/2022/05/24/Graph6/</url>
    <content><![CDATA[<p><strong>Interlacing Theorem</strong></p>
<p><strong>Thm(Eigenvalue Interlacing Theorem)<br>Let A be a symmetric
real <span class="math inline">\(n\times n\)</span> and let B be an m-th
principal submatrix<font color='red'>(obtained by deleting both i-th row
and i-th column for some n-m values of i)</font>. Suppose A has
eigenvalues <span
class="math inline">\(\lambda_1\geq\cdots\geq\lambda_n\)</span>, and B
has eigenvalues <span
class="math inline">\(\beta_1\geq\cdots\geq\beta_m\)</span>.Then</strong>
<span class="math display">\[
\lambda_k\geq\beta_k\geq\lambda_{k+(n-m)},\qquad k=1,2,\dots,m
\]</span> <span id="more"></span></p>
<p><img
src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220226/2022-05-24_122238.626hmwj3vik0.jpg" /></p>
<p>Further,if <span class="math inline">\(m=n-1\)</span>, then <span
class="math display">\[
\lambda_1\geq\beta_1\geq\lambda_2\geq\beta_2\geq\cdots\geq\lambda_i\geq\beta_i\geq\lambda_{i+1}\geq\cdots\geq\beta_{n-1}\geq\lambda_{n}
\]</span></p>
<hr />
<p><strong>Proof</strong></p>
<p>Without loss of generality, assume that <span
class="math inline">\(A=\left[\begin{matrix}B&amp;X\\X^T&amp;C\end{matrix}\right]\)</span>
and <span class="math inline">\(\lambda_i\vec{x}_i=A\vec{x}_i\)</span>
for <span class="math inline">\(i\in[n]\)</span> such that all <span
class="math inline">\(\vec{x}_i\)</span> are linearly independent and
normalized, and <span
class="math inline">\(\beta_j\vec{y}_j=B\vec{y}_j\)</span> for <span
class="math inline">\(j\in[m]\)</span> s.t. all <span
class="math inline">\(\vec{y}_j\)</span> are linearly independent and
normalized.</p>
<p>Let <span
class="math inline">\(V=span\{\vec{x}_k,\cdots,\vec{x}_n\}\)</span> and
<span
class="math inline">\(W=span\{\vec{y}_1,\cdots,\vec{y}_k\}\)</span>.
Extend <span class="math inline">\(W\)</span> to a subspace of <span
class="math inline">\(\mathbb{R}^n\)</span> s.t. <span
class="math display">\[
\widetilde{W}=\left\{\left.\left[\begin{matrix}\vec{w}\\0\end{matrix}\right]\right|\vec{w}\in
W\right\}\subset\mathbb{R}^n
\]</span> Then <span class="math inline">\(\dim(V)=n-k+1\)</span> and
<span class="math inline">\(\dim(\widetilde{W})=\dim(W)=k\)</span></p>
<p>Note that both <span class="math inline">\(V\subset
\mathbb{R}^n\)</span> and <span
class="math inline">\(\widetilde{W}\subset \mathbb{R}^n\)</span>, and
<span class="math display">\[
\dim(V)+\dim(\widetilde{W})=n-k+1+k=n+1&gt;\dim(\mathbb{R}^n)
\]</span> It follows that there exists a vector <span
class="math inline">\(\tilde{w}\)</span> which satisfies <span
class="math inline">\(\tilde{w}\in V\cap\widetilde{W}\)</span>.</p>
<p><font color='red'><span class="math inline">\(\lambda_k\)</span> is
the largest eigenvalue with an eigenvector in V; <span
class="math inline">\(\beta_k\)</span> is the smallest eigenvalue with
an eigenvector in W.</font></p>
<p>Therefore, <span class="math display">\[
\begin{aligned}
\lambda_k&amp;=\max\{\vec{x}^TA\vec{x}|\vec{x}\in V,||\vec{x}||=1\}\\
&amp;\geq\frac{\tilde{w}^TA\tilde{w}}{\tilde{w}^T\tilde{w}}=\left.\left[\begin{matrix}\vec{w}^T&amp;0\end{matrix}\right]\left[\begin{matrix}B&amp;X\\X^T&amp;C\end{matrix}\right]\left[\begin{matrix}\vec{w}\\0\end{matrix}\right]\right/\left[\begin{matrix}\vec{w}^T&amp;0\end{matrix}\right]\left[\begin{matrix}\vec{w}\\0\end{matrix}\right]\\
&amp;=\frac{\tilde{w}^TB\tilde{w}}{\tilde{w}^T\tilde{w}}\geq\min\{\vec{y}^TA\vec{y}|\vec{y}\in
W,||\vec{y}||=1\}=\beta_k
\end{aligned}
\]</span> So we have <span
class="math inline">\(\lambda_k\geq\beta_k\)</span>.</p>
<p>On the other hand, let <span
class="math inline">\(V=span\{\vec{x}_1,\cdots,\vec{x}_{k+n-m}\}\)</span>
<font color='red'>(i.e. <span
class="math inline">\(\lambda_{k+n-m}\)</span> is the smallest
eigenvalue with an eigenvector in V)</font> and <span
class="math inline">\(W=span\{\vec{y}_1,\cdots,\vec{y}_{k+n-m}\}\)</span>
<font color='red'>(i.e. <span class="math inline">\(\beta_k\)</span> is
the largest eigenvalue with an eigenvector in W)</font>.</p>
<p>Let <span
class="math inline">\(\widetilde{W}=\left\{\left.\left[\begin{matrix}\vec{w}\\0\end{matrix}\right]\right|\vec{w}\in
W\right\}\subset\mathbb{R}^n\)</span>. Then <span
class="math inline">\(\dim(V)=k+n-m\)</span> and <span
class="math inline">\(\dim(\widetilde{W})=m-k+1\)</span>.</p>
<p>Therefore, <span
class="math inline">\(\dim(V)+\dim(\widetilde{W})=n-k+1+k=n+1&gt;\dim(\mathbb{R}^n)\)</span></p>
<p>It follows that there exists a vector <span
class="math inline">\(\tilde{w}\)</span> which satisfies <span
class="math inline">\(\tilde{w}\in V\cap\widetilde{W}\)</span>. <span
class="math display">\[
\begin{aligned}
\lambda_{k+n-m}&amp;=\min\{\vec{x}^TA\vec{x}|\vec{x}\in
V,||\vec{x}||=1\}\\
&amp;\leq\frac{\tilde{w}^TA\tilde{w}}{\tilde{w}^T\tilde{w}}=\left.\left[\begin{matrix}\vec{w}^T&amp;0\end{matrix}\right]\left[\begin{matrix}B&amp;X\\X^T&amp;C\end{matrix}\right]\left[\begin{matrix}\vec{w}\\0\end{matrix}\right]\right/\left[\begin{matrix}\vec{w}^T&amp;0\end{matrix}\right]\left[\begin{matrix}\vec{w}\\0\end{matrix}\right]\\
&amp;=\frac{\tilde{w}^TB\tilde{w}}{\tilde{w}^T\tilde{w}}\leq\max\{\vec{y}^TA\vec{y}|\vec{y}\in
W,||\vec{y}||=1\}=\beta_k
\end{aligned}
\]</span> So <span
class="math inline">\(\lambda_{k+n-m}\leq\beta_k\)</span>.</p>
<p><strong>Bounding degree of induced subgraph</strong></p>
<p><img
src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220226/2022-05-24_162631.52l2utvvt9c0.jpg" /></p>
<p><strong>Thm(Huang,2019) Let H be an induced subgraph of the
n-dimensional hypercube <span class="math inline">\(Q_n\)</span>. If
<span
class="math inline">\(|V(H)|&gt;2^{n-1}=\frac{|V(Q)|}{2}\)</span>,then
<span class="math inline">\(\Delta (H)\geq\sqrt{n}\)</span></strong></p>
<p><font color='red'><strong>n-dimensional hypercube <span
class="math inline">\(Q_n\)</span></strong></font></p>
<p><img
src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220226/2022-05-24_163151.69hvpww08lw0.jpg" /></p>
<p><font color='red'>An n-dimensional hypercube <span
class="math inline">\(Q_n\)</span> is a graph with vertex set consisting
of all <span class="math inline">\(\{0,1\}\)</span>-sequences of length
n and two vertices are adjacent to each other if and only if the
two <span class="math inline">\(\{0,1\}\)</span>-sequences has exactly
one position different</font></p>
<p>The adjacency matrix of n-dimensional hypercube <span
class="math inline">\(Q_n\)</span> satisfies the following</p>
<p><img
src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220226/2022-05-24_163613.2kylzo171uo0.jpg" /></p>
<p>If we give every edge in n-dimensional hypercube <span
class="math inline">\(Q_n\)</span> a sign, we can get a signed adjacency
matrix.</p>
<p><img
src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220226/2022-05-24_163633.44mufz49sju0.jpg" /></p>
<p><strong>Lemma The signed n-dimensional hypercube with adjacency
matrix <span class="math inline">\(S_n\)</span> has an eigenvalue <span
class="math inline">\(\sqrt{n}\)</span> of multiplicity <span
class="math inline">\(2^{n-1}\)</span> and eigenvalue <span
class="math inline">\(-\sqrt{n}\)</span> with multiplicity <span
class="math inline">\(2^{n-1}\)</span></strong></p>
<hr />
<p><strong>Proof</strong></p>
<p><strong>claim: <span
class="math inline">\(S_n^2=nI\)</span></strong></p>
<p>If <span class="math inline">\(n=1\)</span>, <span
class="math inline">\(S_1=\left[\begin{matrix}0&amp;1\\1&amp;0\end{matrix}\right],S_1^2=I\)</span>.
Assume that <span class="math inline">\(S_{n-1}^2=(n-1)I\)</span></p>
<p>Then <span class="math display">\[
S_n^2=\left[\begin{matrix}S_{n-1}&amp;I\\I&amp;-S_{n-1}\end{matrix}\right]\left[\begin{matrix}S_{n-1}&amp;I\\I&amp;-S_{n-1}\end{matrix}\right]=\left[\begin{matrix}S_{n-1}^2+I&amp;O\\O&amp;S_{n-1}^2+I\end{matrix}\right]=nI
\]</span> So claim holds.</p>
<p>Note that <span class="math inline">\(nI\)</span> has eigenvalues n.
Therefore, <span class="math inline">\(S_n\)</span> has eigenvalues
either <span class="math inline">\(\sqrt{n}\)</span> or <span
class="math inline">\(-\sqrt{n}\)</span>.</p>
<p>Since the trace of <span class="math inline">\(S_n\)</span> is 0,
<span class="math inline">\(S_n\)</span> has eigenvalues <span
class="math inline">\(\sqrt{n}\)</span> of multiplicity <span
class="math inline">\(2^{n-1}\)</span> and <span
class="math inline">\(-\sqrt{n}\)</span> with multiplicity <span
class="math inline">\(2^{n-1}\)</span>.</p>
<hr />
<p><strong>Proof of Huang's Theorem</strong></p>
<p>Let H be a induced subgraph of <span
class="math inline">\(Q_n\)</span> with more than <span
class="math inline">\(2^{n-1}\)</span> vertices. It suffices to show
that every subgraph H with exactly <span
class="math inline">\(2^{n-1}+1\)</span> vertices has maximum degree at
least <span class="math inline">\(\sqrt{n}\)</span>.</p>
<p>Let <span class="math inline">\((Q_n,\sigma)\)</span> be the signed
graph with adjacency matrix <span class="math inline">\(S_n\)</span> as
defined above. Then <span class="math inline">\((H,\sigma)\)</span> is a
signed induced subgraph of <span
class="math inline">\((Q_n,\sigma)\)</span>, whose adjacency matrix
<span class="math inline">\(A\)</span> is a <span
class="math inline">\((2^{n-1}+1)\)</span>-principle submatrix of <span
class="math inline">\(S_n\)</span>.</p>
<p>By the proposition <font color='red'>(i.e. <span
class="math inline">\(|\lambda(H,\sigma)|\leq\Delta (H)\)</span></font>
and the interlacing theorem <span class="math display">\[
\Delta
(H)\geq\lambda_1(A)\geq\lambda_{1+2^n-(2^{n-1}+1)}(S_n)=\lambda_{2^{n-1}}(S_n)=\sqrt{n}
\]</span> <span class="math inline">\(\lambda_1(A)\)</span> means the
largest eigenvalue of A.</p>
<hr />
<p><strong>Unfriendly partitions of subcubic graphs</strong></p>
<p>A graph G is subcubic if the maximum degree of G is at most 3.
<font color='red'>(<span
class="math inline">\(\Delta(G)\leq3\)</span>)</font></p>
<p><font color='red'>Conjecture (Pisanski and Fowler,2012)  <br>All
subcubic graphs except finitely many have median eigenvalues in the
interval<span class="math inline">\([-1,1]\)</span>. There exists a
constant c such that if <span
class="math inline">\(|V(G)|\geq|c|\)</span>, then <span
class="math inline">\(\lambda_{\lfloor\frac{\lambda+1}{2}\rfloor},\lambda_{\lceil\frac{\lambda+1}{2}\rceil}\in[-1,1]\)</span></font></p>
<p>Let G be a graph. A partition <span
class="math inline">\((X,Y)\)</span> of <span
class="math inline">\(V(G)\)</span> is unfriendly if every vertex has at
least the same number of neighbors in the other subset as in it
owns.</p>
<p><font color='red'>In other words, for every vertex v of G, <span
class="math inline">\(d_{G[x]}(v)\leq\frac{1}{2}d_G(v)\)</span>
and <span
class="math inline">\(d_{G[Y]}(v)\leq\frac{1}{2}d_G(v)\)</span></font></p>
<p>If <span class="math inline">\((X,Y)\)</span> is an unfriendly
partition of a subcubic graph <span class="math inline">\(G\)</span>,
then the maximum degree of the induced subgraph <span
class="math inline">\(G[X]\)</span> and <span
class="math inline">\(G[Y]\)</span> is at most 1.</p>
<p>An unfriendly partition <span class="math inline">\((X,Y)\)</span> is
unbalanced if <span class="math inline">\(|X|\not=|Y|\)</span></p>
<p>A partition is a bisection if <span
class="math inline">\(\Big||X|-|Y|\Big|\leq1\)</span></p>
<p><strong>Proposition Let G be a subcubic graph with n vertices. If G
has an unbalanced unfriendly partition, then</strong> <span
class="math display">\[
\lambda_{\lfloor\frac{n+1}{2}\rfloor}\in[-1,1]\qquad\lambda_{\lceil\frac{n+1}{2}\rceil}\in[-1,1]
\]</span></p>
<hr />
<p><strong>Proof</strong></p>
<p>Let G be a subcubic graph with n vertices and <span
class="math inline">\((X,Y)\)</span> be an unbalanced unfriendly
partition.</p>
<p>Without loss of generality, assume that <span
class="math inline">\(|X|&gt;|Y|\)</span></p>
<p>Then <span
class="math inline">\(\lambda_1(X)\leq\Delta(X)\leq1\)</span> and <span
class="math inline">\(\lambda_1(Y)\leq\Delta(Y)\leq1\)</span>. So both X
and Y are bipartite.</p>
<p>All eigenvalues of <span class="math inline">\(X\)</span> and <span
class="math inline">\(Y\)</span> belong to <span
class="math inline">\([-1,1]\)</span>. Since <span
class="math inline">\(|X|&gt;|Y|\)</span>, it holds that <span
class="math display">\[
|X|\geq\left\lceil
\frac{n}{2}\right\rceil+1&gt;\frac{n}{2}&gt;\left\lceil
\frac{n}{2}\right\rceil-1\geq|Y|
\]</span> It follows that the interlacing theorem that <span
class="math display">\[
1\geq\lambda_1(X)\geq\lambda_{1+n-|X|}(G)\geq\lambda_{1+n-(\lceil\frac{n}{2}\rceil+1)}(G)\geq\lambda_{\left\lfloor
\frac{n+1}{2}\right\rfloor}(G)\geq\lambda_{\left\lceil
\frac{n+1}{2}\right\rceil}(G)\geq\lambda_{\left\lceil
\frac{n+1}{2}\right\rceil}(X)\geq-1
\]</span> The completes the proof.</p>
<hr />
<p><font color='red'>Q: Does every subcubic graph have an unbalanced
unfriendly partition?</font></p>
<p><font color='red'>A: No</font></p>
<p><img
src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220226/2022-05-26_005635.7fv36qke8og0.jpg" /></p>
<p><font color='red'>Conjecture(Ban&amp;Linal,2016) Every cubic graph
has an unfriendly almost balanced partition <span
class="math inline">\((X,Y)\)</span> s.t. <span
class="math inline">\(\Big||X|-|Y|\Big|\leq2\)</span></font></p>
]]></content>
      <categories>
        <category>Graph Theory</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Operation Research</tag>
      </tags>
  </entry>
  <entry>
    <title>Lecture series on graph theory 5</title>
    <url>/2022/05/22/Graph5/</url>
    <content><![CDATA[<p>Let G be a finite graph. We consider a random walk on the vertices of
G of the following type. Start at a vertex <span
class="math inline">\(v\)</span> .<font color='red'>(v could be chosen
randomly according to some probably distribution or could be specified
in advance).</font> Among all edges incident to v, choose one uniformly
at random<font color='red'>( i.e. if <span
class="math inline">\(d_G(v)=d\)</span>, each of these edges is chosen
with probability 1/d)</font></p>
<p><strong>Problem: determine the probability of being at a given vertex
after a given number steps.</strong></p>
<span id="more"></span>
<p>Let M(G) be the matrix whose rows and columns are indexed by vertices
<span class="math inline">\(v_1,\dots,v_n\)</span>, we assume that <span
class="math inline">\(m_{ij}\)</span> is the <span
class="math inline">\((i,j)\)</span>-entry of M(G), which satisfies the
following formula <span class="math display">\[
m_{ij}=\frac{a_{ij}}{d_i}
\]</span> where <span class="math inline">\(a_{ij}\)</span> is the
number of edges between <span class="math inline">\(v_i\)</span> and
<span class="math inline">\(v_j\)</span>. The <span
class="math inline">\(m_{ij}\)</span> is probability that if one starts
at <span class="math inline">\(v_i\)</span> and then the next step will
be at <span class="math inline">\(v_j\)</span>.</p>
<p><font color='red'>Recall: the number of k-walks from <span
class="math inline">\(v_i\)</span> to <span
class="math inline">\(v_j\)</span>= the <span
class="math inline">\((i,j)\)</span>-entry of <span
class="math inline">\(A(G)^k\)</span></font></p>
<p><span class="math inline">\(\exists v_ie_1v_{i_1}e_2v_{i_2}\cdots
e_kv_j,\ P(v_ie_1v_{i_1}e_2v_{i_2}\cdots
e_kv_j)=\frac{a_{ii_1}}{d_i}\frac{a_{i_1i_2}}{d_{i_1}}\cdots\frac{a_{i_{k-1}i_j}}{d_{i_{k-1}}}=m_{ii_1}m_{i_1i_2}\cdots
m_{i_{k-1}j}\)</span> <span class="math display">\[
\begin{aligned}
P(v_i\to v_j\ in\ k\ steps)&amp;=\sum_{k-walk\ from\ v_i\to v_j}
P(v_ie_1v_{i_1}e_2v_{i_2}\cdots e_kv_j)\\
&amp;=\sum m_{ii_1}m_{i_1i_2}\cdots m_{i_{k-1}j}=(i,j)-entry\ of\ M(G)^k
\end{aligned}
\]</span> Assume the probability to pick <span
class="math inline">\(v_i\)</span> is <span
class="math inline">\(p(v_i)\)</span> for <span
class="math inline">\(i\in\{1,\dots,n\}\)</span> s.t. <span
class="math inline">\(\sum_{i=1}^n p(v_i)=1\)</span></p>
<p>Let <span
class="math inline">\(P=[\begin{matrix}p(v_1)&amp;p(v_2)&amp;\cdots&amp;p(v_n)\end{matrix}]\)</span>.
Then the probability of a walk ending up at <span
class="math inline">\(v_i\)</span> in k steps is <span
class="math display">\[
P(there\ is\ a\ walk\ ending\ up\ at\ v_i\ in\ k\ steps)=[PM(G)^k]_i
\]</span> If G is k regular <font color='red'>( every vertex has degree
k)</font> then <span
class="math inline">\(M(G)=\frac{1}{d}A(G)\)</span></p>
<p>Then the eigenvalue <span class="math inline">\(\beta_i\)</span> of
<span class="math inline">\(M(G)\)</span> satisfies <span
class="math inline">\(\beta_1=\frac{1}{d}\lambda_i\)</span> where <span
class="math inline">\(\lambda_i\)</span> is an eigenvalue of G. <span
class="math display">\[
P(\exists\ a\ closed\ k-walk\ starting\
v)=\beta_1^k+\cdots+\beta_n^k=\frac{1}{d^k}(\lambda_1^k+\cdots+\lambda_n^k)
\]</span> <strong>Weighted graphs and digraphs</strong></p>
<p>Let G be a graph. A weighted graph is a graph G associated with a
weight function: <span
class="math inline">\(w:E(G)\to\mathbb{F}\)</span> where <span
class="math inline">\(\mathbb{F}\)</span> is a field, denote by <span
class="math inline">\((G,w)\)</span>. Most of the time, we consider the
case that <span
class="math inline">\(\mathbb{F}=\mathbb{R}\)</span>.</p>
<p>The adjacency matrix of a weighted graph is a real symmetric matrix
<span class="math inline">\(A(G,w)=(a_{ij})_{n\times n}\)</span> with
<span class="math inline">\(a_{ij}=w(v_iv_j)\)</span>, the weight of the
edge of <span class="math inline">\(v_iv_j\)</span>.</p>
<p>Let H be a subgraph of <span class="math inline">\((G,w)\)</span>.
The weight of H is defined as <span
class="math inline">\(w(H)=\sum_{e\in E(H)}w(e)\)</span></p>
<p>For example, how to find a minimum weight path between two given
vertices? How to find a minimum spanning tree or how to find a cycle or
walk with large weight<font color='red'>( so-called heavy cycles or
walks)</font></p>
<p>A digraph is a graph with an orientation which assigns an orientation
to each edge.</p>
<p><img
src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220226/2022-05-23_002508.6gvjbxprb7g0.jpg" /></p>
<p><font color='red'>An orientation edge (or arc) from <span
class="math inline">\(v_i\)</span> to <span
class="math inline">\(v_j\)</span> is an ordered pair of vertices ,
denoted by <span class="math inline">\((v_i,v_j)\)</span> where <span
class="math inline">\(v_i\)</span> is called the tail and <span
class="math inline">\(v_j\)</span> is called the head of arc.</font>
<span class="math display">\[
A(D,w)=[a_{ij}]_{n\times n}\  where\ a_{ij}=\left\{\begin{aligned}&amp;
w(v_iv_j),\quad v_i\to v_j\\
&amp;-w(v_iv_j),\quad v_j\to v_i\\
&amp;0,\quad otherwise\end{aligned}\right.
\]</span> Then <span class="math inline">\(A(D,w)\)</span> is no longer
symmetric <font color='red'>but skew-symmetric:<span
class="math inline">\(A+A^T=O\)</span></font></p>
<p>For a given graph G, let D be an orientation of G, <span
class="math inline">\(\vec{B}\)</span> is an oriented incidence matrix
<span class="math display">\[
\vec{B}\cdot \vec{f}=\vec{b}\ where\ \vec{b}\in\mathbb{R}^{|V(G)|},\
\vec{f}\in\mathbb{R}^{|E(G)|}
\]</span> A solution to <span class="math inline">\(\vec{B}\cdot
\vec{f}=\vec{b}\)</span> is called a network flow. <span
class="math inline">\(\vec{b}\)</span> is called a boundary
condition.</p>
<p>If <span class="math inline">\(\vec{b}=\vec{0},\ \vec{B}\cdot
\vec{f}=\vec{0}.\qquad(*)\)</span></p>
<p>A vector <span class="math inline">\(\vec{f}\)</span> satisfies <span
class="math inline">\((*)\)</span> is called a circulation or real flow
if <span
class="math inline">\(\vec{f}\in\mathbb{R}^{|E(G)|}\)</span>.</p>
<p>If a solution to <span class="math inline">\((*)\)</span> satisfies
<span class="math inline">\(\vec{f}\in\mathbb{Z}^{|E(G)|}\)</span>, then
<span class="math inline">\(\vec{f}\)</span> is called an integer
flow.</p>
<p><font color='red'>Tutte's five-flow conjecture: For a graph without
bridge, it has a nowhere zero 5-flow i.e. <span
class="math inline">\(\exists \vec{f}\in\mathbb{Z}^{|E(G)|}\)</span> and
every component of f is not zero and absolute value of every component
is at most 4. <span class="math inline">\(\vec{f}=[f_1,
f_2,\cdots,f_m]\)</span> where <span class="math inline">\(m=|E(G)|,\
f_i\in\{-4,-3,-2,-1,0,1,2,3,4\}\)</span></font></p>
<p><strong>Eigenvalues and subgraphs </strong></p>
<p>Let G be a graph with n vertices, <span
class="math inline">\(A(G)\)</span> be the adjacency matrix.</p>
<p>All n eigenvalues of <span class="math inline">\(A(G)\)</span> are
real because <span class="math inline">\(A(G)\)</span> is real and
symmertic <span class="math display">\[
\lambda_1(G)\geq\lambda_2(G)\geq\cdots\geq\lambda_{\lceil
\frac{n+1}{2}\rceil}\geq\lambda_{\lfloor
\frac{n+1}{2}\rfloor}\geq\lambda_n(G)
\]</span> where <span class="math inline">\(\lambda_{\lceil
\frac{n+1}{2}\rceil},\lambda_{\lfloor \frac{n+1}{2}\rfloor}\)</span> are
median eigenvalues.</p>
<p>The largest eigenvalues <span
class="math inline">\(\lambda_1(G)\)</span> is usually called the
spectral radius of G.</p>
<p><strong>Proposition. Let G be an n-vertex graph and A be its
adjacency matrix.Let <span
class="math inline">\(\lambda_1\geq\cdots\geq\lambda_n\)</span> be the
eigenvalues of A<br>Then 1. <span class="math inline">\(\lambda_1
=\max_{\vec{x}\not=\vec{0}}\frac{\vec{x}^TA\vec{x}}{\vec{x}^T\vec{x}}\)</span>,
2. <span
class="math inline">\(\lambda_1\geq|\lambda_n|\)</span></strong></p>
<hr />
<p><strong>Proof</strong></p>
<p>1.The eigenvalues of A (say <span
class="math inline">\(\vec{u}_1,\vec{u}_2,\dots,\vec{u}_n\)</span>) can
be chosen as a standard orthogonal basis of <span
class="math inline">\(\mathbb{R}^n\)</span>.</p>
<p>Assume that array (<span
class="math inline">\(x_1,x_2,\dots,x_n\)</span>) is the coordinate of
<span class="math inline">\(\vec{x}\)</span> under this basis <span
class="math display">\[
\frac{\vec{x}^TA\vec{x}}{\vec{x}^T\vec{x}}=\frac{\lambda_1x_1^2+\cdots+\lambda_nx_n^2}{x_1^2+\cdots+x_n^2}\leq\lambda_1
\]</span> with equality holds if and only if <span
class="math inline">\(x_1\not= 0\)</span> and <span
class="math inline">\(x_i=0\)</span> for <span
class="math inline">\(i=\{2,\cdots,n\}\)</span>, i.e. <span
class="math inline">\(\vec{x}\)</span> is exactly an eigenvector of
<span class="math inline">\(\lambda_1\)</span>.</p>
<ol start="2" type="1">
<li><p>Let <span class="math inline">\(\vec{v}\)</span> be get from
<span class="math inline">\(\vec{u}_n\)</span> by convert each component
into its absolute value (i.e. <span
class="math inline">\(\vec{v}=(|\vec{u}_n(1)|,|\vec{u}_n(2)|,\cdots,|\vec{u}_n(n)|)\)</span>)</p>
<p>From proof of 1. we can write <span
class="math inline">\(\lambda_n\)</span> as <span
class="math display">\[
|\lambda_n|=|\frac{\vec{u}^T_nA\vec{u}_n}{\vec{u}_n^T\vec{u}_n}|=|\vec{u}^T_nA\vec{u}_n|\leq\sum_{i,j\in[n]}A(i,j)|\vec{u}_n(i)\vec{u}_n(j)|=|\frac{\vec{v}^TA\vec{v}}{\vec{v}^T\vec{v}}|\leq\lambda_1
\]</span> We have used triangle inequality at the first inequality and
the result of 1. at the second inequality.</p></li>
</ol>
<hr />
<p><strong>Propsition. Let G be a graph, and <span
class="math inline">\(\Delta (G)\)</span> be the maximum degree and
<span class="math inline">\(d(G)\)</span> be the average degree. Then we
have </strong> <span class="math display">\[
d(G)\leq\lambda_1\leq\Delta (G)
\]</span></p>
<hr />
<p><strong>Proof</strong></p>
<p>Note that, there exist <span
class="math inline">\(\vec{x}\not=\vec{0}\)</span>, s.t. <span
class="math inline">\(A\vec{x}=\lambda\vec{x}\)</span> where A is the
adjacency matrix. <span class="math display">\[
\lambda_1=\sup\{\vec{x}^TA\vec{x}\Big|||\vec{x}||=1\ and\
\vec{x}\in\mathbb{R}^n\}
\]</span> Let <span
class="math inline">\(\vec{x}_1=\frac{1}{\sqrt{n}}[\begin{matrix}1&amp;1&amp;\dots&amp;1\end{matrix}]^T\)</span>,
then <span class="math display">\[
\begin{aligned}\lambda_1&amp;\geq
\vec{x}_1^TA\vec{x}_1=\frac{1}{\sqrt{n}}[\begin{matrix}1&amp;1&amp;\dots&amp;1\end{matrix}]A\frac{1}{\sqrt{n}}[\begin{matrix}1&amp;1&amp;\dots&amp;1\end{matrix}]^T\\
&amp;=\frac{1}{n}[\begin{matrix}1&amp;1&amp;\dots&amp;1\end{matrix}][\begin{matrix}d(v_1)&amp;d(v_2)&amp;\cdots&amp;d(v_n)\end{matrix}]^T\\
&amp;=\frac{1}{n}\sum_{i=1}^nd(v_i)=d(G)\end{aligned}
\]</span> For the upper bound, let <span
class="math inline">\(\vec{x}\)</span> s.t. <span
class="math inline">\(A\vec{x}=\lambda_1\vec{x}\)</span> where <span
class="math inline">\(\vec{x}=[\begin{matrix}x_1&amp;x_2&amp;\cdots&amp;x_n\end{matrix}]^T\)</span></p>
<p>Let <span class="math inline">\(x_i\)</span> be the largest value
among all components of <span class="math inline">\(\vec{x}\)</span>.
Then, <span class="math display">\[
\lambda_1 x_i=\sum_{v_iv_j\in E(G)}x_j\leq\Delta(G)x_j
\]</span> So <span class="math inline">\(\lambda_1\leq\Delta
(G)\)</span> follows.</p>
<hr />
<p><strong>Corollary Let G be a k-regular graph. Then <span
class="math inline">\(\lambda_1(G)=k\)</span></strong></p>
<p>A signed graph <span class="math inline">\((G,\sigma)\)</span> is a
weighted graph s.t. <span class="math inline">\(\sigma:\
E(G)\to\{-1,1\}\)</span> <span class="math display">\[
A(G,\sigma)=[a_{ij}]_{n\times n}\ where\
a_{ij}=\left\{\begin{aligned}&amp;\sigma(v_iv_j),\quad v_iv_j\in
E(G)\\&amp;0,\quad otherwise\end{aligned}\right.
\]</span> So <span class="math inline">\(A(G,\sigma)\)</span> is a
symmetric real matrix.</p>
<p>We can assume that <span
class="math inline">\(\lambda_1(G,\sigma)\geq\lambda_2(G,\sigma)\geq\cdots\geq\lambda_n(G,\sigma)\)</span>,
<font color='red'>but <span
class="math inline">\(\lambda_1(G,\sigma)\geq|\lambda_n(G,\sigma)|\)</span> may
not hold.</font></p>
<p><strong>Prop. Let <span class="math inline">\((G,\sigma)\)</span> be
a signed graph with maximum degree <span class="math inline">\(\Delta
(G)\)</span>. Then</strong> <span class="math display">\[
|\lambda(G,\sigma)|\leq\Delta(G)\ where\ \lambda(G,\sigma)\ is\ an\
eigenvalue\ of\ G
\]</span></p>
<hr />
<p><strong>Proof</strong></p>
<p>Let <span class="math inline">\(\vec{x}\)</span> be an eigenvector of
<span class="math inline">\(\lambda\)</span> s.t. <span
class="math inline">\(\lambda\vec{x}=A\vec{x}\)</span>.</p>
<p>Let <span
class="math inline">\(\vec{x}=[\begin{matrix}x_1&amp;x_2&amp;\cdots&amp;x_n\end{matrix}]^T\)</span>
and <span class="math inline">\(x_i\)</span> has the largest absolute
value among all <span class="math inline">\(x_j\)</span>'s.</p>
<p>Then <span class="math display">\[
|\lambda x_i|=|(A\vec{x})_i|=|\sum_{v_iv_j\in
E(G)}\sigma(v_iv_j)x_j|\leq\sum_{v_iv_j\in E(G)}|x_j|\leq\Delta(G)|x_i|
\]</span> So <span
class="math inline">\(|\lambda|\leq\Delta(G)\)</span></p>
<hr />
<p><strong>Thm A graph G is bipartite <span
class="math inline">\(\Leftrightarrow\)</span> its spectrum is symmetric
about the origin.</strong></p>
<p><font color='red'>(i.e. <span
class="math inline">\(\lambda_i\)</span> is an eigenvalue of G <span
class="math inline">\(\Leftrightarrow\)</span> <span
class="math inline">\(-\lambda_i\)</span> is an eigenvalue of
G)</font></p>
<hr />
<p><strong>Proof</strong></p>
<p><span class="math inline">\(\Rightarrow\)</span> Assume that G is
bipartite.Let A be The adjacency matrix of G. <span
class="math display">\[
A=\left[\begin{matrix}O&amp;B\\B^T&amp;O\end{matrix}\right]\ where\ B\
is\ the\ bipartite\ adjacency\ matrix.
\]</span> Let <span class="math inline">\(\lambda\)</span> be an
eigenvalue of G with <span
class="math inline">\(\vec{x}=(\begin{matrix}\vec{x}_1^T&amp;\vec{x}_2^T\end{matrix})^T\)</span></p>
<p>Then <span class="math display">\[
A\vec{x}=\left(\begin{matrix}O&amp;B\\B^T&amp;O\end{matrix}\right)\left(\begin{matrix}\vec{x}_1\\\vec{x}_2\end{matrix}\right)=\left(\begin{matrix}B\vec{x}_2\\B^T\vec{x}_1\end{matrix}\right)=\lambda\left(\begin{matrix}\vec{x}_1\\\vec{x}_2\end{matrix}\right)
\]</span> Then <span class="math display">\[
A\left(\begin{matrix}\vec{x}_1\\-\vec{x}_2\end{matrix}\right)=\left(\begin{matrix}O&amp;B\\B^T&amp;O\end{matrix}\right)\left(\begin{matrix}\vec{x}_1\\-\vec{x}_2\end{matrix}\right)=\left(\begin{matrix}-B\vec{x}_2\\B^T\vec{x}_1\end{matrix}\right)=-\lambda\left(\begin{matrix}\vec{x}_1\\-\vec{x}_2\end{matrix}\right)
\]</span> So <span class="math inline">\(-\lambda\)</span> is also an
eigenvalue of A.</p>
<p><span class="math inline">\(\Leftarrow\)</span> Let <span
class="math inline">\(\lambda_1\geq\cdots\geq\lambda_n\)</span> be all
eigenvalues of G.<font color='red'>(i.e. <span
class="math inline">\(\lambda_i=-\lambda_{n-i+1}\)</span>)</font></p>
<p>For any positive integer k, the matrix <span
class="math inline">\(A^k\)</span> has eigenvalues <span
class="math inline">\(\lambda_1^k,\lambda_2^k,\cdots,\lambda_n^k\)</span></p>
<p>Because G has symmetric specturm, it follows that <span
class="math inline">\(\lambda_1^k+\cdots+\lambda_n^k=0\)</span> if k is
an odd integer. <span class="math display">\[
0=\lambda_1^k+\cdots+\lambda_n^k=w_k(G)
\]</span> <font color='red'><span
class="math inline">\(w_k(G)\)</span> is the total number of close
k-walks.</font></p>
<p>So every closed walk have an even length. Therefore G is
bipartite.</p>
<hr />
<p><font color='red'>Problem: characterize graphs which satisfy #
positive eigenvalues=# negative eigenvalues</font></p>
]]></content>
      <categories>
        <category>Graph Theory</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Operation Research</tag>
      </tags>
  </entry>
  <entry>
    <title>Lecture series on graph theory 7</title>
    <url>/2022/05/26/Graph7/</url>
    <content><![CDATA[<p><strong>Thm(Wilf,1967) Let G be a graph. Then <span
class="math inline">\(\chi(G)\leq\lambda_1(G)+1\)</span>, where <span
class="math inline">\(\chi(G)\)</span> is the chromatic
number</strong></p>
<p>A proper vertex coloring is a map <span
class="math inline">\(c:V(G)\to\mathbb{N}\)</span> s.t. <span
class="math inline">\(c(v_i)\not=c(v_j)\)</span> if <span
class="math inline">\(v_iv_j\in E(G)\)</span>.</p>
<p>A graph is a k-colorable if there exists a proper vertex coloring
<span class="math display">\[
c:V(G)\to\{1,2,\cdots,k\}=[k].
\]</span> <span id="more"></span></p>
<p>The chromatic number of a graph is the smallest integer k s.t. G is
k-colorable, denoted by <span
class="math inline">\(\chi(G)\)</span>.</p>
<p><strong>(Four color Theorem) Every planar graph is
4-colorable</strong></p>
<p><img
src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220226/2022-05-26_011010.4crr6n46e6o.jpg" /></p>
<p><strong>Lemma Let G be a graph. Then</strong> <span
class="math display">\[
\chi(G)\leq1+p
\]</span> <strong>where <span
class="math inline">\(p=\max\{\delta(H)|\text{H is an induced subgraph
of G}\}\)</span>, <font color='red'><span
class="math inline">\(\delta(G)\)</span> is minimum degree of
H.</font></strong></p>
<hr />
<p><strong>Proof of Lemma</strong></p>
<p>Use greedy algorithm:</p>
<p>Consider that <span
class="math inline">\(c:V(G)\to\mathbb{N}\)</span> such that color the
first vertex by the smallest value and color the k-th vertex by using
the smallest value that has not been used to color any of the first k-1
vertices that are adjacent to the k-th vertex. So it suffices to show
that there is an ordering of the vertices of G for which the greedy
algorithm gives an (1+p)-coloring of G.</p>
<p>Let <span class="math inline">\(x_n\)</span> be a vertex of <span
class="math inline">\(G=H_n\)</span> having degree at most
p.<font color='red'>（<span class="math inline">\(x_n\)</span> could be
the vertex of G with the degree <span
class="math inline">\(\delta(G)\)</span></font></p>
<p>By the definition of the value of p, the subgraph <span
class="math inline">\(H_{n-1}=G-x_n\)</span> has a vertex <span
class="math inline">\(x_{n-1}\)</span> of degree at most p. Continue
this process, let <span
class="math inline">\(H_{n-1}=G-\{x_n,x_{n-1},\cdots,x_{n-i+1}\}\)</span>
which again has a vertex of degree at most p, denoted by <span
class="math inline">\(x_{n-i}\)</span> for <span
class="math inline">\(i\in[n]\)</span></p>
<p>Then <span
class="math inline">\(H_{1}=G-\{x_n,x_{n-1},\cdots,x_{2}\}\)</span> is
an isolated vertex of degree 0.</p>
<p>Then the ordering <span
class="math inline">\(x_1,x_2,\cdots,x_n\)</span> is a desired one.</p>
<hr />
<p><strong>Proof of Wilf's Theorem</strong></p>
<p>Let G be a graph. For any induced subgraph H of G, <span
class="math inline">\(\delta(G)\leq
d(G)\leq\lambda_1(H)\leq\lambda_1(G)\)</span></p>
<p>Therefore, <span class="math inline">\(p=\max\{\delta(H)|\text{H is
an induced subgraph of G}\}\leq\lambda_1(G)\)</span></p>
<p>It follows from the above Lemma <span class="math display">\[
\chi(G)\leq 1+p\leq1+\lambda_1(G)
\]</span></p>
<hr />
<p>If G is k-colorable, let <span
class="math inline">\(c:V(G)\to[k]\)</span> be a k-colorable. <span
class="math inline">\(c^{-1}(i)\)</span>, the preimage of color i, is an
independent set. Independent number of G: <span
class="math inline">\(\alpha(G)\geq\max\left\{|c^{-1}(i)|\big|i\in[k]\right\}\geq
n/k\)</span>.</p>
<p>So <span class="math inline">\(\alpha(G)\geq n/\chi(G)\geq
n/(1+\lambda_1(G))\)</span>.</p>
<p><strong>Coloring, Integer flow</strong></p>
<p>Let G be a graph. An integer flow of G is an ordered pair <span
class="math inline">\((D,f)\)</span> where <span
class="math inline">\(D\)</span> is an orientation of <span
class="math inline">\(G\)</span> and <span
class="math inline">\(f\)</span> is an integer function <span
class="math inline">\(f:E(G)\to\mathbb{Z}\)</span> s.t. for every vertex
v of G <span class="math inline">\(\sum_{e\in E^{+}(v)}f(e)=\sum_{e\in
E^{-}(v)}f(e)\)</span> where <span
class="math inline">\(E^{+}(v)\)</span> is the set of all arcs with
<span class="math inline">\(v\)</span> as tail and <span
class="math inline">\(E^{-}(v)\)</span> is the set of all arcs with v as
head.</p>
<p><font color='red'>Recall: this incidence matrix of D is matrix is
<span class="math inline">\(\vec{B}\)</span> and <span
class="math inline">\(\vec{f}=&lt;f(e_1),\cdots,f(e_m)&gt;\in\mathbb{Z}^m\)</span> where
<span class="math inline">\(m=|E(G)|\)</span> , then <span
class="math inline">\(\vec{B}\cdot\vec{f}=0\)</span>. This vector <span
class="math inline">\(\vec{f}\)</span> is called an integer flow of
G.</font></p>
<p>An integer flow <span class="math inline">\((D,f)\)</span> is
nowhere-zero if <span class="math inline">\(f(e)\not=0\)</span> for all
edges of <span class="math inline">\(G\)</span> <font color='red'>i.e.
<span class="math inline">\(\vec{f}\)</span> has no zero
component.</font></p>
<p>An integer flow <span class="math inline">\((D,f)\)</span> is a
k-flow if <span class="math inline">\(|f(e)|&lt;k\)</span>
<font color='red'>i.e. every component of <span
class="math inline">\(\vec{f}\)</span> has absolute value less than
k.</font></p>
<p>If G has a k-flow, the orientation in the k-flow does not matter.</p>
<p><strong>Proposition Every Eulerian graph has nowhere 2-flow. A
connected graph with a nowhere-zero 2-flow is Eulerian.</strong></p>
<p><strong>Lemma Let <span class="math inline">\((D,f)\)</span> be a
flow of G, then for each <span class="math inline">\(X\subset
V(G)\)</span>, it holds that</strong><br />
<span class="math display">\[
\sum_{e\in E^{+}X}f(e)=\sum_{e\in E^{-}(X)}f(e)
\]</span></p>
<hr />
<p><strong>Proof</strong></p>
<p>Since <span class="math inline">\((D,f)\)</span> is a flow, it
follows that, for every vertex v, <span class="math display">\[
\sum_{e\in E^{+}(v)}f(e)=\sum_{e\in E^{-}(v)}f(e)
\]</span> So <span class="math inline">\(\sum_{e\in
E^{+}(v)}f(e)-\sum_{e\in E^{-}(v)}f(e)=0\)</span></p>
<p>Note that <span class="math display">\[
0=\sum_{v\in X}(\sum_{e\in E^{+}(v)}f(e)-\sum_{e\in
E^{-}(v)}f(e))=\sum_{e\in E^{+}(X)}f(e)-\sum_{e\in E^{-}(X)}f(e)
\]</span></p>
<hr />
<p><strong>Corollary A graph has a nowhere-zero integer flow <span
class="math inline">\(\Leftrightarrow\)</span> it has no
cut-edge.</strong></p>
<hr />
<p><strong>Proof</strong></p>
<p><span class="math inline">\(\Rightarrow\)</span> It follows directly
from the above lemma.</p>
<p><span class="math inline">\(\Leftarrow\)</span> Assume that G has no
cut-edge. Then every edge of G belongs to a cycle.</p>
<p>Let <span class="math inline">\(C=\{C_1,C_2,\cdots,C_k\}\)</span> be
a set of cycles covering all edges of G.</p>
<p>Every <span class="math inline">\(C_1\)</span> has nowhere-zero
2-flow <span class="math inline">\((D,f_1)\)</span> <span
class="math display">\[
f:E(G)\to\mathbb{N}\quad s.t.\ f(e)=\sum_{i=1}^k 2^if_i(e)
\]</span> Then <span class="math inline">\((D,f)\)</span> is a
nowhere-zero integer flow.</p>
<hr />
<p><strong>The Coloring-Flow Duality Theorem (Tutte)<br>Let G be a
2-connected planar graph. Then G is proper face k-colorable if and only
if G has a nowhere-zero k-flow. In other words, let <span
class="math inline">\(G^{\star}\)</span> be its planar dual. Then <span
class="math inline">\(G^{\star}\)</span> is proper k-colorable <span
class="math inline">\(\Leftrightarrow\)</span> G has a nowhere-zero
k-flow.</strong></p>
]]></content>
      <categories>
        <category>Graph Theory</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Operation Research</tag>
      </tags>
  </entry>
  <entry>
    <title>Functional Analysis—Geometric Forms</title>
    <url>/2023/07/03/functional-2/</url>
    <content><![CDATA[<h3 id="hahn-banach定理几何形式凸集分离">1.2
Hahn-Banach定理几何形式——凸集分离</h3>
<p><strong>超平面的定义</strong></p>
<p>超平面(hyperplane)指 <span class="math inline">\(H\subset E\)</span>
且其形如 <span class="math inline">\(H=\{x\in
E|f(x)=\alpha\}=[f=\alpha]\)</span>,其中 <span
class="math inline">\(f\)</span> 为 <span
class="math inline">\(E\)</span> 上非恒为 <span
class="math inline">\(0\)</span> 的线性泛函, <span
class="math inline">\(\alpha\in\mathbb{R}\)</span>
为常数,<font color='red'>(<span class="math inline">\(f\)</span>
不要求连续)</font>, 此时称 <span
class="math inline">\(f(x)=\alpha\)</span> 是超平面 <span
class="math inline">\(H\)</span> 的方程. <span id="more"></span>
我们先针对线性泛函不一定连续这个命题做一些简单的解释.</p>
<p><strong>Proposition 1</strong> 设 <span
class="math inline">\(E\)</span> 是无穷维空间,那么存在 <span
class="math inline">\(E\)</span> 中的Hamel基 <span
class="math inline">\(\{e_i\}\)</span> 满足 <span
class="math inline">\(\Vert e_i\Vert=1\)</span>.</p>
<p><strong>Proof</strong> 我们记 <span class="math inline">\(P\)</span>
为由 <span class="math inline">\(E\)</span> 中线性无关集构成的集合.显然,
<span class="math inline">\(P\)</span> 是诱导集,利用 Zorn 引理可以得到
<span class="math inline">\(P\)</span> 有极大元,不妨我们记其为 <span
class="math inline">\(\{e_i\}_{i\in I}\)</span>,
这就是我们所说的Hamel基. 此时找到的基可能不满足 <span
class="math inline">\(\Vert
e_i\Vert\not=1\)</span>,我们只需要做一次归一化就可以.</p>
<p><strong>Proposition 2</strong>
在上述命题的基础之上，我们可以得到存在这样的函数，他线性但是他不连续。
<strong>Proof</strong> 因为 <span class="math inline">\(E\)</span>
是无穷维空间，因此我们可以假设 <span
class="math inline">\(\mathbb{N}\subset I\)</span>. 那我们就可以构造一个
<span class="math inline">\(E\)</span> 上的特殊函数 <span
class="math inline">\(f\)</span>, <span class="math display">\[
\begin{cases}
&amp;f(e_i)=i,\ i\in\mathbb{N}\\
&amp;f(e_i)=0,\ i\in I\backslash\mathbb{N}
\end{cases}
\]</span></p>
<p><strong>Proposition 2</strong> 超平面 <span
class="math inline">\(H=[f=\alpha]\)</span> 是闭的 <span
class="math inline">\(\Leftrightarrow\)</span> <span
class="math inline">\(f\)</span> 是连续的</p>
<p><strong>Proof</strong> 如果 <span class="math inline">\(f\)</span>
是连续的,显然有超平面 <span class="math inline">\(H\)</span> 是闭的.
<br>反之如果 <span class="math inline">\(H\)</span> 是闭的,那么 <span
class="math inline">\(H^C\)</span> 是开集并且非空<font color='red'>(由
<span class="math inline">\(f\not\equiv0\)</span> 保证)</font>.设 <span
class="math inline">\(x_0\in H^C\)</span>,则 <span
class="math inline">\(f(x_0)\not=\alpha\)</span>.不妨我们假设 <span
class="math inline">\(f(x_0)&lt;\alpha\)</span>, 我们取<span
class="math inline">\(r&gt;0\)</span>,使 <span
class="math inline">\(B(x_0,r)=\{x\in E|\Vert x-x_0\Vert&lt;r\}\subset
H^C\)</span>,则成立 <span class="math inline">\(f(x)&lt;\alpha,\
B(x_0,r)\)</span>.事实上,若存在 <span class="math inline">\(x_1\in
B(x_0,r)\)</span>,使得 <span
class="math inline">\(f(x_1)&gt;\alpha\)</span>,构造线段 <span
class="math inline">\(\{x_t=(1-t)x_0+tx_1|t\in[0,1]\}\)</span> 包含在
<span class="math inline">\(B(x_0,r)\)</span>, 可以由下面的式子保证,
<span class="math display">\[
\Vert x_t-x_0\Vert=\Vert t(x_1-x_0)\Vert\leq\Vert x_1-x_0\Vert&lt;r
\]</span> 因此线段上的点也满足 <span
class="math inline">\(f(x_t)\not=\alpha,\ \forall
t\in[0,1].\)</span></p>
<p>为了后续导出矛盾,我们选取一个特殊的 <span
class="math inline">\(t=\frac{\alpha-f(x_0)}{f(x_1)-f(x_0)}\in(0,1)\)</span>,那么有
<span class="math display">\[
f(x_t)=f((1-t)x_0+tx_1)=f(x_0)+t(f(x_1)-f(x_0))=\alpha
\]</span> 这与 <span class="math inline">\(x_t\in H^C\)</span> 矛盾.
因此有 <span class="math inline">\(f(x_0+rz)\alpha,\ \forall z\in
B(0,1)\)</span>,根据 <span class="math inline">\(f\)</span> 是线性的,
故<span
class="math inline">\(|f(z)|&lt;\frac{1}{r}(\alpha-f(x_0))\)</span>,因此
<span class="math inline">\(f\)</span> 满足 <span
class="math inline">\(\Vert f\Vert\leq
\frac{1}{r}(\alpha-f(x_0))\)</span>.根据有界算子的特性知,有界性和连续性等价.</p>
<p><strong>Def</strong> 设 <span class="math inline">\(A\subset E,
B\subset E\)</span>, 称 <span
class="math inline">\(H=[f=\alpha]\)</span> 分离 <span
class="math inline">\(A\)</span> 和 <span
class="math inline">\(B\)</span>, 若满足 <span class="math display">\[
f(x)\leq\alpha,\ \forall x\in A\ \text{and}\ f(x)\geq\alpha,\ \forall
x\in B.
\]</span> 进一步,我们称 <span class="math inline">\(H\)</span> 严格分离
<span class="math inline">\(A,\ B\)</span>,则若 <span
class="math inline">\(\exists \epsilon&gt;0\)</span>,使 <span
class="math inline">\(f(x)\leq\alpha-\epsilon,\ \forall x\in A\)</span>
且 <span class="math inline">\(f(x)\geq\alpha+\epsilon,\ \forall x\in
B\)</span>.</p>
<p>我们从几何上来看, <span
class="math inline">\(A,B\)</span>分别位于由超平面 <span
class="math inline">\(H\)</span>分割出的两个半平面上,如图所示 <img
src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20240123/屏幕截图-2024-01-23-083637.8h96r3z6ve8.png"
alt="屏幕截图-2024-01-23-083637" /></p>
<p>在此重新明确一下凸集的定义: 如果 <span class="math inline">\(x,y\in
A\)</span>,则要求 <span class="math inline">\(tx+(1-t)y\in A,\
t\in[0,1].\)</span></p>
<p><strong>Thm (Hahn-Banach定理第一几何形式)</strong> 设 <span
class="math inline">\(A\subset E,\ B\subset E\)</span>
为两个互不相交的非空凸集,若 <span class="math inline">\(A\)</span>
是开集, 则存在闭的超平面分离 <span class="math inline">\(A,\
B\)</span>.</p>
<p>为了证明这个定理,我们先给出几个引理,</p>
<p><strong>Lemma 1</strong> 设 <span class="math inline">\(C\subset
E\)</span>是一个凸的开集并且 <span class="math inline">\(0\in
C\)</span>, 针对任意的<span class="math inline">\(x\in C\)</span>,
我们定义如下泛函 <span class="math display">\[
p(x)=\inf\{\alpha&gt;0|\alpha^{-1} x\in C\}
\]</span> 称其为 <span class="math inline">\(C\)</span> 的度量 (gauge),
又称其为 <span class="math inline">\(C\)</span> 的 Minkowski 泛函,则
<span class="math inline">\(p(x)\)</span> 满足下列性质 <span
class="math display">\[
\begin{aligned}&amp;1.\ p(\lambda x)=\lambda p(x),\ \forall x\in E,\
\lambda&gt;0,\\&amp;2.\ p(x+y)\leq p(x)+p(y),\ \forall x,y\in
E,\\&amp;3.\exists M,s.t. 0\leq p(x)\leq M\Vert x\Vert,\ \forall x\in
E\\&amp;4.C=\{x|p(x)&lt;1\}\end{aligned}
\]</span> <strong>Proof</strong> 1.显然成立,即 <span
class="math display">\[
p(\lambda x)=\inf\{\alpha&gt;0|\alpha^{-1}\lambda x\in
C\}=\lambda\inf\{\alpha\lambda^{-1}|(\alpha\lambda^{-1})^{-1}x\in
C\}=\lambda p(x)
\]</span> 下面我们证明3成立,根据题目可得,设 <span
class="math inline">\(r&gt;0\)</span>,我们可以构造一个开球 <span
class="math inline">\(B(0,r)\subset C\)</span>. 显然有 <span
class="math inline">\(p(x)\leq\frac{1}{r}\Vert x\Vert,\ \forall x\in
E\)</span>, 下面给出一定的解释.</p>
<p>当 <span class="math inline">\(x=0\)</span>, 有 <span
class="math inline">\(p(x)=0\)</span>.但 <span
class="math inline">\(x\not=0\)</span> 时,我们可以对<span
class="math inline">\(x\)</span>做单位化,记<span
class="math inline">\(y=\frac{x}{\Vert x\Vert}\)</span>,此处我们取 <span
class="math inline">\(r=\sup\{\delta|\delta\cdot y\in B(0,r)\subset
C\}\)</span>,因此 <span
class="math inline">\(p(y)\leq\frac{1}{r}\Rightarrow
p(x)\leq\frac{1}{r}\Vert x\Vert\)</span>.</p>
<p>下证明 4 成立,设<span class="math inline">\(x\in C\)</span>并且 <span
class="math inline">\(C\)</span> 是开集, 故存在<span
class="math inline">\(\epsilon&gt;0\)</span>,使得 <span
class="math inline">\((1+\epsilon)x\in C\)</span> 成立,因此 <span
class="math inline">\(p(x)\leq\frac{1}{1+\epsilon}&lt;1\)</span>.反之如果有
<span class="math inline">\(p(x)&lt;1\)</span> 成立,那么有 <span
class="math inline">\(0&lt;\alpha&lt;1\)</span>使得 <span
class="math inline">\(\alpha^{-1}x\in C\)</span>.从而有 <span
class="math inline">\(x=\alpha(\alpha^{-1}x)+(1-\alpha)0\in
C\)</span>,这由 <span class="math inline">\(C\)</span>
的凸集性质保证.</p>
<p>下说明 2 成立.设 <span class="math inline">\(\forall x,\ y\in
E\)</span> 并且 <span
class="math inline">\(\epsilon&gt;0\)</span>,由1和4可知 <span
class="math inline">\(\frac{x}{p(x)+\epsilon},\frac{y}{p(y)+\epsilon}\in
C\)</span>.由于C是凸集,因此 <span class="math inline">\(\forall
t\in[0,1]\)</span>,有 <span
class="math inline">\(t\frac{x}{p(x)+\epsilon}+(1-t)\frac{y}{p(y)+\epsilon}\in
C\)</span>.为了给出证明,我们选取特殊的 <span
class="math inline">\(t\)</span> 即 <span
class="math inline">\(t=\frac{p(x)+\epsilon}{p(x)+p(y)+2\epsilon}\)</span>,代入可得
<span class="math inline">\(\frac{x+y}{p(x)+p(y)+2\epsilon}\in
C\)</span>.因此有 <span
class="math inline">\(p(x+y)&lt;p(x)+p(y)+2\epsilon\)</span>,此时我们令
<span class="math inline">\(\epsilon\to0\)</span>,式 2 即可证明.</p>
<p><strong>Lemma 2</strong> 设 <span class="math inline">\(C\subset
E\)</span> 并且 <span class="math inline">\(C\)</span>
是一个非空凸开集.若 <span class="math inline">\(x_0\in E\)</span> 且
<span class="math inline">\(x_0\not\in C\)</span>, 那么就存在 <span
class="math inline">\(f\in E^\star\)</span>,使得 <span
class="math inline">\(f(x)&lt;f(x_0),\ \forall x\in C\)</span>. 特别地,
超平面 <span class="math inline">\([f=f(x_0)]\)</span> 分离了点 <span
class="math inline">\(x_0\)</span> 和集合 <span
class="math inline">\(C\)</span>.</p>
<p><strong>Proof</strong> 我们假设 <span class="math inline">\(0\in
C\)</span> 成立, 不然的话, 我们总可以通过平移来使得其成立,
这并不会对我们的结果造成影响,因此我们直接假设其成立即可. 我们引入 Lemma
1 中定义的 <span class="math inline">\(C\)</span> 的度量 <span
class="math inline">\(p(x)\)</span>. 我们考虑 <span
class="math inline">\(E\)</span> 的线性子空间 <span
class="math inline">\(G=\mathbb{R}x_0\)</span> 和定义在其上的线性泛函
<span class="math inline">\(g(tx_0)=t,\ t\in\mathbb{R}\)</span>.
我们接下来要说明这个线性泛函是被我们前面引入的度量泛函控制的.</p>
<p>1.如果 <span class="math inline">\(t&gt;0\)</span>, 根据 Lemma 1
推导的性质知, <span
class="math inline">\(p(tx_0)=tp(x_0)\)</span>.又根据题设知 <span
class="math inline">\(x_0\not\in C\)</span> 并且 <span
class="math inline">\(0\in C\)</span>, 因此 <span
class="math inline">\(p(x_0)\geq 1,\ p(tx_0)\geq t=g(x)\)</span></p>
<p>2.如果 <span class="math inline">\(t\leq 0\)</span>, <span
class="math inline">\(p(x)\geq g(x)\)</span> 是显然成立的.</p>
<p>由 Hahn-Banach 定理的解析形式, 存在 <span
class="math inline">\(f\)</span> 是 <span
class="math inline">\(E\)</span> 上线性泛函延拓了 <span
class="math inline">\(g\)</span> 并且 <span
class="math inline">\(f(x)\leq p(x),\ \forall x\in E\)</span>. 因此
<span class="math inline">\(f(x_0)=g(x_0)=1\)</span>. 由 Lemma 1
导出的度量泛函性质, 我们可以得到 <span class="math inline">\(f\)</span>
也是有界泛函, 即 <span class="math inline">\(f(x)\leq p(x)\leq M\Vert
x\Vert\)</span>, 所以 <span class="math inline">\(f\)</span>
是连续线性泛函. 根据 Lemma 1 可知, <span
class="math inline">\(f(x)&lt;1,\ \forall x\in C\)</span>.</p>
<p><strong>Proof of Thm</strong> 令 <span
class="math inline">\(C=A-B\)</span> 且 <span
class="math inline">\(C\)</span> 是凸集. 同时 <span
class="math inline">\(C\)</span> 是开集, 这是因为我们可以将 <span
class="math inline">\(C\)</span> 改写成 <span
class="math inline">\(C=\bigcup_{y\in
B}(A-y)\)</span><font color='red'>(题设中 <span
class="math inline">\(A\)</span> 是开集在此应用)</font>, 但是 <span
class="math inline">\(0\not\in C\)</span>. 由 Lemma 2 可知, <span
class="math inline">\(\exists f\in E^\star\)</span>, 使得 <span
class="math inline">\(f(z)&lt;0,\ \forall z\in C\)</span>
<font color='red'>(此处要求 <span
class="math inline">\(f(0)=0\)</span>,如果不成立的话,我们只需要平移
<span class="math inline">\(f\)</span> 即可)</font>. 此式可得到 <span
class="math inline">\(f(x)&lt;f(y),\ \forall x\in A,\ y\in B\)</span>.
此时我们选取 <span class="math inline">\(\alpha\)</span> 满足 <span
class="math inline">\(\sup_{x\in A}f(x)\leq\alpha\leq\inf_{y\in
B}f(y)\)</span>. 因此 <span class="math inline">\([f=\alpha]\)</span>
分离了 <span class="math inline">\(A\)</span> 和 <span
class="math inline">\(B\)</span>.</p>
<p><strong>Thm (Hahn-Banach定理第二几何形式)</strong> 设 <span
class="math inline">\(A\subset E,\ B\subset E\)</span>
是两个互不相交的凸集, 设 <span class="math inline">\(A\)</span> 是闭集,
<span class="math inline">\(B\)</span> 是紧集, 则存在闭超平面严格分离
<span class="math inline">\(A\)</span> 和 <span
class="math inline">\(B\)</span>.</p>
<p><strong>Proof</strong> 令 <span class="math inline">\(C=A-B\)</span>,
同样我们可以得到 <span class="math inline">\(C\)</span> 是凸集. 我们宣称
<span class="math inline">\(C\)</span> 是闭集.</p>
<p>下面给出这个宣称的证明, 若 <span
class="math inline">\(c_n=a_n-b_n\)</span> 且 <span
class="math inline">\(c_n\to c_0\)</span>, 我们只需要说明 <span
class="math inline">\(c_0\in C\)</span> 即完成证明. 由于 <span
class="math inline">\(B\)</span> 是紧集, 因此 <span
class="math inline">\(b_n\to b_0\in B\)</span>. <span
class="math inline">\(a_n=b_n+c_n\to b_0+c_0\in A\)</span>, 因此 <span
class="math inline">\(A\)</span> 是闭集. 此处我们记 <span
class="math inline">\(a_0=b_0+c_0\in A\)</span>, 因此 <span
class="math inline">\(c_0=a_0-b_0\in C\)</span>.</p>
<p>同样我们可知 <span class="math inline">\(0\not\in C\)</span>, 因此
<span class="math inline">\(\exists r&gt;0\)</span>, 使得 <span
class="math inline">\(B(0,r)\cap C=\emptyset\)</span>. 根据 Hahn-Banach
定理第一几何形式, 存在闭超平面分离了 <span
class="math inline">\(B(0,r)\)</span> 和 <span
class="math inline">\(C\)</span>,即 <span class="math display">\[
\exists f\in E^\star,\ f\not\equiv 0,\ f(x-y)\leq f(rz),\ \forall x\in
A,\ y\in B,\ z\in B(0,1).
\]</span> 故 <span class="math inline">\(f(x-y)\leq -r\Vert f\Vert,\
\forall x\in A,\ y\in B.\)</span> <font color='red'>(此式的导出基于
<span class="math inline">\(|f(rz)|=r|f(z)|\leq r\Vert
f\Vert\)</span>)</font>.</p>
<p>令 <span class="math inline">\(\epsilon=\frac{r}{2}\Vert
f\Vert&gt;0\)</span>, 则有 <span class="math inline">\(f(x)+\epsilon\leq
f(y)-\epsilon,\ \forall x\in A,\ y\in B\)</span> 成立. 因此我们选取
<span class="math inline">\(\alpha\)</span> 满足 <span
class="math inline">\(\sup_{x\in A}f(x)+\epsilon\leq\alpha\leq\inf_{y\in
B}f(y)-\epsilon\)</span>, 所以闭超平面 <span
class="math inline">\([f=\alpha]\)</span> 严格分离 <span
class="math inline">\(A\)</span> 和 <span
class="math inline">\(B\)</span>.</p>
<p><strong>Corollary 1</strong> 设 <span class="math inline">\(F\subset
E\)</span> 是 <span class="math inline">\(E\)</span> 的线性子空间, 使得
<span class="math inline">\(\overline{F}\not=E\)</span>, 那么 <span
class="math inline">\(\exists f\in E^\star\)</span> 且 <span
class="math inline">\(f\not\equiv 0\)</span>, 使得 <span
class="math inline">\(\langle f,x\rangle=0,\ \forall x\in
F\)</span>.</p>
<p><strong>Proof</strong> 由题设可知, <span
class="math inline">\(\exists x_0\in E\)</span> 且 <span
class="math inline">\(x_0\not\in \overline{F}\)</span>. 我们记 <span
class="math inline">\(A=\overline{F},\ B=\{x_0\}\)</span>, 显然此处的
<span class="math inline">\(A\)</span> 是闭的, 而 <span
class="math inline">\(B\)</span> 则是紧的. 依托 H-B
定理的第二几何形式可知存在一个闭超平面 <span
class="math inline">\([f=\alpha]\)</span> 严格分离 <span
class="math inline">\(A\)</span> 和 <span
class="math inline">\(B\)</span>, 即 <span class="math inline">\(\langle
f,x\rangle&lt;\alpha&lt;\langle f,x_0\rangle,\ \forall x\in F\)</span>.
因为 <span class="math inline">\(F\)</span> 是线性子空间, 因此有 <span
class="math inline">\(\lambda \langle f,x\rangle&lt;\alpha,\ \forall
\lambda\in\mathbb{R}\Rightarrow \langle f,x\rangle=0,\ \forall x\in
F\)</span>.</p>
<p><strong><font color='red'>Remark</font></strong>
<font color='red'>该推论一般用于判断子空间 <span
class="math inline">\(F\subset E\)</span> 是否在 <span
class="math inline">\(E\)</span> 上稠密. 如果稠密, 则有 <span
class="math inline">\(\forall f\)</span> 满足 <span
class="math inline">\(\langle f,x\rangle=0,\ \forall x\in F\)</span>, 
同时有 <span class="math inline">\(\langle f,x\rangle\equiv0,\ \forall
x\in E\)</span></font></p>
]]></content>
      <categories>
        <category>Functional Analysis</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Functional Analysis</tag>
      </tags>
  </entry>
  <entry>
    <title>Functional Analysis-Bidual Space and Orthogonality Relation</title>
    <url>/2023/08/07/functional-3/</url>
    <content><![CDATA[<h3 id="二次对偶空间和正交关系">1.3 二次对偶空间和正交关系</h3>
<p>设 <span class="math inline">\(E\)</span> 是赋范向量空间, <span
class="math inline">\(E^\star\)</span> 是其对偶空间, 其上定义的范数为
<span class="math display">\[\Vert f\Vert_{E^\star}=\sup_{x\in E,\ \Vert
x\Vert\leq1}|\langle f,x\rangle|,\ f\in E^\star\]</span> 二次对偶空间
<span class="math inline">\(E^{\star\star}\)</span> 则是对偶空间 <span
class="math inline">\(E^\star\)</span> 的对偶空间并且在其上定义的范数为
<span class="math display">\[\Vert \xi \Vert_{E^{\star\star}}=\sup_{f\in
E^\star,\ \Vert f\Vert\leq1}|\langle\xi,f\rangle|,\ \xi\in
E^{\star\star}\]</span> <span id="more"></span>
我们定义典范内射<font color='red'>(canonical injection)</font> <span
class="math inline">\(J:E\to E^{\star\star}\)</span> 如下:</p>
<p>对于给定的 <span class="math inline">\(x\in E\)</span>, 映射 <span
class="math inline">\(f\to\langle f,x\rangle\)</span> 是 <span
class="math inline">\(E^\star\)</span> 上的连续线性泛函, 因此 <span
class="math inline">\(x\)</span> 是 <span
class="math inline">\(E^{\star\star}\)</span> 的元素, 记作 <span
class="math inline">\(Jx\)</span>.</p>
<p><strong><font color='red'>Remark</font></strong>
<font color='red'>对于此映射, 我们固定 <span
class="math inline">\(x\)</span>, 讨论 <span
class="math inline">\(f\)</span> 在 <span
class="math inline">\(E^\star\)</span> 上变化, 则其为 <span
class="math inline">\(E^\star\)</span> 上的连续线性泛函. 反之如果固定
<span class="math inline">\(f\)</span>, 令 <span
class="math inline">\(x\)</span> 在 <span
class="math inline">\(E\)</span> 上变化, 则其为 <span
class="math inline">\(E\)</span> 上的连续线性泛函.</font></p>
<p>因此, 我们有下式成立 <span class="math display">\[\langle
Jx,f\rangle_{E^{\star\star},E^\star}=\langle
f,x\rangle_{E^\star,E}=f(x),\ \forall x\in E,\ f\in E^\star\]</span>
显然映射 <span class="math inline">\(J\)</span> 是线性的且等距的, 即
<span class="math inline">\(\Vert Jx\Vert_{E^{\star\star}}=\Vert
x\Vert\)</span>.</p>
<p>对于等距性, 我们给出一定的解释, <span class="math inline">\(\Vert
Jx\Vert_{E^{\star\star}}=\sup_{f\in E^\star,\Vert f\Vert\leq1}|\langle
f,x\rangle|=\Vert x\Vert\)</span>, 用到了前面文章中的推论.</p>
<p>我们定义的映射 <span class="math inline">\(J\)</span> 并不一定是满射,
也就是说 <span class="math inline">\(J(E)\subset E^{\star\star}\)</span>
可能只是子空间. 如果 <span class="math inline">\(J\)</span> 是满射,
那么我们就将 <span class="math inline">\(E\)</span> 称为自反的, 也就是
<span
class="math inline">\(E=E^{\star\star}\)</span><font color='red'>(二者在等距同构意义之下是相同的)</font></p>
<p>我们引入一些记号, 如果 <span class="math inline">\(M\subset
E\)</span> 是一个线性子空间, 那么我们记 <span
class="math inline">\(M^\perp=\{f\in E^\star|\langle f,x\rangle=0,\
\forall x\in M\}\subset E^\star\)</span>, 其为 <span
class="math inline">\(M\)</span> 的正交空间, 同时其在 <span
class="math inline">\(E^\star\)</span>
上是闭的.<font color='red'>(该集合的含义是作用在 <span
class="math inline">\(M\)</span> 上为 <span
class="math inline">\(0\)</span> 的连续线性泛函的集合)</font>. 同样,
我们可以定义 <span class="math inline">\(E^\star\)</span> 的线性子空间
<span class="math inline">\(N\)</span> 的正交空间为 <span
class="math inline">\(N^\perp=\{x\in E|\langle f,x\rangle=0,\ \forall
f\in E^\star\}\)</span>, 同样其在 <span class="math inline">\(E\)</span>
中是闭的.</p>
<p><strong>Propsition 1</strong> 设 <span class="math inline">\(M\subset
E\)</span> 是线性子空间, 则 <span class="math inline">\(\left(
M^\perp\right)^\perp=\overline{M}\)</span>; <span
class="math inline">\(N\subset E^\star\)</span> 线性子空间, 则 <span
class="math inline">\(\overline{N}\subset\left(N^\perp\right)^\perp\)</span>.</p>
<p><strong>Proof</strong> 显然有 <span
class="math inline">\(M\subset\left( M^\perp\right)^\perp\)</span>,
又因为 <span class="math inline">\(\left( M^\perp\right)^\perp\)</span>
为闭集, 因此有 <span class="math inline">\(\overline{M}\subset\left(
M^\perp\right)^\perp\)</span>. 同样, 我们可以推得 <span
class="math inline">\(\overline{N}\subset\left(
N^\perp\right)^\perp\)</span>.</p>
<p>下面我们要说明 <span class="math inline">\(\left(
M^\perp\right)^\perp\subset \overline{M}\)</span>. 我们采用反证法.
假设存在 <span class="math inline">\(x_0\)</span> 满足 <span
class="math inline">\(x_0\in\left( M^\perp\right)^\perp\)</span> 但是
<span class="math inline">\(x_0\not\in \overline{M}\)</span>.
依据H-B定理的第二几何形式知, 存在一个超平面严格分离 <span
class="math inline">\(\{x_0\}\)</span> 和 <span
class="math inline">\(\overline{M}\)</span>, 即 <span
class="math display">\[
\exists f\in E^\star,\ \alpha\in\mathbb{R},\ \text{使得}\ \langle
f,x\rangle&lt;\alpha&lt;\langle f,x_0\rangle,\ \forall x\in M\Rightarrow
\langle f,x\rangle=0,\ \forall x\in M.
\]</span> 因此 <span class="math inline">\(f\in M^\perp\)</span>, 而
<span class="math inline">\(\langle f,x_0\rangle&gt;0\)</span>, 又由于
<span class="math inline">\(x_0\in \left( M^\perp\right)^\perp\)</span>,
应有 <span class="math inline">\(\langle f,x\rangle=0\)</span>, 矛盾,
因此有 <span class="math inline">\(\left( M^\perp\right)^\perp\subset
\overline{M}\)</span>. 综上所述命题得证.</p>
]]></content>
      <categories>
        <category>Functional Analysis</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Functional Analysis</tag>
      </tags>
  </entry>
  <entry>
    <title>Lecture series on graph theory 8</title>
    <url>/2022/05/27/Graph8/</url>
    <content><![CDATA[<p><strong>Proof of the coloring-flow duality theorem</strong></p>
<span id="more"></span>
<p><span class="math inline">\(\Rightarrow\)</span> Assume that G is
face k-colorable (proper coloring)</p>
<p>We need to show that G has a nowhere-zero k-flow <span
class="math inline">\((D,f)\)</span> <span class="math display">\[
\begin{aligned}
(i.e.
&amp;f:E(G)\to\{-(k-1),-(k-2),\cdots,-1,1,\cdots,k-2,k-1\}\\&amp; s,t,\forall
v\in V(G),\sum_{e\in E^{+}(v)}f(e)=\sum_{e\in E^{-}(v)}f(e))
\end{aligned}
\]</span> Let <span class="math inline">\(F(G)\)</span> be the set of
all faces of G and let <span class="math inline">\(c:F(G)\to[k]\)</span>
be a face coloring.</p>
<p>Assign an orientation <span class="math inline">\(D\)</span> to <span
class="math inline">\(E(G)\)</span>: each edge <span
class="math inline">\(e\in E(G)\)</span> is oriented such that the face
with a smaller color index is on the right side of the arc.</p>
<p><img
src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220226/2022-05-27_121553.4l885wgltpq0.jpg" /></p>
<p>Define a function <span class="math inline">\(f:E(G)\to[k-1]\)</span>
such that <span class="math inline">\(f(e)\)</span> is the absolute
value of the difference of the colors of two faces incident with e.</p>
<p><font color='blue'><strong>claim: <span
class="math inline">\((D,f)\)</span> is a nowhere-zero
k-flow</strong></font></p>
<hr />
<p><strong><font color='blue'>Proof of claim:</font></strong></p>
<p><font color='blue'>Clearly, <span
class="math inline">\(0&lt;f(e)&lt;k\)</span>, because the smallest
color index is 1 and the largest color index is k;and two faces share
edges have different color indices.So f is nowhere-zero.</font></p>
<p><font color='blue'>Let v be vertex of G and <span
class="math inline">\(v_1,v_2,\cdots,v_d\)</span> be all neighbors of v
appearing around v in a clockwise order.Let <span
class="math inline">\(f_i\)</span> be the face containing edges <span
class="math inline">\(vv_1\)</span> and <span
class="math inline">\(vv_{i+1}\)</span> . Note that, for any <span
class="math inline">\(i\not=j,f_i\not=f_j\)</span> because G is
2-connected.</font></p>
<p><font color='blue'>Define</font> <span class="math display">\[
\textcolor{blue}{\epsilon_i=\left\{\begin{aligned}&amp;-1,\quad if\ v\to
v_i\ in\ D\\&amp;1,\quad if\ v_i\to v\ in\ D
\end{aligned}\right.}
\]</span> <font color='blue'>Then, for each <span
class="math inline">\(i\in[d]\)</span></font> <span
class="math display">\[
\textcolor{blue}{c(f_i)=c(f_d)+\sum_{j=1}^i\epsilon_if(vv_j) \tag{*}}
\]</span> <img
src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220226/2022-05-27_124414.4gsbkbgif9u0.jpg" />
<span class="math display">\[
\begin{aligned}&amp;\textcolor{blue}{c(f_1)=c(f_d)}+\textcolor{red}{f(vv_1)}\\&amp;\textcolor{blue}{c(f_2)=c(f_1)-f(vv_2)=c(f_d)+f(vv_1)-f(vv_2)=c(f_d)+\sum_{j=1}^2\epsilon_jf(vv_j)}\end{aligned}
\]</span> <font color='blue'>From (*), <span
class="math inline">\(c(f_i)=c(f_d)+\sum_{j=1}^i\epsilon_if(vv_j)\)</span>.
It follows that</font> <span class="math display">\[
\textcolor{blue}{\sum_{j=1}^d\epsilon_jf(vv_j)=0\Rightarrow\sum_{e\in
E^{+}(v)}f(e)=\sum_{e\in E^{-}(v)}f(e)}
\]</span></p>
<hr />
<p><span class="math inline">\(\Leftarrow\)</span> Assume that G has a
nowhere-zero k-flow <span class="math inline">\((D,f)\)</span>.</p>
<p>Define a map <span
class="math inline">\(c:F(G)\to\{1,2,\cdots,k-1\}\)</span></p>
<p>Choose an arbitrary face <span class="math inline">\(f_0\)</span> and
let <span class="math inline">\(c(f_0)=1\)</span>. For each arc <span
class="math inline">\(e_i\)</span> in D, let <span
class="math inline">\(f_i&#39;\)</span> and <span
class="math inline">\(f_i&#39;&#39;\)</span> be two faces incident with
<span class="math inline">\(e_i\)</span>. If one of <span
class="math inline">\(f_i&#39;\)</span> and <span
class="math inline">\(f_i&#39;&#39;\)</span> is colored, then the color
of another face is given by the following equality <span
class="math display">\[
c(f_i&#39;&#39;)=c(f_i&#39;)+f(e_i)(mod\ k)
\]</span> It suffices to show that the vertex coloring is
well-defined.<font color ='red'>In other words, the process does not
color one face by two or more different colors.</font></p>
<p>Let <span class="math inline">\(f_1\)</span> be uncolored face
incident with two colored faces <span class="math inline">\(f_2\)</span>
and <span class="math inline">\(f_3\)</span>.Let <span
class="math inline">\(e_i\)</span> be the edge on the boundary of <span
class="math inline">\(f_1\)</span> and <span
class="math inline">\(f_i\)</span> for <span
class="math inline">\(i=2,3\)</span>. Without loss of generality, let
<span class="math inline">\(f_i\)</span> be on the left side of the arcs
<span class="math inline">\(e_2\)</span> and <span
class="math inline">\(e_3\)</span>.</p>
<p><font color='blue'><strong>claim: <span
class="math inline">\(c(f_2)+f(e_2)\equiv c(f_3)+f(e_3)(mod\
k)\)</span></strong></font></p>
<hr />
<p><font color='blue'><strong>Proof of claim:</strong></font></p>
<p><img
src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220226/2022-05-27_164800.1de6ecdbpaps.jpg" /></p>
<p><font color='blue'>Consider the dual graph <span
class="math inline">\(G^\star\)</span> of G.</font></p>
<p><font color='blue'>The vertex subset <span
class="math inline">\(X^\star=\{f\in V(G^\star)\big|f\in F(G)\ is\
colored\ already\}\)</span> induces a connected subgraph of <span
class="math inline">\(G^\star\)</span>. Thus, there is a cycle <span
class="math inline">\(C^\star\)</span> of <span
class="math inline">\(G^\star\)</span> containing <span
class="math inline">\(f_1,f_2\)</span> and <span
class="math inline">\(f_3\)</span>.The cycles <span
class="math inline">\(C^\star\)</span> also contains the edge <span
class="math inline">\(f_1f_2\)</span> and<span
class="math inline">\(f_1f_3\)</span>, <span
class="math inline">\(V(C^\star)\backslash \{f_1\}\subset
X^\star\)</span>.</font></p>
<p><font color='blue'>Since all edges of G corresponding to the edge of
<span class="math inline">\(C^\star\)</span>​ separate G into two
parts</font> <font color='red'>(i.e. these edges form an
edge-cut)</font><font color='blue'>, Let X be the set of vertices in one
part. It follows from a lemma that </font> <span class="math display">\[
\textcolor{blue}{\sum_{e\in E^{+}(v)}f(e)-\sum_{e\in E^{-}(v)}f(e)=0}
\]</span> <font color='blue'>So the clain follows.</font></p>
<hr />
<p>This completes the whole proof.</p>
<p><font color='red'>Recall: Every Eulerian graph G has a cycle
decomposition: edges of G can be decomposed into edge-disjoint
cycles.</font></p>
<p>A cycle cover of a graph is a family of cycles which cover all edges
of G.</p>
<p>A graph has a cycle cover <span
class="math inline">\(\Leftrightarrow\)</span> it has even-subgraph
cover.</p>
<p><strong>Thm If a graph G has k-even-subgraph cover, then G has a
nowhere-zero <span class="math inline">\(2^k\)</span>-flow</strong></p>
<hr />
<p><strong>Proof</strong></p>
<p>For each even-subgraph <span class="math inline">\(H_i\)</span>, it
has a 2-flow <span class="math inline">\((D,f_i)\)</span>.</p>
<p>So <span class="math inline">\((D,f)\)</span> is a nowhere-zero <span
class="math inline">\(2^k\)</span>-flow where <span
class="math inline">\(f=\sum_{e\in E(G)}2^{i-1}f_i(e)\)</span></p>
<hr />
<p><strong>(8-flow theorem,Jaeger) Every bridgeless graph has
nowhere-zero 8-flow</strong></p>
<p><strong>(Splitting Lemma) Let G be a connected graph without
cut-edge.If G has a vertex v of degree at least four. Then there are two
edges <span class="math inline">\(e_1\)</span> and <span
class="math inline">\(e_2\)</span> incident with v s.t. the resulting
graph after splitting <span class="math inline">\(e_1\)</span> and <span
class="math inline">\(e_2\)</span> from v remains to be connected and
without cut-edge.</strong></p>
<p><font color='red'>(Cycle double cover conjecture,1970s) Every
connected cubic graph without cut-edge has a family of cycles covering
every edge exactly twice.</font></p>
<p>A proper k-edge-coloring of a graph G is a map <span
class="math inline">\(c:E(G)\to[k]\)</span> s.t. <span
class="math inline">\(c(e)\not=c(e&#39;)\)</span> if <span
class="math inline">\(e\)</span> and <span
class="math inline">\(e&#39;\)</span> have a common end vertex.</p>
<p><strong>Thm Every 3-edge-colorable cubic graph has a family of cycles
which cover every edge exactly twice</strong></p>
<hr />
<p><strong>Proof</strong></p>
<p>Let <span class="math inline">\(c:E(G)\to[3]\)</span>. Then <span
class="math inline">\(c^{-1}(1)\cup c^{-1}(2)\)</span> is a family of
cycles, <span class="math inline">\(c^{-1}(1)\cup c^{-1}(3)\)</span> is
a family of cycles, <span class="math inline">\(c^{-1}(2)\cup
c^{-1}(3)\)</span> is a family of cycles. <span class="math display">\[
l_{e_1}=c^{-1}(1)\cup c^{-1}(2),l_{e_2}=c^{-1}(1)\cup
c^{-1}(3),l_{e_3}=c^{-1}(2)\cup c^{-1}(3)
\]</span> So <span class="math inline">\(l_{e_1}\cup l_{e_2}\cup
l_{e_3}\)</span> is a family of cycles which cover every edge exactly
twice.</p>
<hr />
<p><font color='blue'>(3-flow conjecture) Every 5-edge connected graph
has a nowhere-zero 3-flow.</font></p>
<p><font color='red'>A graph is a k-edge-connected if for any two
vertices x ang y, the graph has k edge-disjoint paths joining x and
y.</font></p>
<p><font color='blue'>(Tutte-Nashwillam Theorem) Every 2k-edge-connected
graph has a k edge-disjoint spanning trees.</font></p>
<p><font color='blue'>(Lovasz,Wu,Thomassen,Zhang,2012) Every
6-edge-connected graph has a nowhere-zero 3-flow.</font></p>
<p><font color='blue'>(5-flow conjecture.1950s) Every bridgeless graph
has a nowhere-zero 5-flow</font></p>
<p><font color='blue'>(Seymour,1980) Every bridgeless graph has a
nowhere-zero 6-flow.</font></p>
<p><font color='blue'>For cubic graph,cycle double cover conjecture<span
class="math inline">\(\approx\)</span> the strong embedding
conjecture</font></p>
<p><font color='blue'>(Strong Embedding Conjecture,1980s) Every
2-connected graph can be embedded on a closed surface such that every
face is bounded by a cycle.</font></p>
]]></content>
      <categories>
        <category>Graph Theory</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Operation Research</tag>
      </tags>
  </entry>
  <entry>
    <title>Functional Analysis—Hahn-Banach Theorem</title>
    <url>/2023/06/19/functional-1/</url>
    <content><![CDATA[<h3 id="hahn-banach定理的解析形式--线性泛函延拓">1.1
Hahn-Banach定理的解析形式--线性泛函延拓</h3>
<p><strong>Theorem 1.1 (H-B定理解析形式)</strong><span
class="math inline">\(\quad\)</span> 设映射 <span
class="math inline">\(p:E\to\mathbb{R}\)</span> 满足 <span
class="math display">\[
\begin{align}
&amp;p(\lambda x)=\lambda p(x),\ \forall x\in E ,\ \lambda&gt;0\\
&amp;p(x+y)\leq p(x)+p(y),\ \forall x,y\in E
\end{align}
\]</span> 此外, <span class="math inline">\(G\)</span> 为 <span
class="math inline">\(E\)</span> 上的线性子空间以及线性泛函 <span
class="math inline">\(g:G\to\mathbb{R}\)</span> 满足 <span
class="math display">\[
\begin{align}
g(x)\leq p(x),\ \forall x\in G
\end{align}
\]</span> 那么存在 <span class="math inline">\(E\)</span> 上的线性泛函
<span class="math inline">\(f\)</span> 延拓 <span
class="math inline">\(g\)</span>, 即 <span
class="math inline">\(f(x)=g(x),\ \forall x\in G\)</span> 且成立 <span
class="math inline">\(f(x)\leq p(x),\ \forall x\in E\)</span>.
<span id="more"></span></p>
<p><strong>Zorn 引理</strong> 在介绍 Zorn 引理之前,
我们先介绍一些后续将会用到的符号.</p>
<p>设 <span class="math inline">\((P,\leq)\)</span>
是一个有序集(偏序集), 我们称子集 <span class="math inline">\(Q\subset
P\)</span> 完全有序, 若对于 <span class="math inline">\(Q\)</span>
中任意一对 <span class="math inline">\(a,b\)</span> 有序关系 <span
class="math inline">\(a\leq b\)</span>, <span
class="math inline">\(b\leq a\)</span> 或者二者同时成立.</p>
<p><strong><font color='red'>Remark 1.</font></strong>
<font color='red'>完全有序指集 <span class="math inline">\(Q\)</span>
中所有元素都可进行比较序关系,例如数集</font></p>
<p>设子集 <span class="math inline">\(Q\subset P\)</span>, 称 <span
class="math inline">\(c\in P\)</span> 是 <span
class="math inline">\(Q\)</span> 的上界, 如果 <span
class="math inline">\(\forall x\in Q\)</span> 都有 <span
class="math inline">\(x\leq c\)</span> 成立. 称 <span
class="math inline">\(m\in P\)</span> 是 <span
class="math inline">\(P\)</span> 的极大元, 如果不存在 <span
class="math inline">\(P\)</span> 中的元素 <span
class="math inline">\(x\)</span> 满足 <span class="math inline">\(m\leq
x\)</span>, 除了 <span class="math inline">\(m=x\)</span>.</p>
<p><strong><font color='red'>Remark 2.</font></strong>
<font color='red'>我们上面定义的极大元和最大元是不一样的, 具体的差异是,
极大元指的是在能够比较的元素之中没有比他大的元素,
而最大元则要求他能和全部元素可比且没有比他大的元素</font></p>
<p>我们称集合 <span class="math inline">\(P\)</span> 是诱导的 <span
class="math inline">\((\text{inductive})\)</span>, 如果 <span
class="math inline">\(P\)</span> 的任意完全有序子集均有上界</p>
<p><strong>Zorn Lemma</strong> 任意非空有序(偏序)的诱导集合有极大元</p>
<p><strong>Proof of Theorem 1.1</strong></p>
<p><strong><font color='red'>Key:</font></strong>
<font color='red'>定义一个集合 <span class="math inline">\(P\)</span>
和其上的偏序关系 <span class="math inline">\(\leq\)</span>,
证明其是诱导的, 构造其极大元.</font></p>
<p>考虑这样的集合</p>
<p><span class="math display">\[
P=\left\{h:D(h)\subset E\to\mathbb{R}\left|\begin{aligned}&amp;D(h)\
\text{is a linear subspace of}\ E\\&amp;h\ \text{is linear},\ G\subset
D(h)\\&amp;h\ \text{extends}\ g,\ \text{and}\ h(x)\leq p(x),\ \forall
x\in D(h)\end{aligned}\right.\right\}
\]</span> 在 <span class="math inline">\(P\)</span> 上我们赋予偏序关系
<span class="math inline">\(\leq\)</span>, 即 <span
class="math display">\[
h_1\leq h_2\Leftrightarrow D(h_1)\subset D(h_2),\ h_2\ \text{延拓}\ h_1.
\]</span> 显然 <span class="math inline">\(P\)</span> 非空, 因为 <span
class="math inline">\(g\in P\)</span>.</p>
<p>下面我们要说明 <span class="math inline">\(P\)</span> 是一个诱导集,
也就是我们要说明任意一个 <span class="math inline">\(P\)</span>
的完全有序子集都有上界.</p>
<p>我们假设 <span class="math inline">\(Q\subset P\)</span>
是一个完全有序集合, 我们可以记 <span
class="math inline">\(Q=\{h_i\}_{i\in I}\)</span> (<span
class="math inline">\(I\)</span> 是指标集), 我们定义一个线性泛函 <span
class="math inline">\(h\)</span> 满足 <span class="math display">\[
D(h)=\bigcup_{i\in I} D(h_i),\quad h(x)=h_i(x),\ \text{if}\ x\in D(h_i)
\]</span> <strong><font color='red'>Remark 3.</font></strong>
<font color='red'>对于定义的线性泛函 <span
class="math inline">\(h\)</span> 是否是良定义的, 我们给出一定的说明.
如果 <span class="math inline">\(D(h_1)\bigcap
D(h_2)\not=\emptyset\)</span>, 因为 <span
class="math inline">\(Q\)</span> 是完全有序的, 因此我们不妨假设序关系
<span class="math inline">\(h_1\leq h_2\)</span> 成立, 故 <span
class="math inline">\(h_2\)</span> 延拓了 <span
class="math inline">\(h_1\)</span>, 即 <span
class="math inline">\(h_2(x)=h_1(x),\ \forall x\in D(h_2)\bigcap
D(h_1).\)</span></font></p>
<p>显然 <span class="math inline">\(h\in P\)</span> 且 <span
class="math inline">\(h\)</span> 是 <span
class="math inline">\(Q\)</span> 的上界(指定义的伴序关系下的上界).
因此根据 Zorn Lemma 知, 我们构造的 <span
class="math inline">\(P\)</span> 存在极大元, 不妨设其为 <span
class="math inline">\(f\)</span>. 下面我们证明 <span
class="math inline">\(D(f)=E\)</span>, 我们采用反证法的技巧.</p>
<p>如果 <span class="math inline">\(D(f)\not=E\)</span>, 也就是说存在
<span class="math inline">\(x_0\in E\)</span> 但是 <span
class="math inline">\(x_0\not\in D(f)\)</span>. 我们构造一个 <span
class="math inline">\(E\)</span> 的子集 <span
class="math inline">\(D(h)=D(f)+\mathbb{R} x_0\)</span>,
其对应的线性泛函是 <span class="math inline">\(h\)</span>, 其满足 <span
class="math display">\[
h(x+tx_0)=f(x)+t\alpha,\ (t\in \mathbb{R},\ \forall x\in D(f))
\]</span> 其中的常数 <span class="math inline">\(\alpha\)</span>
我们将在后续讨论中给出取值方法. 我们为了推出矛盾, 要验证 <span
class="math inline">\(h\in P\)</span>, 也就是通过选取 <span
class="math inline">\(\alpha\)</span> 来保证 <span
class="math inline">\(f(x)+t\alpha\leq p(x+tx_0),\ \forall t\in
\mathbb{R},\ \forall x\in D(f)\)</span> 成立.</p>
<p>由 (1) 式知, 我们只需要保证下式成立即可, <span
class="math display">\[
\left\{\begin{aligned}
&amp;f(x)+\alpha\leq p(x+x_0)\\
&amp;f(x)-\alpha\leq p(x-x_0)
\end{aligned}\right.
\]</span> 由于二者等价性比较显然, 我们隐去不谈. 根据上式知, 我们选取
<span class="math inline">\(\alpha\)</span> 满足 <span
class="math display">\[\sup_{y\in
D(f)}\{f(y)-p(y-x_0)\}\leq\alpha\leq\inf_{x\in
D(f)}\{p(x+x_0)-f(x)\}\]</span> 下面我们只用说明这样的 <span
class="math inline">\(\alpha\)</span> 是存在的, <span
class="math display">\[
\begin{aligned}
&amp;\qquad f(x)+f(y)=f(x+y)\leq p(x+y)\leq p(y-x_0)+p(x+x_0)\\
&amp;\Rightarrow f(y)-p(y-x_0)\leq p(x+x_0)-f(x)
\end{aligned}
\]</span> 这代表 <span class="math inline">\(\alpha\)</span> 是存在的,
因此 <span class="math inline">\(h\in P\)</span> 且 <span
class="math inline">\(f\leq h\)</span>, 这与 <span
class="math inline">\(f\)</span> 是极大元矛盾. 因此 <span
class="math inline">\(D(f)=E.\)</span></p>
<p>考虑 H-B 定理的应用, 考虑集合 <span class="math inline">\(E\)</span>
是赋范向量空间(n. v. s.)</p>
<p>范数本质上也是一种映射 <span
class="math inline">\(\Vert\cdot\Vert:E\to\mathbb{R}\)</span> 满足 <span
class="math display">\[
\begin{align}
&amp;\Vert x+y\Vert\leq\Vert x\Vert+\Vert y\Vert,\ \forall x,y\in E\\
&amp;\Vert\alpha x\Vert=|\alpha|\Vert x\Vert,\ \alpha\in\mathbb{R},\
\forall x\in E\\
&amp;\Vert x\Vert=0\Rightarrow x=0(\text{此处 }0\text{
并不是简单的数,而是向量空间的零元})
\end{align}
\]</span> 我们记 <span class="math inline">\(E^\star\)</span> 为 <span
class="math inline">\(E\)</span> 的对偶空间, 即 <span
class="math inline">\(E\)</span> 上定义的所有连续线性泛函构成的空间,
同样我们可以构造 <span class="math inline">\(E^\star\)</span> 上的范数为
<span class="math display">\[
\Vert f\Vert_{E^\star}=\sup_{\scriptsize    \begin{aligned}&amp;\Vert
x\Vert=1\\&amp;x\in
E\end{aligned}}|f(x)|=\sup_{\scriptsize   \begin{aligned}&amp;\Vert
x\Vert=1\\&amp;x\in E\end{aligned}}f(x)
\]</span> <span class="math inline">\(\forall f\in E^\star, x\in
E\)</span>, 我们称 <span class="math inline">\(\langle
f,x\rangle=f(x)\)</span> 且称 <span
class="math inline">\(\langle\cdot,\cdot\rangle\)</span> 是定义在对偶集
<span class="math inline">\(E,E^\star\)</span> 的数量积.</p>
<p><strong>Proposition</strong> <span
class="math inline">\(E^\star\)</span> 是一个 Banach 空间,
尽管我们并没有给出 <span class="math inline">\(E\)</span> 的完备性.</p>
<p><strong>Proof</strong> 我们要证明 <span
class="math inline">\(E^\star\)</span> 是 Banach 空间, 等价于证明 <span
class="math inline">\(\forall \{f_n\}\subset E^\star\)</span> 是 Cauchy
列, 则 <span class="math inline">\(\exists f\in E^\star,\ f_n\to
f\)</span>.</p>
<p><span class="math inline">\(\forall x\in E\)</span>, 有 <span
class="math inline">\(|f_n(x)-f_m(x)|\leq\Vert f_n-f_m\Vert\cdot\Vert
x\Vert\)</span>, 且由于 <span class="math inline">\(f_n\)</span> 是
<span class="math inline">\(E^\star\)</span> 上的 Cauchy 列, 故 <span
class="math inline">\(\Vert f_n-f_m\Vert\to 0,\ n,m\to \infty\)</span>.
因此 <span class="math inline">\(\forall x\in E\)</span>, 有 <span
class="math inline">\(|f_n(x)-f_m(x)|\to 0,\ n,m\to \infty\)</span>, 即
<span class="math inline">\(f_n(x)\)</span> 是 <span
class="math inline">\(\mathbb{R}\)</span> 上的 Cauchy 列, <span
class="math inline">\(f_n(x)\)</span> 收敛, 不妨我们记其收敛到 <span
class="math inline">\(f(x)\)</span>.</p>
<p>下面我们仅需要说明 <span class="math inline">\(f_n\)</span> 在 <span
class="math inline">\(E^\star\)</span> 上是收敛到 <span
class="math inline">\(f\)</span> 的, 也就是说, <span
class="math inline">\(\forall \epsilon&gt;0,\exists N&gt;0,\forall
n&gt;N,\Vert f_n-f\Vert\leq\epsilon.\)</span> 显然 <span
class="math inline">\(f(x)\)</span> 是线性泛函, 由上确界的定义可得 <span
class="math display">\[
\forall \epsilon&gt;0,\exists x_0\in E,\ \Vert x_0\Vert=1,\
|f_n(x_0)-f(x_0)|\geq\Vert f_n-f\Vert-\epsilon.
\]</span> 两边取上极限得 <span class="math display">\[
\overline{\lim_{n\to\infty}}\Vert
f_n-f\Vert\leq\lim_{n\to\infty}|f_n(x_0)-f(x_0)|+\epsilon=\epsilon
\]</span> 因此证毕.</p>
<p><strong>Corollary 1</strong> 记 <span
class="math inline">\(G\)</span> 是 <span
class="math inline">\(E\)</span> 的子向量空间, 若 <span
class="math inline">\(g:G\to \mathbb{R}\)</span> 是连续线性泛函, 那么在
<span class="math inline">\(E^\star\)</span> 中存在一个线性泛函 <span
class="math inline">\(f\)</span> 延拓了 <span
class="math inline">\(g\)</span> 且满足 <span class="math display">\[
\Vert f\Vert_{E^\star}=\sup_{\scriptsize    \begin{aligned}&amp;\Vert
x\Vert=1\\&amp;x\in G\end{aligned}}|g(x)|=\Vert g\Vert_{G^\star}
\]</span></p>
<p><strong>Proof.</strong> 我们令 <span class="math inline">\(p(x)=\Vert
g\Vert_{G^\star}\Vert x\Vert\)</span> , 应用 H-B 定理知有 <span
class="math inline">\(f(x)\leq p(x)=\Vert g\Vert_{G^\star}\Vert x\Vert,\
\forall x\in E\)</span>, 因此 <span class="math inline">\(\Vert
f\Vert_{E^\star}\leq\Vert g\Vert_{G^\star}\)</span>. 同时有下式成立
<span class="math display">\[
\Vert f\Vert_{E^\star}=\sup_{\scriptsize    \begin{aligned}&amp;\Vert
x\Vert=1\\&amp;x\in
E\end{aligned}}|f(x)|\geq\sup_{\scriptsize    \begin{aligned}&amp;\Vert
x\Vert=1\\&amp;x\in G\end{aligned}}|g(x)|=\Vert g\Vert_{G^\star}
\]</span> 综上所述, <span class="math inline">\(\Vert
f\Vert_{E^\star}=\Vert g\Vert_{G^\star}\)</span>.</p>
<p><strong>Corollary 2</strong> <span class="math inline">\(\forall
x_0\in E,\ \exists f_0\in E^\star\)</span> 使得 <span
class="math inline">\(\Vert f_0\Vert_{E^\star}=\Vert x_0\Vert_E\)</span>
且 <span class="math inline">\(\langle f_0,x_0\rangle=\Vert
x_0\Vert^2\)</span>.</p>
<p>Proof. 考虑 <span class="math inline">\(G=\mathbb{R} x_0\)</span> 和
<span class="math inline">\(g(tx_0)=t\Vert x_0\Vert^2\)</span>.
下我们说明 <span class="math inline">\(\Vert g\Vert_{G^\star}=\Vert
x_0\Vert^2\)</span>, 依据定义可立马得到, <span class="math display">\[
\Vert g\Vert_{G^\star}=\sup_{\scriptsize    \begin{aligned}&amp;\Vert
x\Vert=1\\&amp;x=tx_0\end{aligned}}|g(tx_0)|=\sup_{\scriptsize    \begin{aligned}&amp;\Vert
x\Vert=1\\&amp;x=tx_0\end{aligned}}t\Vert x_0\Vert^2=\Vert x_0\Vert
\]</span> 根据 Corollary 1的结果, 存在 <span class="math inline">\(f0\in
E^\star\)</span> 满足 <span class="math inline">\(\Vert
f_0\Vert{E^\star}=\Vert g\Vert_{G^\star}=\Vert x_0\Vert.\)</span> 和
<span class="math inline">\(\langle f_0,x_0\rangle=f_0(x_0)=g(x_0)=\Vert
x_0\Vert^2.\)</span></p>
<p><strong><font color='red'>Remark 4.</font></strong>
<font color='red'>上面我们讨论的<span class="math inline">\(f_0\)</span>
并不是唯一的. 只有当 <span class="math inline">\(E^\star\)</span>
严格凸, 例如当 <span class="math inline">\(E\)</span> 是 Hilbert
空间或者 <span class="math inline">\(E\)</span> 是 <span
class="math inline">\(L^p\)</span> 空间<span
class="math inline">\((1&lt;p&lt;\infty)\)</span>, <span
class="math inline">\(f_0\)</span>唯一. 记 <span
class="math inline">\(\forall x_0\in E, F(x_0)=\{f_0\in E^\star|\Vert
f_0\Vert=\Vert x_0\Vert,\ \langle f_0,x_0\rangle=\Vert
x_0\Vert^2\}\)</span>. 一般而言, 映射 <span class="math inline">\(d:
x_0\to F(x_0)\)</span> 是多值映射, 我们称映射 <span
class="math inline">\(d\)</span> 为 <span
class="math inline">\(E\)</span> 到 <span
class="math inline">\(E^\star\)</span> 的对偶映射.</font></p>
<p><strong><font color='red'>Remark 5.</font></strong>
<font color='red'>我们称赋范向量空间 <span
class="math inline">\(E\)</span> 是严格凸的, 如果 <span
class="math inline">\(\forall x,y\in E,\ \Vert x\Vert=\Vert y\Vert=1,\
x\not=y\)</span>, 有<span class="math inline">\(\Vert
tx+(1-t)y\Vert&lt;1,\ \forall t\in(0,1)\)</span>.</font></p>
<p><strong>Corollary 3</strong> <span class="math inline">\(\forall x\in
E\)</span> 有 <span class="math display">\[\Vert
x\Vert=\sup_{\scriptsize \begin{aligned}&amp;\Vert
f\Vert\leq1\\&amp;f\in E^\star\end{aligned}}|\langle
f,x\rangle|=\max_{\scriptsize \begin{aligned}&amp;\Vert
f\Vert\leq1\\&amp;f\in E^\star\end{aligned}}|\langle
f,x\rangle|\]</span>.</p>
<p><strong>Proof.</strong> 若 <span
class="math inline">\(x\not=0\)</span>, 显然有 <span
class="math inline">\(|f(x)|\leq\Vert f\Vert\Vert x\Vert\)</span>,
也就是 <span class="math display">\[
\sup_{\scriptsize \begin{aligned}&amp;\Vert f\Vert\leq1\\&amp;f\in
E^\star\end{aligned}}|\langle f,x\rangle|\leq\Vert x\Vert
\]</span> 根据 Corollary 2的结果知, <span class="math inline">\(\exists
f_0\in E^\star\)</span> 满足 <span class="math inline">\(\Vert
f_0\Vert=\Vert x\Vert,\ \langle f_0,x\rangle=\Vert x\Vert^2\)</span>.
我们记 <span class="math inline">\(f_1=f_0/\Vert x\Vert\)</span>, 则
<span class="math inline">\(\Vert f_1\Vert=1\)</span> 且 <span
class="math inline">\(\langle f_1,x\rangle=\Vert x\Vert\)</span>.</p>
]]></content>
      <categories>
        <category>Functional Analysis</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Functional Analysis</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux-Shell常用指令</title>
    <url>/2024/03/30/linux-1/</url>
    <content><![CDATA[<h1 id="shell-基本命令">Shell 基本命令</h1>
<p>Bash提供了命令行补全的特性.我们可以利用Tab键来完成命令以及文件名的自动补全.如果以已输入的字符开头的文件不止一个,那么连续输入两次Tab键,shell将会以列表的形式给出所有以输入字符开头的文件名.</p>
<p>同样我们可以补全Linux命令,这是因为Linux的命令本质上是一些可执行文件,所以可以认为命令补全和文件名补全其实是同一件事.</p>
<p>此外,Shell在查找文件中存在通配符的专用符号,其为*,?,[].这些通配符可以搜索并匹配文件名的一部分,从而可以做到批量检索文件.</p>
<span id="more"></span>
<ol type="1">
<li><p>*用于匹配文件名中任意长度的字符串.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> *.cpp <span class="comment">## 检索以.cpp结尾的文件</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>?和*类似,但是与*匹配任意长度的字符串不同,?只能匹配一个字符串</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> text? <span class="comment">## 检索文件名中以text开头并且后面接一个字符的文件.</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>[]用于匹配所有出现在方括号内的字符.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> text[1A]  <span class="comment">## 用于列出以text开头而仅以1或者A结束的文件</span></span></span><br></pre></td></tr></table></figure>
<p>如果需要查找多个连续字符范围的,可以利用短线-来指定一个字符集范围.所有包含在上下界之间的字符都会被匹配.同样可对字母操作,如在ASC码中,A-Z可以包含所有的大写字母.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> text[1-3] <span class="comment">## 用于列出以text开头而仅以1-3中字符结束的文件</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> text[A-Z] <span class="comment">## 用于列出以text开头而仅以大写字母结束的文件</span></span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>虽然我们上面的演示都以通配符位于文件末,但实际上通配符的位置是任意的.并且可以随意搭配使用.</p>
<p><a id="org48c8384"></a></p>
<h2 id="pwd-显示当前目录">pwd: 显示当前目录</h2>
<p>pwd命令会显示当前所在的位置,也就是工作目录.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> /usr/local/bin  <span class="comment">## 进入/usr/local/bin目录</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">pwd</span>                <span class="comment">## 显示当前所在位置</span></span></span><br><span class="line">/user/local/bin</span><br></pre></td></tr></table></figure>
<p><a id="org0a74477"></a></p>
<h2 id="cd-改变目录">cd: 改变目录</h2>
<p>cd是Linux文件系统在不同文件夹之间转移的常用指令.其后一般都加上路径名作为参数表示跳转到相应的位置,但其有一些特殊的路径符号来简化跳转特定文件夹的指令.</p>
<ol type="1">
<li><p>/表示根目录,不管在什么目录下,命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> / <span class="comment">## 跳转到根目录</span></span></span><br></pre></td></tr></table></figure>
<p>都会快速跳转到根目录下.</p></li>
<li><p>..表示当前目录的上一级目录,例如如果现在工作目录都是/usr/bin</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> .. <span class="comment">## 跳转到上一级目录</span></span></span><br></pre></td></tr></table></figure>
<p>其会跳转到上一级目录即/usr中.</p></li>
<li><p>.表示当前目录,我们如果需要跳转到当前目录的某个文件夹中可以用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> ./xxx  <span class="comment">## 跳转到同级目录中的下级目录</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>~表示用户主目录,其一般是/home/下名称为用户名的文件夹,在其中存储对应用户的数据和设置.同样我们可以用cd命令不加任何参数来跳转到用户主目录.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> ~  <span class="comment">## 跳转到用户主目录</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span>    <span class="comment">## 跳转到用户主目录</span></span></span><br></pre></td></tr></table></figure></li>
</ol>
<p><a id="orge55b477"></a></p>
<h2 id="ls-列出目录内容">ls: 列出目录内容</h2>
<p>ls命令实际上是list的简化形式.list的用法十分多,但其基本语法是</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls [OPTION]... [FILE]... ## ls命令的基本形式</span><br></pre></td></tr></table></figure>
<p>最简单的情况,我们直接在任意工作目录下输入ls命令,用于列出当前目录下所有文件和子目录.为了区分文件目录和文件,linux系统会用不同颜色来标注不同的类型.由于不同的系统对于颜色渲染不太一样,甚至可能没有颜色,我们可以用-F参数的ls命令,-F会在每个目录后面加上/,在可执行文件后加*,在链接文件后加@.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -F <span class="comment">##列出文件并且在列出的文件名称后加一符号</span></span></span><br></pre></td></tr></table></figure>
<p>虽然我们可以用ls列出当前目录下的所有内容,但实际上有很多的名称以.开头的文件并未展示,我们称这类文件为隐含文件,在默认情况下是不会展示的.我们可以用参数-a来显示所有的文件.对于命令的参数是可以组合使用的,并且制定多个选项只需要用一个短线即可.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -a  <span class="comment">## 列出所有文件及目录(以.开头的隐含文件也会被列出)</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -aF <span class="comment">## 列出所有文件和目录的同时加上一个后缀符号</span></span></span><br></pre></td></tr></table></figure>
<p>ls另外一个比较常见的参数是-l,这个选项可以用来查看文件的各种属性,</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l  <span class="comment">## 列出所有文件和目录以及其对应的属性</span></span></span><br><span class="line">  总计 152</span><br><span class="line">  drwxr-xr-x  2 lyd  lyd   4096  2月  5 09:49  公共</span><br><span class="line">  drwxr-xr-x  2 lyd  lyd   4096  2月  5 09:49  模板</span><br><span class="line">  drwxr-xr-x  2 lyd  lyd   4096  2月  5 09:49  视频</span><br><span class="line">  drwxr-xr-x  3 lyd  lyd   4096  2月 25 20:55  图片</span><br><span class="line">  drwxr-xr-x  2 lyd  lyd   4096  2月  5 09:49  文档</span><br><span class="line">  drwxr-xr-x  2 lyd  lyd   4096  3月 14 15:39  下载</span><br><span class="line">  drwxr-xr-x  2 lyd  lyd   4096  2月  5 09:49  音乐</span><br><span class="line">  drwxr-xr-x  2 lyd  lyd   4096  2月  5 09:49  桌面</span><br></pre></td></tr></table></figure>
<p>这一共有九个不同的信息栏,从左到右依次表示,</p>
<ol type="1">
<li>文件的权限标志(后续会进一步讨论其含义)</li>
<li>文件连接个数(同上)</li>
<li>文件所有者的用户名</li>
<li>该用户所在的用户组祖名(后续会讨论)</li>
<li>文件的大小</li>
<li>最后一次修改时的月份</li>
<li>最后一次修改的日期</li>
<li>最后一次修改的时间</li>
<li>文件名</li>
</ol>
<p>ls命令后接路径名,可以直接查看子目录的内容,</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> /etc/init.d/ <span class="comment">## 用来查看/etc/init.d/的内容</span></span></span><br></pre></td></tr></table></figure>
<p>除了ls命令可以列出目录,我们也可以用windows系统常用的dir命令来列出,但其功能比ls要少.我们也可以用vdir来代替ls
-l来列出目录和文件的完整信息.但由于ls的功能明显更为强大,我们就不再多介绍dir和vdir的用法.</p>
<p><a id="org824b1c7"></a></p>
<h2 id="cat-和-more-查看文本文件">cat 和 more: 查看文本文件</h2>
<p>cat命令用于查看文件内容(一般是文本文件,如果打开的是PDF或者其他形式的文件会以文本文件的形式打开),后跟文件名作为参数.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> xxx <span class="comment">## 查看文件内容</span></span></span><br></pre></td></tr></table></figure>
<p>cat后面的文件名参数可以添加多个文件名,同样也可以用通配符来批量查看文件.</p>
<p>为了调试方便,我们可以用-n参数来在展示的文本文件形式的每行前面显示行号</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> -n xxxx <span class="comment">## 查看文件内容的同时显示行号</span></span></span><br></pre></td></tr></table></figure>
<p>但是当我们打开多个文件的时候,用-n参数并不会智能地区分每个文件的终止,而是连续的对行号进行递增编号.</p>
<p>但由于cat命令会将文件的内容全部展示在shell命令行之上,对于内容较多的文件,这样的打开方式并不合适.因此我们可以用more命令来一页页的显示文章内容,</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">more XXX <span class="comment">## 以分页的形式展示文件内容</span></span></span><br><span class="line">....</span><br><span class="line">--More-- (75%) </span><br></pre></td></tr></table></figure>
<p>more命令会在最后显示一个百分比,其表示已显示内容占整个文件的比例.我们可以用空格键向下翻一页,用Enter则可以向下滚动一行,用Q退出文本文件展示.</p>
<p>more命令和cat一样可以添加多个文件名,也可以通配符来批量查看文件.</p>
<p><a id="orge830626"></a></p>
<h2 id="head-和-tail-查看文件的开头和结尾">head 和 tail:
查看文件的开头和结尾</h2>
<p>head和tail用于展示文件的开头和结尾.我们可以用-n参数来修改展示的行数,如果我们不加-n命令手动修改展示行数,那么会默认展示10行的内容.head命令的默认输出是包括输出文件名,但不会计入展示文件开头的行数,我们可以用-q参数来取消输出文件名.不仅如此,head后面还可以接多个文件名,用于批量展示多个文件的开头和结尾.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">head</span> -n k xxx <span class="comment">## 展示文件前k行,如果没有-n参数,默认展示文件的前10行</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">head</span> -q xxx <span class="comment">## 不展示文件名</span></span></span><br></pre></td></tr></table></figure>
<p>tail和head的用法完全一致.</p>
<p><a id="org41780dc"></a></p>
<h2 id="less-更好的文本阅读工具">less: 更好的文本阅读工具</h2>
<p>less和前面提到的more十分类似,都不能对文本文件进行修改,也支持打开多个文本文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">less ~/.bashrc <span class="comment">## 用less查看文件</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">~/.bashrc: executed by bash(1) <span class="keyword">for</span> non-login shells.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">see /usr/share/doc/bash/examples/startup-files (<span class="keyword">in</span> the package bash-doc)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="keyword">for</span> examples</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">If not running interactively, don<span class="string">&#x27;t do anything</span></span></span><br><span class="line">case $ - in</span><br><span class="line">    *i*) ;;</span><br><span class="line">      *) return;;</span><br><span class="line">esac</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">don&#x27;</span>t put duplicate lines or lines starting with space <span class="keyword">in</span> the <span class="built_in">history</span>.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">See bash(1) <span class="keyword">for</span> more options</span></span><br><span class="line">HISTCONTROL=ignoreboth</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">append to the <span class="built_in">history</span> file, don<span class="string">&#x27;t overwrite it</span></span></span><br><span class="line">shopt -s histappend</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">for setting history length see HISTSIZE and HISTFILESIZE in bash(1)</span></span></span><br><span class="line">HISTSIZE=1000</span><br><span class="line">HISTFILESIZE=2000</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">check the window size after each command and, if necessary,</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">update the values of LINES and COLUMNS.</span></span></span><br><span class="line">:</span><br></pre></td></tr></table></figure>
<p>在屏幕的末尾会有一个冒号,其表示等待用户输入命令.在此我们罗列常用的移动命令,</p>
<ul>
<li><SPC> 向下滚动一页</li>
<li><Enter> 向下滚动一行</li>
<li>b 向上翻一页</li>
<li>y 向上滚动一行</li>
<li>d 向下翻半页</li>
<li>u 向上翻半页</li>
</ul>
<p>在less查看的文本文件中,我们还可以用/跟上想要查找的内容,来实现对文本内容的检索,less会把第一个搜索目标高亮显示,如果我们还需要查找相同内容,我们只需要用n来跳转到下一个搜索目标,同样如果我们需要跳转到前一次的搜索结果我们可以用N来跳转.</p>
<p>实际上/并不是全文检索,而是以光标为基准向后搜索字符串,相反我们可以用?来以光标为基准向前搜索字符串.</p>
<p>由于less的用法较多,可以在冒号后接h来打开less自带的帮助文档查看指令及其作用.</p>
<p>为了展示更多的文件信息,我们可以用-M来展示更多的文件信息,</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">  $ </span><span class="language-bash">less -m ~/.bashrc</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">~/.bashrc: executed by bash(1) <span class="keyword">for</span> non-login shells.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">see /usr/share/doc/bash/examples/startup-files (<span class="keyword">in</span> the package bash-doc)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="keyword">for</span> examples</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">If not running interactively, don<span class="string">&#x27;t do anything</span></span></span><br><span class="line">case $ - in</span><br><span class="line">    *i*) ;;</span><br><span class="line">      *) return;;</span><br><span class="line">esac</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">don&#x27;</span>t put duplicate lines or lines starting with space <span class="keyword">in</span> the <span class="built_in">history</span>.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">See bash(1) <span class="keyword">for</span> more options</span></span><br><span class="line">HISTCONTROL=ignoreboth</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">append to the <span class="built_in">history</span> file, don<span class="string">&#x27;t overwrite it</span></span></span><br><span class="line">shopt -s histappend</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">for setting history length see HISTSIZE and HISTFILESIZE in bash(1)</span></span></span><br><span class="line">HISTSIZE=1000</span><br><span class="line">/home/lyd/.bashrc lines 1-19/114 15%</span><br></pre></td></tr></table></figure>
<p>less在输出的底部显示了文件名,当前行数,总行数以及所占百分比.最后可以用Q推出less程序.</p>
<p><a id="org6891801"></a></p>
<h2 id="grep-查找文件内容">grep: 查找文件内容</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep [OPTIONS] PATTERN [FILE...]  ## grep一般形式</span><br></pre></td></tr></table></figure>
<p>如果我们想在文件A中查找包含test的行,可以用如下命令,</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">grep <span class="built_in">test</span> A</span></span><br></pre></td></tr></table></figure>
<p>从上面的命令我们可以看出grep后面接两个不同类型的参数,第一个是被搜索的关键词,也称之为模式,第二个则是所搜索的文件.grep会将文件中出现关键词的行输出,并且grep可指定多个文件来搜索.另外我们用grep查找的是关键词,对于查找如Debian
Ubunut这样的关键词,我们需要用单引号来将空格包含在关键词中,不然grep会认为关键词为Debian,在文件名为Ubuntu的文件中查找.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">grep <span class="string">&#x27;Debian Ubuntu&#x27;</span> linux  <span class="comment">##在linux文件中查找关键词 Debian Ubuntu</span></span></span><br></pre></td></tr></table></figure>
<p>我们列出一些常用的grep命令选项,</p>
<ul>
<li>-i 忽略大小写进行匹配</li>
<li>-r 进行递归查找子目录中的文件</li>
<li>-l 仅输出存在匹配的文件名</li>
<li>-c 输出匹配的行数</li>
<li>-v 反向查找,只打印不匹配的行</li>
</ul>
<p>grep实际上是以正则表达式的形式对文件进行查找,针对扩展的正则表达式,我们可以用egrep来查找.</p>
<p><a id="org676ae04"></a></p>
<h2 id="find-文件查找">find: 文件查找</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find [OPTION] [path...] [expression] ## find命令的基本语法</span><br></pre></td></tr></table></figure>
<p>find命令需要一个路径名作为查找范围,find会深入该路径中的每个子目录中寻找,如果我们指定的路径名为/,那么就会在整个文件系统中搜索.下给出一个find命令的实例,</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">find /usr/bin -name zip -<span class="built_in">print</span> <span class="comment">##在/usr/bin的目录下查找zip</span></span></span><br><span class="line">/usr/bin/zip</span><br></pre></td></tr></table></figure>
<p>这里的/usr/bin就是find的查找范围,-name指定了查找条件以文件名为基准,此处支持用通配符*和?.-print表示将结果输出到屏幕,实际上可以不需要加这个动作指令,find会默认将其输出.值得注意的是find输出的结果是文件的绝对路径.</p>
<p>我们在此罗列find常用的查找条件的参数,</p>
<ul>
<li>-name pattern: 按照文件名查找,支持使用通配符</li>
<li>-size [+-]size[cwbkMG]:
按文件大小查找,支持使用+或-来表示大于或小于指定大小,单位可以是c(字节),w(字数),b(块数),k(KB),M(MB)或G(GB).</li>
<li>-mtime days:
按修改时间查找,支持使用+或-表示在指定天数前或后,days是一个整数表示天数</li>
<li>-user username: 按照文件所有者查找</li>
<li>-group groupname: 按文件所属组查找</li>
<li>-type type: 按照文件类型查找,type的参数含义如下表所示</li>
</ul>
<div data-align="center">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<colgroup>
<col  class="org-left" />
</colgroup>
<colgroup>
<col  class="org-left" />
</colgroup>
<colgroup>
<col  class="org-left" />
</colgroup>
<colgroup>
<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">
参数
</th>
<th scope="col" class="org-left">
含义
</th>
<th scope="col" class="org-left">
参数
</th>
<th scope="col" class="org-left">
含义
</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">
b
</td>
<td class="org-left">
块设备文件
</td>
<td class="org-left">
f
</td>
<td class="org-left">
普通文件
</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">
c
</td>
<td class="org-left">
字符设备文件
</td>
<td class="org-left">
p
</td>
<td class="org-left">
命名管道
</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">
d
</td>
<td class="org-left">
目录文件
</td>
<td class="org-left">
l
</td>
<td class="org-left">
符号链接
</td>
</tr>
</tbody>
</table>
</div>
<p>我们介绍find对匹配到的文件执行的操作,</p>
<ul>
<li>-amin n: 查找在n分钟被访问过的文件</li>
<li>-atime n: 查找在n*24小时内被访问的文件</li>
<li>-cmin n: 查找在n分钟内状态发生变化的文件(例如权限)</li>
<li>-ctime n: 查找在n*24小时内状态发生过变化的文件(例如权限)</li>
<li>-mmin n: 查找在n分钟内被修改过的文件</li>
<li>-mtime n: 查找在n*24小时内被修改过的文件</li>
</ul>
<p>上面的参数n可以是正数,负数亦或是0.正数+n表示查找比指定时间更早的文件或目录,负数-n表示查找在指定时间内的文件或目录,0表示当天的文件或目录</p>
<p><a id="org3ded0d1"></a></p>
<h2 id="locate-快速定位文件">locate: 快速定位文件</h2>
<p>由于find在查找大批量文件中将花费大量的文件,因此我们可以用locate来代替find,在Ubuntu系统中locate并没有内置安装,因此我们先用apt包管理器下载locate,</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt-get install mlocate <span class="comment">## 下载locate命令及相关依赖</span></span></span><br></pre></td></tr></table></figure>
<p>locate的底层逻辑是并不去查找每个子目录,而是在/var/lib/slocate资料库里查找,因此locate的查找并不是及时的,需要对数据库进行更新,一般来说系统每天会自动更新一次,当然也可以用命令自己手动的更新,</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo updatedb <span class="comment">## 手动更新locate的文件名数据库</span></span></span><br></pre></td></tr></table></figure>
<p>locate查找也可以使用通配符,一些常用的locate命令参数为</p>
<ul>
<li>-c: 只输出找到的数量</li>
<li>-i: 忽略大小写进行查找</li>
<li>-n n: 至多显示n个输出</li>
<li>-h: 显示帮助</li>
</ul>
<p><a id="orgcffd121"></a></p>
<h2 id="whereis-查找特定程序">whereis: 查找特定程序</h2>
<p>whereis命令主要用于查找程序文件并提供该程序的二进制可执行文件,源代码文件和使用手册页存放的位置.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">whereis find <span class="comment">## 寻找find程序文件以及相关的配套文件</span></span></span><br><span class="line">find: /usr/bin/find /usr/share/man/man1/find.1.gz /usr/share/info/find.info-1.gz /usr/share/info/find.info.gz /usr/share/info/find.info-2.gz</span><br></pre></td></tr></table></figure>
<p>我们可以用-b选项来让whereis只返回该程序的二进制可执行文件,</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">whereis -b find <span class="comment">## 寻找find命令的二进制可执行文件</span></span></span><br><span class="line">find: /usr/bin/find</span><br></pre></td></tr></table></figure>
<p>同样,可以用-m选项来让whereis只返回该程序的帮助文件,</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">whereis -m find <span class="comment">## 寻找find命令的帮助文件</span></span></span><br><span class="line">find: /usr/share/man/man1/find.1.gz /usr/share/info/find.info-1.gz /usr/share/info/find.info.gz /usr/share/info/find.info-2.gz</span><br></pre></td></tr></table></figure>
<p>如果查找的文件不存在,那会返回一个空字符串,</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">find xxx</span></span><br><span class="line">xxx:</span><br></pre></td></tr></table></figure>
<p>事实上,whereis命令查找不到文件,不一定是文件不存在,而是有可能不是在whereis的查找目录中,其实whereis并没有查找全文件系统,仅查找了内置的子目录路径,这在查找精度上是一个缺陷,但对于查找的速度来说是一个显著提升.</p>
<p><a id="org99ede03"></a></p>
<h2 id="用户版本信息查看">用户版本信息查看</h2>
<p>who可以查看当前系统有哪些人登陆使用,以及他们使用的工作台,</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"> <span class="built_in">who</span> <span class="comment">## 查看当前使用系统的用户</span></span></span><br></pre></td></tr></table></figure>
<p>whoami用来查看自己是以什么身份进入系统的</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">whoami</span> <span class="comment">## 查看自己进入系统的身份</span></span></span><br></pre></td></tr></table></figure>
<p>上面这两个命令对于PC系统的应用不大,主要是对于服务器系统的查看,因为不同的用户会有不同的权限,因此需要用这个来查看用户身份.</p>
<p>uname是用来显示当前系统的版本信息.-a选项会显示当前的操作系统的所有有用的信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">uname</span> -a <span class="comment">## 显示当前的操作系统的所有有用的信息</span></span></span><br><span class="line">Linux lyd-Lenovo-330S-14IKB 6.5.0-25-generic #25~22.04.1-Ubuntu SMP PREEMPT_DYNAMIC Tue Feb 20 16:09:15 UTC 2 x86_64 x86_64 x86_64 GNU/Linux</span><br></pre></td></tr></table></figure>
<p>如果只需要查看处理器类型,-m选项可以只输出这个结果,</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">uname</span> -m</span></span><br><span class="line">x86_64</span><br></pre></td></tr></table></figure>
<h2 id="man-寻求帮助">man: 寻求帮助</h2>
<p>linux可以用man命令接某个命令的名称来获取该命令的帮助文档,</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">man find <span class="comment">## 查看find的帮助文档</span></span></span><br></pre></td></tr></table></figure>
<p>man命令显示手册页用的是less程序.对于其上下移动和vim的操作一样,不再赘述.</p>
<h2 id="whatis-和-apropos-获取命令简介">whatis 和 apropos:
获取命令简介</h2>
<p>由于man查找的是帮助文档,因此太过冗长.我们可以用whatis命令快速得到命令的简要介绍,</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">whatis find  <span class="comment">## 获取命令的简要介绍</span></span></span><br><span class="line">find (1)             - search for files in a directory hierarchy</span><br></pre></td></tr></table></figure>
<p>但如果我们想要实现某个功能但不知道用什么命令时,我们可以选用apropos来反向查找,如</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">apropos search  <span class="comment">##反向搜索使用的命令</span></span></span><br><span class="line">apropos (1)          - search the manual page names and descriptions</span><br><span class="line">apt-patterns (7)     - Syntax and semantics of apt search patterns</span><br><span class="line">badblocks (8)        - search a device for bad blocks</span><br><span class="line">bsearch (3)          - binary search of a sorted array</span><br><span class="line">bzegrep (1)          - search possibly bzip2 compressed files for a regular e...</span><br><span class="line">bzfgrep (1)          - search possibly bzip2 compressed files for a regular e...</span><br><span class="line">bzgrep (1)           - search possibly bzip2 compressed files for a regular e...</span><br><span class="line">Data::DPath::Context (3pm) - Abstraction for a current context that enables i...</span><br><span class="line">find (1)             - search for files in a directory hierarchy</span><br><span class="line">git-bisect (1)       - Use binary search to find the commit that introduced a...</span><br><span class="line">hsearch (3)          - hash table management</span><br><span class="line">hsearch_r (3)        - hash table management</span><br><span class="line">lfind (3)            - linear search of an array</span><br></pre></td></tr></table></figure>
<p>可以发现apropos实际上是检索命令简介中包含关键词的条目罗列出,让用户选择.</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Computer Science</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Functional Analysis-A Quick Introduction to the Theory of Conjugate Convex Functions(1)</title>
    <url>/2023/08/08/functional-4/</url>
    <content><![CDATA[<h3 id="共轭凸函数1">1.4 共轭凸函数(1)</h3>
我们先从下半连续函数和凸函数开始讨论, 考虑定义在集合 <span
class="math inline">\(E\)</span> 上, 取值在 <span
class="math inline">\((-\infty,+\infty]\)</span> 的函数 <span
class="math inline">\(\phi\)</span>, 我们给出一些记号如 <span
class="math inline">\(\phi\)</span> 的定义域为 <span
class="math inline">\(D(\phi)=\{x\in E|\phi(x)&lt;+\infty\}\)</span>,
<span class="math inline">\(\phi\)</span> 的上图像为 <span
class="math inline">\(\text{epi}\ \phi=\{[x,\lambda]\in
E\times\mathbb{R}|\phi(x)\leq \lambda\}\)</span>, 其中 <span
class="math inline">\(\mathbb{R}=(-\infty,+\infty)\)</span>. <span id="more"></span>
假设 <span class="math inline">\(E\)</span> 是拓扑空间, 定义 <span
class="math inline">\(\phi: E\to(-\infty,+\infty]\)</span>
是下半连续函数, 若 <span class="math inline">\(\forall
\lambda\in\mathbb{R}\)</span>, 集合 <span
class="math inline">\([\phi\leq\lambda]=\{x\in
E|\phi(x)\leq\lambda\}\)</span> 是闭集.
下面列举一些下半连续函数的基本性质:
<ul>
<li>
<span class="math inline">\(\phi\)</span> 是下半连续函数,
那么其对应的上图像 <span class="math inline">\(\text{epi}\ \phi\)</span>
是 <span class="math inline">\(E\times\mathbb{R}\)</span> 上的闭集,
反之亦然.
</li>
<li>
<span class="math inline">\(\phi\)</span> 是下半连续函数, 则 <span
class="math inline">\(\forall x,\ \forall\epsilon&gt;0\)</span>, 存在
<span class="math inline">\(x\)</span> 的领域 <span
class="math inline">\(V\)</span>, 使得 <span
class="math inline">\(\phi(y)\geq\phi(x)-\epsilon,\ \forall y\in
V\)</span>, 反之亦然.
</li>
<li>
若 <span class="math inline">\(\phi_1,\ \phi_2\)</span> 是下半连续函数,
那么 <span class="math inline">\(\phi_1+\phi_2\)</span>
也是下半连续函数.
</li>
<li>
<span class="math inline">\(\{\phi_i\}_{i\in I}\)</span>
是一族下半连续函数, 那么 <span class="math inline">\(\phi=\sup_{i\in
I}\phi_i(x)\)</span> 是下半连续函数
</li>
<li>
若 <span class="math inline">\(E\)</span> 为紧空间, 而 <span
class="math inline">\(\phi\)</span> 是下半连续的, 则 <span
class="math inline">\(\phi\)</span> 在 <span
class="math inline">\(E\)</span> 上可以达到下确界, 也就是 <span
class="math inline">\(\exists x_0\in E\)</span>, 使得 <span
class="math inline">\(\phi(x_0)=\inf_E\phi\)</span>
</li>
</ul>
假设 <span class="math inline">\(E\)</span> 是向量空间, 定义 <span
class="math inline">\(\phi:E\to(-\infty,+\infty]\)</span> 是凸函数, 若
<span class="math inline">\(\phi\)</span> 满足 <span
class="math inline">\(\phi(tx+(1-t)y)\leq t\phi(x)+(1-t)\phi(y),\
\forall x,y\in E,\ \forall t\in[0,1]\)</span>.
同样我们在下面列举一些凸函数的基本性质.
<ul>
<li>
若 <span class="math inline">\(\phi\)</span> 是凸函数, 则其对应的上图像
<span class="math inline">\(\text{epi}\ \phi\)</span> 是凸集. 反之亦然
</li>
<li>
若 <span class="math inline">\(\phi\)</span> 是凸函数, 则 <span
class="math inline">\(\forall \lambda\in\mathbb{R}\)</span>
</li>
<li>
若 <span class="math inline">\(\phi_1,\ \phi_2\)</span> 是凸函数, 则
<span class="math inline">\(\phi_1+\phi_2\)</span> 是凸函数
</li>
<li>
若 <span class="math inline">\(\{\phi_i\}_{i\in I}\)</span>
是一族凸函数, 则 <span class="math inline">\(\phi(x)=\sup_{i\in
I}\phi_i\)</span> 是凸函数
</li>
</ul>
<p>假设 <span class="math inline">\(E\)</span> 是赋范线性空间, 设给定
<span class="math inline">\(\phi:E\to(-\infty,+\infty]\)</span> 满足
<span class="math inline">\(\phi\not\equiv+\infty\)</span>, 即 <span
class="math inline">\(D(\phi)\not=\empty\)</span>, 记 <span
class="math inline">\(\phi\)</span>
的共轭函数<font color='red'>(Conjugate function)</font> <span
class="math inline">\(\phi^\star: E^\star\to(-\infty,+\infty]\)</span>,
<span class="math display">\[
\phi^\star(f)=\sup_{x\in E}\left\{\langle f,x\rangle-\phi(x)\right\},\
(f\in E^\star)
\]</span> <font color='red'><span
class="math inline">\(\big(\)</span>从一维的角度来看, <span
class="math inline">\(\phi^\star\)</span> 实际上指的是 <span
class="math inline">\(\langle f,x\rangle\)</span> 和 <span
class="math inline">\(\phi(x)\)</span> 两图像中最大的距离<span
class="math inline">\(\big)\)</span></font></p>
<p>上面定义的共轭函数 <span class="math inline">\(\phi^\star\)</span>
是在 <span class="math inline">\(E^\star\)</span> 上的下半连续凸函数,
下面我们给出相关证明, <strong>Proof</strong> 我们先考虑其凸性, 在 <span
class="math inline">\(\forall f_1,\ f_2\in E^\star,\ t\in[0,1]\)</span>
的情况下, <span class="math display">\[
\begin{aligned}
\phi^\star
\end{aligned}
\]</span></p>
]]></content>
      <categories>
        <category>Functional Analysis</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Functional Analysis</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux-文件目录管理</title>
    <url>/2024/04/16/linux-2/</url>
    <content><![CDATA[<h1 id="文件目录管理">文件目录管理</h1>
<p>下表罗列了Linux文件系统中主要目录的内容</p>
<div data-align="center">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<colgroup>
<col  class="org-center" />
</colgroup>
<colgroup>
<col  class="org-center" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-center">
目 录
</th>
<th scope="col" class="org-center">
内 容
</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-center">
/bin
</td>
<td class="org-center">
构建最小系统所需要的命令(最常用的命令)
</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-center">
/boot
</td>
<td class="org-center">
内核和启动文件
</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-center">
/dev
</td>
<td class="org-center">
各种设备文件
</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-center">
/etc
</td>
<td class="org-center">
系统软件的启动和配置文件
</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-center">
/home
</td>
<td class="org-center">
用户的主目录(用户所有数据,极其重要)
</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-center">
/lib
</td>
<td class="org-center">
C编译器的库
</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-center">
/media
</td>
<td class="org-center">
可移动介质的安装点
</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-center">
/opt
</td>
<td class="org-center">
可选的应用软件包(用deb包安装的部分软件在这)
</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-center">
/proc
</td>
<td class="org-center">
进程的映像
</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-center">
/root
</td>
<td class="org-center">
根用户root的主目录
</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-center">
/sbin
</td>
<td class="org-center">
和系统操作有关的命令
</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-center">
/tmp
</td>
<td class="org-center">
临时文件存放点
</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-center">
/usr
</td>
<td class="org-center">
非系统的程序和命令(apt安装的位置)
</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-center">
/var
</td>
<td class="org-center">
系统专用的数据和配置文件
</td>
</tr>
</tbody>
</table>
</div>
<p><a id="org8d61c7d"></a></p>
<span id="more"></span>
<h2 id="mkdir-建立目录">mkdir: 建立目录</h2>
<p>mkdir命令可以一次建立一个或几个目录.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> document picture <span class="comment">## 新建两个目录</span></span></span><br></pre></td></tr></table></figure>
<p>这样的创建是先利用cd到你想创建的位置,再创建目录.用户也可以用绝对路径来新建目录,这样的话不需要用cd来跳转到创建的位置,在任意位置用mkdir加绝对路径即可创建目录,</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> ~/picture/temp <span class="comment">## 在主目录的picture目录下创建temp子目录</span></span></span><br></pre></td></tr></table></figure>
<p>这个命令合法是因为picture目录存在主目录下,如果用户试图在一个不存在的目录下创建新子目录,那命令会报错.为了避免这个报错,我们可以用-p选项来创建目录.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> -p /home/username <span class="comment">## 在home目录下创建username目录,如果他存在那就不去创建</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> -p ~/test1/test2 <span class="comment">## 如果主目录下没有test1,那么不会报错,而是先创建test1再在其中创建test2</span></span></span><br></pre></td></tr></table></figure>
<p><a id="orgfef9599"></a></p>
<h2 id="touch-建立一个空文件">touch: 建立一个空文件</h2>
<p>touch后面接文件名作为参数,可以在当前目录创建一个或多个新文件,</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">touch</span> hello <span class="comment">## 在当前目录创建文件名为hello的文件</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">touch</span> <span class="string">&#x27;hello world&#x27;</span> <span class="comment">## 在当前目录创建文件名为 &#x27;hello world&#x27; 的文件</span></span></span><br></pre></td></tr></table></figure>
<p>如果我们在上面的'hello
world'中不加引号,那touch会认为创建hello和world两个文件.用touch命令创建的文件是空文件,其内不包含任何内容.</p>
<p>touch除了创建空文件的作用,其更重要的用途是更新一个文件的建立日期和时间.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l init.el~ <span class="comment">## 查看文件的时间属性</span></span></span><br><span class="line">-rw-r--r-- 1 lyd lyd 997  2月  5 21:54 init.el~ ## 原来文件时间属性是2024/2/5-21:54</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">touch</span> init.el~ <span class="comment">## 修改文件的时间属性</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l init.el~ <span class="comment">## 查看改过的文件时间属性</span></span></span><br><span class="line">-rw-r--r-- 1 lyd lyd 997  3月 20 20:52 init.el~ ## 改过以后文件时间变成了2024/3/20-20:52</span><br></pre></td></tr></table></figure>
<p>touch命令在自动备份和整理文件文件时非常有用.</p>
<p><a id="org0ba94bd"></a></p>
<h2 id="mv-移动和重命名">mv: 移动和重命名</h2>
<p>mv其实是move的缩写形式.这个命令可以用来移动文件或目录到另一个路径.这里移动到的文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mv</span> hello bin/ <span class="comment">## 把hello文件移动到bin目录下</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mv</span> Photos/ 桌面/ <span class="comment">## 把Photos目录移动到桌面目录下</span></span></span><br></pre></td></tr></table></figure>
<p>由于执行mv命令的时候并不会有任何信息显示,那么如果目标目录中有一个同名文件,不加任何选项的mv命令会强制替换文件.这一行为极其危险,容易强制替换掉一些关键文件.为了避免这种情况出现,我们可以用-i选项来控制覆盖文件与否,</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mv</span> -i hello <span class="built_in">test</span>/ <span class="comment">## 出现同名文件询问是否覆盖</span></span></span><br></pre></td></tr></table></figure>
<p>其会先询问用户是否覆盖旧文件,输入y表示直接覆盖,输入n表示取消移动操作.</p>
<p>另外一个避免强制覆盖的选项是-b,其与-i的询问不同,如果出现同名文件,那么他会在转移之前将目标目录中的同名文件的文件名后面加一个~,形成一个备份,从而避免文件覆盖情况的发生.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mv</span> -b hello <span class="built_in">test</span>/ <span class="comment">## 出现同名文件则对其备份</span></span></span><br></pre></td></tr></table></figure>
<p>Linux中不存在重命名的操作,我们可以认为重命名只不过是在同一级目录下的移动而已.因此我们可以用mv命令来实现对文件或目录的重命名.
如</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mv</span> hello world <span class="comment">## 在同级目录下进行重命名</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mv</span> /home/lyd/hello /home/lyd/learning/world <span class="comment">## 移动到其他目录并且重命名</span></span></span><br></pre></td></tr></table></figure>
<p>使用mv命令可能出现的一些简单情况,</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mv</span> file1 file2 <span class="comment">## 移动file1到file2</span></span></span><br></pre></td></tr></table></figure>
<p>如果file2存在,他的内容会被file1的内容覆盖.如果file2不存在,那就会创建file2.但这两种情况下,file1都不会存在.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mv</span> file1 file2 dir1/ <span class="comment">## 移动file1和file2到目录dir1中</span></span></span><br></pre></td></tr></table></figure>
<p>这个命令的前提是目录dir1必须已经存在.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mv</span> dir1/ dir2/ <span class="comment">## 移动目录dir1到目录dir2</span></span></span><br></pre></td></tr></table></figure>
<p>如果目录dir2不存在,创建目录dir2,并且移动目录dir1的内容到目录dir2中,同时删除目录dir1.如果dir2存在,移动目录dir1及他的内容到目录dir2.</p>
<p><a id="org8b9b032"></a></p>
<h2 id="cp-复制文件和目录">cp: 复制文件和目录</h2>
<p>cp命令用来复制文件和目录.下面的指令用来将test.php复制到test目录下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cp</span> test.php <span class="built_in">test</span>/ <span class="comment">## 复制文件到指定路径</span></span></span><br></pre></td></tr></table></figure>
<p>和mv命令一样,cp在默认情况下也会强制覆盖目标目录中的同名文件.同样我们可以用-i选项来对这种覆盖文件的情况进行提示,我们也可以用-b选项来避免询问,通过对同名文件进行一个修改命名再进行复制.这两个选项的使用和mv命令的一样,因此不再赘述.</p>
<p>如果我们希望复制一个目录到另一个目录下,而直接用cp命令进行复制,则会有如下结果</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cp</span> learning/ Downloads/ <span class="comment">## 报错的复制目录</span></span></span><br><span class="line">cp: 未指定 -r；略过目录 &#x27;learning/&#x27;</span><br></pre></td></tr></table></figure>
<p>这是因为cp命令在执行复制任务的时候会自动跳过目录.如果我们一定要连同目录及其内部的文件一块复制到另一个目录,我们需要用-r选项来实现这一操作.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cp</span> -r learning/ Downloads/ <span class="comment">##  复制目录到指定目录</span></span></span><br></pre></td></tr></table></figure>
<p>使用cp可能出现的一些简单情况,</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cp</span> file1 file2 <span class="comment">## 复制文件file1内容到文件file2</span></span></span><br></pre></td></tr></table></figure>
<p>如果file2存在,那么file2的内容会被file1的内容覆盖.如果file2不存在,那就会创建一个file2.但和mv删除file1不同,cp命令会保留file1.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cp</span> file1 file2 dir1/ <span class="comment">## 复制文件file1和file2到目录dir1</span></span></span><br></pre></td></tr></table></figure>
<p>但这里必须要求目录dir1存在.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cp</span> dir1/* dir2/ <span class="comment">## 用通配符移动文件</span></span></span><br></pre></td></tr></table></figure>
<p>与-r选项不同,用通配符来批量移动dir1中的文件,要求dir2存在并且移动只会复制dir1中的文件和子目录,不会在dir2中复制dir1这个目录.</p>
<p><a id="org9b7d339"></a></p>
<h2 id="rmdir-和-rm-删除目录和文件">rmdir 和 rm: 删除目录和文件</h2>
<p>rmdir命令可以用来删除目录.其只需要在rmdir命令后面接要删除的文件名即可.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> remove <span class="comment">##创建一个空目录</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">rmdir</span> remove <span class="comment">##删除指定的空目录</span></span></span><br></pre></td></tr></table></figure>
<p>但rmdir只能用于删除空目录,一旦试图用其删除非空目录,那么会有如下报错</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">rmdir</span> learning</span></span><br><span class="line">rmdir: 删除 &#x27;learning&#x27; 失败: 目录非空</span><br></pre></td></tr></table></figure>
<p>因此,如果我们想要用rmdir删除非空目录,我们需要先删除该目录下的所有子目录及文件.</p>
<p>对于文件的删除可以用rm命令,其实rm命令也可以针对目录,此处rm命令删除的目录是允许出现非空目录,因此rm的应用远比rmdir更为广泛.rm命令可以一次性删除单个或多个文件,</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">rm</span> <span class="built_in">test</span>/* <span class="comment">## 删除test目录下的所有文件</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">rm</span> halo <span class="comment">## 删除halo文件</span></span></span><br></pre></td></tr></table></figure>
<p>和前面的mv和cp命令一样,rm不会在运行过程中出现任何提示,利用rm命令删除的文件并不会被移入回收站,而是直接从系统中删除.因此为了安全的使用rm,我们一般用-i选项来在删除过程之前给出提示等待用户确认,与前面的mv和cp一样.但有个例外,如果我们删除只读文件,那么即便我们不使用-i选项,rm命令也会对这一操作进行询问</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">rm</span> <span class="built_in">test</span> <span class="comment">## 删除test只读文件</span></span></span><br><span class="line">rm: 是否删除有写保护的普通空文件 &#x27;test&#x27;？ </span><br></pre></td></tr></table></figure>
<p>如果对这个交互操作默认是y,且不想多次交互,我们可以用-f选项来跳过这些交互操作,rm会自动对这些交互操作回答y.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">rm</span> -f <span class="built_in">test</span> <span class="comment">## -f选项跳过交互操作</span></span> </span><br></pre></td></tr></table></figure>
<p>我们可以用带-r选项的rm命令会递归的删除指定目录下所有文件和子目录.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">rm</span> -r Photos/ <span class="comment">## 递归删除Photos目录</span></span></span><br></pre></td></tr></table></figure>
<p>关键在于使用rm
-rf命令一定要注意评估删除的后果,不然可能会破坏系统的稳定性,故慎用rm
-r命令.</p>
<p><a id="org1f6941e"></a></p>
<h2 id="linux文件目录权限">Linux文件目录权限</h2>
<p>Linux的文件目录权限针对三类人群:文件所有者(属主),文件属组用户,其他人.关键在于其他人的多样性,可能会对文件目录内容进行修改,从而有机会造成不可预料的信息损坏.root用户虽然应该归属于上面的其他人,但root用户显然具有对系统任意文件的查看,修改,执行权利,因为root用户拥有控制一台计算机的所有权限.</p>
<p>文件所有者一般是文件的创建者.但这并不是绝对的,root用户可以修改一个文件的属主用户.换言之,在某个用户在linux系统创建了某个文件,此时文件所有者(属主)自动是文件创建者,但后续过程中root用户可以将文件所有者进行转让,这个转让过程也仅能用root用户进行.</p>
<p>当然文件的权限也会被给予一个用户组,我们称这个用户组为文件的属组.组是一群用户组成的一个集合.文件属组中的用户按照设置对文件享有特定的权限.通常而言,当一个用户创建了一个文件,那么该文件的属主就是这个用户,而文件的属组则是有且仅有该用户的用户组.当然我们也可以设置这个文件属组是一个不包括文件属主的用户组.如果文件属主执行文件操作的时候,系统只会关注于文件属主的权限,而文件属组的权限并不会对文件属主的权限造成影响.</p>
<p>其他人则是不包括文件所有者,文件属组用户和root用户以外的其他用户.通常其他人的权限十分低,甚至于无法对文件有任何权限.</p>
<p>可以用来赋予用户的文件和目录的权限为读取(r),写入(w)和执行(x).对于文件而言,读取权限意味着可以打开并查看文件的内容,写入权限控制着对文件的修改权限,至于是否能呢更狗删除和重命名一个文件则是由其父目录的权限设置所控制.要让一个文件可执行,必须设置其执行权限.可执行文件有两类,一类是可以直接由CPU执行的二进制代码,另一类则是Shell脚本程序.</p>
<p>对目录而言,目录的执行权限其实是控制用户是否能够进入该目录,因此目录的执行权限其实上是目录的最基本的权限.而读取权限负责确定能否列出该目录的内容,写入权限则控制在目录中创建,删除和重命名文件.</p>
<p><a id="org3d640d7"></a></p>
<h2 id="ls--l-查看文件类型">ls -l: 查看文件类型</h2>
<p>前面介绍ls命令时,提到了ls
-l来查看文件的属性,此处进一步解释展示的文件属性的参数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l  <span class="comment">## 列出所有文件和目录以及其对应的属性</span></span></span><br><span class="line">  总计 152</span><br><span class="line">  drwxr-xr-x  2 lyd  lyd   4096  2月  5 09:49  公共</span><br></pre></td></tr></table></figure>
<ul>
<li>第一个字段中的第一个字符表示文件类型,这个例子是d,其表示这是一个目录,具体的字符和文件类型的对应下表所示,</li>
</ul>
<div data-align="center">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<colgroup>
<col  class="org-left" />
</colgroup>
<colgroup>
<col  class="org-left" />
</colgroup>
<colgroup>
<col  class="org-left" />
</colgroup>
<colgroup>
<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">
文件类型
</th>
<th scope="col" class="org-left">
符号
</th>
<th scope="col" class="org-left">
文件类型
</th>
<th scope="col" class="org-left">
符号
</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">
普通文件
</td>
<td class="org-left">
-
</td>
<td class="org-left">
本地域套接口
</td>
<td class="org-left">
s
</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">
目录
</td>
<td class="org-left">
d
</td>
<td class="org-left">
有名管道
</td>
<td class="org-left">
p
</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">
字符设备文件
</td>
<td class="org-left">
c
</td>
<td class="org-left">
符号链接
</td>
<td class="org-left">
l
</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">
块设备文件
</td>
<td class="org-left">
b
</td>
<td class="org-left">
 
</td>
<td class="org-left">
 
</td>
</tr>
</tbody>
</table>
</div>
<p>其中具体的含义大概解释如下,Linux一般用设备文件来表示一个特定的硬件设备.Linux中有两类设备文件:字符设备文件和块设备文件.其中字符设备指的是能从他那读取成字符序列的设备,如磁带和串行设备;块设备则是指用来存储数据并对其各部分内容提供同等访问权的设备,如磁盘.一般我们可以称字符设备为顺序访问设备,块设备则为随机访问设备.这是因为块设备可以从硬盘的任何随机位置获取数据,而字符设备则必须按照数据发送的顺序从串行线路上获得.但是系统中存在设备文件,并不代表着他一定链接着相应的硬件设备,而是表示其具有处理对应硬件设备的能力.</p>
<p>关于本地域套接口和有名管道这两个文件涉及到了进程间通信,日常使用并不常见.</p>
<p>符号链接会在后续的ln里介绍,类似于windows系统的快捷方式.</p>
<ul>
<li>接下来的rwxr-xr-x则是三组权限位,断句如下rwx,r-x,r-x,分别代表着属主,属组,其他用户的权限.r表示可读取,w表示可写入,x表示可执行,如果某个权限被禁用,那么其会用短横线-取代.</li>
<li>紧跟着三组权限位的数字表示文件的链接树木.此处是2.表示该目录存在两个链接,关于链接后续会给出介绍.</li>
<li>后面第三个字段和第四个字段表示文件的属主和属组.</li>
</ul>
<p>ls
-l可以用来查看某个特定文件的属性,但是如果我们需要查看目录的属性则需要用ls
-ld命令来查看.</p>
<p><a id="orgaef0396"></a></p>
<h2 id="chown-和-chgrp-改变文件所有权">chown 和 chgrp:
改变文件所有权</h2>
<p>chown命令用于改变文件的所有权.chown命令的基本语法为:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chown [OPTION] ... [OWNER][:[GROUP]] FILE... ## chown语法基本结构</span><br></pre></td></tr></table></figure>
<p>这条命令可以将文件FILE的属主更改为OWNER,属组更改为GROUP.
下面命令给出了一个示例,其将文件的属主更改为LYD,同时将文件属组更改为root组,</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo <span class="built_in">chown</span> LYD:root file <span class="comment">## 修改文件file的属主为LYD,同时修改属组为root组</span></span></span><br></pre></td></tr></table></figure>
<p>如果我们只需要修改文件的属主,那么我们只需要输入OWNER,不需要输入:GROUP.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo <span class="built_in">chown</span> LYD file <span class="comment">## 修改文件file的属主为LYD,但不对属组进行修改</span></span></span><br></pre></td></tr></table></figure>
<p>同样,我们只修改文件属组的话,只需要输入:GROUP,但这里要注意的是冒号:并不是可省略的,省略参数OWNER即可,</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo <span class="built_in">chown</span> :root file <span class="comment">## 修改文件file的属组为root,但不对属主进行操作</span></span></span><br></pre></td></tr></table></figure>
<p>我们在前面用chown修改单个文件的属组和属组.实际上我们可以用chown来修改目录文件的属主和属组,但是显然如果我们只修改目录文件的属主和属组的话,并没有什么意义.因此我们可以利用chown命令的-R选项,用于改变一个目录及其下所有文件(包括子目录)的所有权设置.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo <span class="built_in">chown</span> -R LYD:root iso/ <span class="comment">## 递归修改iso文件及其下的所有文件(包括子目录)的所有权</span></span></span><br></pre></td></tr></table></figure>
<p>由于chown可以更改文件的属主和属组属性,但实际上Linux系统提供了另一个命令chgrp,其专门用来修改文件的属组.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">chgrp</span> nogroup days <span class="comment">## 更改文件属组</span></span></span><br></pre></td></tr></table></figure>
<p>同样和chown一样,我们也可以用-R选项来递归的更改目录及其下所有文件和子目录的属组.但是这里chgrp和chown有一个关键区别在于,chown修改文件属组需要用root用户权限,然而对于chgrp,其只需要修改的用户在文件的属组就可以修改文件的属组.</p>
<p><a id="orgad5e953"></a></p>
<h2 id="chmod-改变文件权限">chmod: 改变文件权限</h2>
<p>chmod用来改变一个文件的权限.其修改删除权限的模式是用户组+/-权限的表达式.具体而言,用户组分为文件属主(u),文件属组(g),其他人(o),以及所有人(a).权限则表示读取(r),写入(w)和执行(x).</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">chmod</span> u+x days <span class="comment">## 为days文件属主提供文件执行权限</span></span></span><br></pre></td></tr></table></figure>
<p>chmod可以用a来同时指定包括文件属主,文件属组和其他人的三类人,我们可以利用以此同时给全部人员增加或删除权限.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">chmod</span> a+w days <span class="comment">## 为days文件的所有人同时提供文件的写入权限</span></span></span><br></pre></td></tr></table></figure>
<p>如果我们需要同时给三类人增删权限,除了用a来表示所有人以外,实际上我们可以不加任何用户组标记,直接用+/-权限的形式,同样可以给全部人员增加或删除权限</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">chmod</span> +rw file <span class="comment">## 为文件file的所有用户增加读取权限和写入权限</span></span></span><br></pre></td></tr></table></figure>
<p>这个命令中我们通过+rw同时给所有用户添加了读取权限和写入权限,这也就是说我们可以在一个命令中同时给用户添加或删除一个或多个权限.进一步我们可以利用逗号来分隔不同的两个修改权限操作</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">chmod</span> u+r,go-w file <span class="comment">## 为文件file的属主添加读取权限,属组和其他人则删除写入权限</span></span></span><br></pre></td></tr></table></figure>
<p>在这里,我们用了一个go来同时对属组和其他人进行修改权限操作,因此实际上我们可以看出来前面用的所有人标识符a和ugo等价.上面我们用逗号分隔符来分隔对不同用户的修改权限操作,实际上我们也可以用逗号分隔符来分隔对同一用户做的不同修改操作.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">chmod</span> u+r,u-w file <span class="comment">## 为文件file的属主添加读取权限的同时,删除文件属主的写入权限</span></span></span><br></pre></td></tr></table></figure>
<p>如果用上面的添加或删除操作修改用户的权限来达到预期会极其复杂,中间也可能需要多次用ls
-l查看文件属性.因此chmod还存在一个规则:用户组=权限来直接设置文件权限.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">chmod</span> ug=rw,o=r file <span class="comment">## 文件的属主和属组权限更改为读取权限和写入权限,而其他人的权限更改为读取权限</span></span></span><br></pre></td></tr></table></figure>
<p>如果文件本身就有一个默认设定的权限,=这种规则会先重置需要修改的用户组的默认规则,然后按照=设定的权限重新赋予.虽然我们举了对所有用户用=修改权限的例子,但实际上,=规则是可以只对其中部分进行修改的.</p>
<p>最后最为常用的是用户组1=用户组2,其的作用在于将用户组1的权限和用户组2的权限设置成一样.明确来说,他的作用是将用户组2的权限覆盖用户组1的权限.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">chmod</span> o=u file <span class="comment">## 将文件file的其他人权限设置成文件属主的权限</span></span></span><br></pre></td></tr></table></figure>
<p>最为关键的一点是只有文件的属主和root用户才可以修改文件的权限.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">chmod</span> u+r file1 file2 <span class="comment">## 为文件file1和file2的属主增加读取权限</span></span></span><br></pre></td></tr></table></figure>
<p>但这里要注意这样的修改要么在root用户下进行,要么两个文件的属主是同一个用户</p>
<p>虽然我们前面已经将权限用三个字母来表示,但这对批量修改文件的权限十分麻烦,因此我们可以用八进制来代表设置权限.由于对于任意的权限而言,其只存在两种状态:设置(1)和不设置(0).所以我们可以得到任意一组权限设置的八进制表示,如'rwx'的二进制为111,八进制为7;'r-x'的二进制为101,八进制为5.这样我们就可以将完整的9位权限位用3个八进制数来表示,例如'rwxr-x-w-'分别对应的三个三位二进制为111/101/010,其对应的三个八进制数752.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">chmod</span> 752 file <span class="comment">## 将文件权限设置为 rwx/ r-x/ -w-</span></span> </span><br></pre></td></tr></table></figure>
<p><a id="orgece5a30"></a></p>
<h2 id="ln-建立链接">ln: 建立链接</h2>
<p>ln命令是用来为某个文件在另一个位置创建一个同步的链接.链接主要分为符号链接(软链接)和硬链接两大类.无论硬链接还是软链接,他们都不会重新复制原来的文件,他们只会占用非常少量的磁盘空间.</p>
<p>符号链接,也被称为软链接,其用ln
-s命令来创建生成.软链接具有如下的特点,</p>
<ol type="1">
<li><p>软链接以路径的形式存在,类似于windows系统的快捷方式</p></li>
<li><p>软链接可以跨越不同的文件系统</p></li>
<li><p>软链接可以对一个不存在的文件名进行链接</p></li>
<li><p>软链接还可以对目录文件进行链接</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ln</span> -s TARGET LINKNAME <span class="comment">## 为文件TARGET创建了一个别名LINKNAME</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l LINKNAME <span class="comment">## 查看LINK_NAME的属性</span></span></span><br><span class="line">lrwxrwxrwx 1 lyd lyd 6  4月 15 11:31 LINK_NAME -&gt; TARGET</span><br></pre></td></tr></table></figure></li>
</ol>
<p>从这里我们可以看出这个文件被指向TARGET文件,因此访问LINK_NAME就相当于访问TARGET.需要注意的是,这里的LINKNAME只是提供了访问TARGET的一个路径,因此我们删除LINKNAME并不会影响TARGET的正常运行,反之我们删除TARGET,虽然不会同时删除LINKNAME,但是其存在已经没有任何意义了.</p>
<p>同样符号链接还可用于目录,</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ln</span> -s learning/ LINK <span class="comment">## 为目录learning创建一个别名LINK</span></span></span><br></pre></td></tr></table></figure>
<p>此外,对于软链接而言,其还存在删除和修改操作如下,</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">rm</span> -rf LINKNAME <span class="comment">## 删除软链接</span></span></span><br></pre></td></tr></table></figure>
<p>切记不要在软链接后面加/,不然如果软链接对应的是目录文件,可能会直接把目录文件里的内容全部删除.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ln</span> -snf NEWTARGET LINK <span class="comment">## 将LINK链接的文件从原文件更改到新文件NEWTARGET</span></span></span><br></pre></td></tr></table></figure>
<p>这里的修改操作,不止允许同一类型之间文件的链接相互更改,还可以把普通文件的链接文件链接到目录文件,亦或反之.</p>
<p>Linux中的另一种链接称为硬链接.其将两个独立的文件联系在一起,因此硬链接和软链接的本质区别是,硬链接是直接引用,而软链接是通过名称进行引用.</p>
<p>硬链接具有的特性如下,</p>
<ol type="1">
<li>以文件副本的形式存在,但不占用实际空间</li>
<li>不允许给目录创建硬链接</li>
<li>硬链接不能跨越文件系统创建,只能在同一个文件系统里创建</li>
</ol>
<p>硬链接和软链接不同,硬链接用不带-s选项的ln命令直接创建,</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ln</span> world worldlink <span class="comment">## 创建world的硬链接文件worldlink</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l worldlink <span class="comment">## 查看硬链接文件的属性</span></span></span><br><span class="line">-r----xrw- 2 lyd lyd 4  4月  8 07:39 world_link</span><br></pre></td></tr></table></figure>
<p>根据上述查看的文件属性,我们得知这两个文件是独立的,但是会被联系在一起而已.</p>
<p>无论软链接还是硬链接,只是对目标文件的一个访问渠道而已,因此我们在任何一类链接文件上修改都会导致目标文件的变化.</p>
<p><a id="org898ec68"></a></p>
<h2 id="输入输出重定向和管道">输入输出重定向和管道</h2>
<p>重定向和管道操作是Linux的Shell命令里的一种高级特性,其允许用户修改程序获取输入或者生成输出的位置.</p>
<p>在默认情况下程序输出结果的位置称之为标准输出.通常来说,标准输出位都是显示器.输出重定向的作用是将程序的输出转移到另一个地方去,</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> &gt; ~/ls_out <span class="comment">## 将输出结果定向到ls_out文件</span></span></span><br></pre></td></tr></table></figure>
<p>如果指定文件不存在,那么这个命令会创建这个文件,反之如果这个文件是存在的,那么他会直接覆盖文件原有的内容.如果我们希望能够保留原来文件中的内容,那么我们可以用输出重定向符号&gt;&gt;,</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">date</span> &gt; date_out <span class="comment">## 将date命令的输出重定向到date_out文件</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> date_out <span class="comment">## 查看date_out文件</span></span></span><br><span class="line">2024年 04月 16日 星期二 21:15:39 CST</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">uname</span> -r &gt;&gt; date_out <span class="comment">## 将输出结果重定向至date_out文件,并且仅在末尾输出,不覆盖原文件</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> date_out <span class="comment">## 再次查看date_out文件</span></span></span><br><span class="line">2024年 04月 16日 星期二 21:15:39 CST</span><br><span class="line">6.5.0-26-generic</span><br></pre></td></tr></table></figure>
<p>类似于标准输出的定义,程序默认情况下接受输入的地方称之为标准输入.通常来说,标准输入指向键盘.如果使用不带任何参数的cat命令,cat不会执行而是等待从标准输入来获取数据,用户可以输入一行会直接输出在屏幕上,直到Ctrl+D用来给cat命令输入一个文件结束符.
在此,我们罗列一下基于shell的常用快捷键及其含义</p>
<ol type="1">
<li>Ctrl+c 终止当前正在执行的程序</li>
<li>Ctrl+z
中断当前进程,但不是终止进程,只是将进程挂起,我们可以用fg命令来重新调用进程(后续介绍)</li>
<li>Ctrl+l 清空屏幕</li>
<li>Ctrl+d 输入特殊的二进制值,表示EOF,作为文件的结束</li>
</ol>
<p>通过使用输入重定向符号&lt;可以让程序从一个文件中获取输入,</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> &lt; file <span class="comment">## 输出file里的内容</span></span></span><br></pre></td></tr></table></figure>
<p>显然cat可以直接接受参数来显示文件内容,因此输入重定向对这类命令并没有优势,故其使用比较少.</p>
<p>类似,其也存在另一种重定向符号&lt;&lt;,被称之为立即文档.立即文档告诉shell从键盘接受输入,并传递给程序,</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> &lt;&lt; <span class="string">EOF ## 立即文档作为输入,EOF</span>用来输入文档终止</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">Hello</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">,</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">world</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">!</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">EOF</span></span><br><span class="line">Hello</span><br><span class="line">,</span><br><span class="line">world</span><br><span class="line">!</span><br></pre></td></tr></table></figure>
<p>这里的EOF只是代用常见的终止缩写,实际上是可以随意使用的,只需要保证输入的内容中不会出终止代号即可.进一步,上面提到的两个重定向符号是可以在同一个命令中出现的.</p>
<p>管道符号|的出现则进一步使输出重定向的功能变灵活.通过一条竖线,将一个命令的输出作为下一个命令的输入,</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> | grep ld <span class="comment">##罗列文件列表以后查找文件名包含ld的文件</span></span></span><br><span class="line">world</span><br><span class="line">worldlink</span><br></pre></td></tr></table></figure>
<p>当然管道可以继续叠加使用,虽然会十分复杂但是运行起来会很高效.</p>
<p><a id="org86fc6aa"></a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Computer Science</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>SVD-Mathematical Overview</title>
    <url>/2024/04/18/svd-1/</url>
    <content><![CDATA[<p>​ Firstly, we consider a large data matrix <span
class="math inline">\(X\in \mathbb{C}^{n\times m}\)</span>:</p>
<p><span class="math display">\[
X=\begin{bmatrix}\vdots&amp;\vdots&amp;\
&amp;\vdots\\x_1&amp;x_2&amp;\cdots&amp;x_m\\\vdots&amp;\vdots&amp;\
&amp;\vdots\end{bmatrix}
\]</span> The column <span class="math inline">\(x_k\in
\mathbb{C}^n\)</span> is obtained from simulations or experiments.
Here,we always consider the column vectors may also represent the state
of a physical system that is evolving in time.The column are often
called snapshots and <span class="math inline">\(m\)</span> is the
number of snapshots in <span class="math inline">\(X\)</span>.</p>
<p>The Singular Value Decomposition allows us to decompose any
complex-valued matrix as the product of three other matrices,</p>
<span id="more"></span>
<p><span class="math display">\[
X=U\Sigma V^T=\begin{bmatrix}\vdots&amp;\vdots&amp;\
&amp;\vdots\\u_1&amp;u_2&amp;\cdots&amp;u_n\\\vdots&amp;\vdots&amp;\
&amp;\vdots\end{bmatrix}\begin{bmatrix}\sigma_1&amp;\ &amp;\ &amp;\ \\\
&amp;\sigma_2&amp;\ &amp;\ \\\ &amp;\ &amp;\ddots&amp;\ \\
\ &amp;\ &amp;\ &amp;\sigma_m\\\ &amp;\ &amp;\ &amp;\ \\\ &amp;\ &amp;\
&amp;\ \\\ &amp;\ &amp;\ &amp;\
\end{bmatrix}\begin{bmatrix}\vdots&amp;\vdots&amp;\
&amp;\vdots\\v_1&amp;v_2&amp;\cdots&amp;v_m\\\vdots&amp;\vdots&amp;\
&amp;\vdots\end{bmatrix}^T
\]</span> where <span class="math inline">\(U\in \mathbb{C}^{n\times
n}\)</span> and <span class="math inline">\(V\in\mathbb{C}^{m\times
m}\)</span> are unitary matrices. If a square matrix <span
class="math inline">\(U\)</span> satisfies <span
class="math inline">\(U^{\star}U=UU^{\star}=I\)</span>, we call it
unitary matrix. Here * denotes the complex conjugate transpose. For
real-valued matrices, it is the same as the regular transpose, <span
class="math inline">\(X^{\star}=X^T\)</span>. So if <span
class="math inline">\(U\)</span> and <span
class="math inline">\(V\)</span> are real-valued matrices, we call them
orthogonal matrices. Since the conclusions of real-valued and
complex-valued <span class="math inline">\(U\)</span> and <span
class="math inline">\(V\)</span> are parallel, we will only discuss the
real-valued case in the following. <span class="math inline">\(\Sigma\in
\mathbb{R}^{n\times m}\)</span> is a diagonal matrix, which means
real,non-zero entries on thediagonal and zeros off the diagonal.</p>
<p>​ These column of <span class="math inline">\(U\)</span> have the same
shape as a column of <span class="math inline">\(X\)</span>. The columns
of <span class="math inline">\(U\)</span> describe the eigen of the data
in <span class="math inline">\(X\)</span>. So in the case of faces,
these mean eigenfaces and in the case of flow fields, these mean
eigenflow fields. Furthermore, the columns of <span
class="math inline">\(U\)</span> are hierarchically arranged in terms of
their ability to describe the variance in the column of <span
class="math inline">\(X\)</span>. In other words, <span
class="math inline">\(u_1\)</span> is somehow more important than <span
class="math inline">\(u_2\)</span> and so on and so forth.</p>
<p>​ <span class="math inline">\(U\)</span> gives me a basis, based on
which we can represent each column of original data in <span
class="math inline">\(X\)</span>.Actually, these basis have great
properties. Since <span class="math inline">\(U\)</span> is an unitary
matrix, it means the column of <span class="math inline">\(U\)</span>
are orthonormal. So these column are all orthogonal , have unit length
and provide a complete basis for n-dimensional subspace where the column
of data matrix lives.</p>
<p>​ <span class="math inline">\(\Sigma\)</span> is not only a diagnol
matrix, but also non-negative and hierarchically ordered matrix. So we
have <span
class="math inline">\(\sigma_1\geq\sigma_2\geq\sigma_3\geq\cdots\geq\sigma_m\geq0\)</span>.
They are all non-negative, although some of them could be zero.
According to the matrix multiplication, we can find that <span
class="math inline">\(\sigma_1\)</span> correspond to the first columns
of <span class="math inline">\(U\)</span> and <span
class="math inline">\(V\)</span>.Since <span
class="math inline">\(\sigma_1\geq\sigma_2\)</span>, it means that the
first columns are somehow important than the second ones when we
describe the information of <span class="math inline">\(X\)</span>. In
other words, the sigular value provides the relative imporatance of
these corresponding columns of <span class="math inline">\(U\)</span>
and <span class="math inline">\(V\)</span>. Finally, we say that the
sigular values are ordered by importance.</p>
<p>​ Here we will start in the case of flow fields. The columns of <span
class="math inline">\(U\)</span> will be eigen flows hierarchically
organized. We call the first column of <span
class="math inline">\(V\)</span> as <span
class="math inline">\(v_1\)</span>. So <span
class="math inline">\(v_1\)</span> would be the time series for how this
first eigen mode <span class="math inline">\(u_1\)</span> evolves in
this flow.</p>
<p>The matrix <span class="math inline">\(U\)</span> is called left
sigular column and the columns are called left singular vectors. <span
class="math inline">\(V\)</span> is similar to <span
class="math inline">\(U\)</span>. The diagonal elements of <span
class="math inline">\(\Sigma\)</span> are called sigular values.The rank
of X is equal to the number of non-zero sigular value.</p>
]]></content>
      <categories>
        <category>Reduced Order Model</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>SVD-Matrix Approximation</title>
    <url>/2024/04/19/svd-2/</url>
    <content><![CDATA[<p>The SVD allows us to decompose data matrix <span
class="math inline">\(X\)</span> as the product of three matrices, <span
class="math inline">\(U,\ V^T,\ \Sigma\)</span>, where essentially <span
class="math inline">\(U\)</span> contains information about the column
space of <span class="math inline">\(X\)</span>, <span
class="math inline">\(V\)</span> contains information about the row
space of <span class="math inline">\(X\)</span> and <span
class="math inline">\(\Sigma\)</span> is a hierarchically ordered
diagonal matrix, which tells you how important the various columns of
<span class="math inline">\(U\)</span> and <span
class="math inline">\(V\)</span> are.</p>
<span id="more"></span>
<p>In fact, the data matrix <span class="math inline">\(X\)</span> has
only <span class="math inline">\(m\)</span> columns, it means there are
at most <span class="math inline">\(m\)</span> linearly independence
columns in this <span class="math inline">\(n\)</span>-dimensional
vector space.So the first <span class="math inline">\(m\)</span> columns
of <span class="math inline">\(U\)</span> are important in representing
this data matrix. To explain this fact more deeply, we try to represent
expansion as a sum of rank-1 matrices.</p>
<p>Based on the Singular Value Decomposition,we can get the following
equation, <span class="math display">\[
X=U\Sigma V^T=\begin{bmatrix}\vdots&amp;\vdots&amp;\
&amp;\vdots\\u_1&amp;u_2&amp;\cdots&amp;u_m\\\vdots&amp;\vdots&amp;\
&amp;\vdots\end{bmatrix}\begin{bmatrix}\sigma_1&amp;\ &amp;\ &amp;\ \\\
&amp;\sigma_2&amp;\ &amp;\ \\\ &amp;\ &amp;\ddots&amp;\ \\
\ &amp;\ &amp;\ &amp;\sigma_m\\\ &amp;\ &amp;\ &amp;\ \\\ &amp;\ &amp;\
&amp;\ \\\ &amp;\ &amp;\ &amp;\
\end{bmatrix}\begin{bmatrix}\cdots&amp;v_1^{T}&amp;\cdots\\\cdots&amp;v_2^T&amp;\cdots\\\
&amp;\vdots&amp;\ \\\cdots&amp;v_m^T&amp;\cdots\end{bmatrix}^T
\]</span> Since <span class="math inline">\(\Sigma\)</span> is a
diagnoal matrix, we can expand the above equation as follow, <span
class="math display">\[
X=U\Sigma
V^T=\sigma_1u_1v_1^T+\sigma_2u_2v_2^T+\cdots+\sigma_mu_mv_m^T=\begin{bmatrix}\vdots&amp;\vdots&amp;\
&amp;\vdots\\u_1&amp;u_2&amp;\cdots&amp;u_m\\\vdots&amp;\vdots&amp;\
&amp;\vdots\end{bmatrix}\begin{bmatrix}\sigma_1&amp;\ &amp;\ &amp;\ \\\
&amp;\sigma_2&amp;\ &amp;\ \\\ &amp;\ &amp;\ddots&amp;\ \\
\ &amp;\ &amp;\
&amp;\sigma_m\end{bmatrix}\begin{bmatrix}\cdots&amp;v_1^{T}&amp;\cdots\\\cdots&amp;v_2^T&amp;\cdots\\\
&amp;\vdots&amp;\
\\\cdots&amp;v_m^T&amp;\cdots\end{bmatrix}^T=\hat{U}\hat{\Sigma}V^T
\]</span> Even though <span class="math inline">\(U\)</span> is a
massive <span class="math inline">\(n\times n\)</span> matrix, there are
only at most <span class="math inline">\(m\)</span> non-zeros singular
values in <span class="math inline">\(\Sigma\)</span> that means the
rank of data matrix <span class="math inline">\(X\)</span> satisfies
<span class="math inline">\(rank(X)\leq m\)</span>. Actually,I can
selcet the first <span class="math inline">\(m\)</span> columns of <span
class="math inline">\(U\)</span>, the first <span
class="math inline">\(m\times m\)</span> block of <span
class="math inline">\(\Sigma\)</span> and the original <span
class="math inline">\(V\)</span> to represent the data matrix <span
class="math inline">\(X\)</span>. We always call <span
class="math inline">\(X=\hat{U}\hat{\Sigma}V^T\)</span> as the economy
SVD and <span class="math inline">\(X=U\Sigma V^T\)</span> as the full
SVD. Since we consider the case of <span class="math inline">\(n\gg
m\)</span>, <span class="math inline">\(\hat{U}\in \mathbb{R}^{n\times
m}\)</span> and <span class="math inline">\(\hat{\Sigma}\in
\mathbb{R}^{m\times m}\)</span> need lower storage.</p>
<p>Therefore, we can give another explanation about SVD: we can
decompose the data matrix X into the orthogonal basis <span
class="math inline">\(U\)</span> and <span
class="math inline">\(V\)</span>, where essentially you can rewrite this
as a sum of rank-1 matrices, which increasingly improve the
approximation of <span class="math inline">\(X\)</span>. According to
this explanation, we can give out some interesting results like, the
best rank-1 matrix that we can make to approximate <span
class="math inline">\(X\)</span> is <span
class="math inline">\(\sigma_1u_1v_1^T\)</span>; the best rank-2 matrix
that we can make to approximate <span class="math inline">\(X\)</span>
is <span
class="math inline">\(\sigma_1u_1v_1^T+\sigma_2u_2v_2^T\)</span> and so
on and so forth.</p>
<p>Since we hope to use less data storage to approximate the real data
as much as possible in practice, we often truncate at rank r. Oftentimes
we have a lot of negligibly small singular values like <span
class="math inline">\(\sigma_{r+1},\
\sigma_{r+2},\cdots,\sigma_m\)</span>, it means that most of the
information of <span class="math inline">\(X\)</span> is captured in the
first <span class="math inline">\(r\)</span> singular values and the
first <span class="math inline">\(r\)</span> singular vectors. So we can
throw away all of low singular values and singular vectors and only keep
the first <span class="math inline">\(r\)</span> columns of <span
class="math inline">\(U\)</span> and <span
class="math inline">\(V\)</span> and the first <span
class="math inline">\(r\times r\)</span> submatrix in <span
class="math inline">\(\Sigma\)</span>. Then we are going to define this
truncated SVD as follows, <span class="math display">\[
X\approx\begin{bmatrix}\vdots&amp;\vdots&amp;\
&amp;\vdots\\u_1&amp;u_2&amp;\cdots&amp;u_r\\\vdots&amp;\vdots&amp;\
&amp;\vdots\end{bmatrix}\begin{bmatrix}\sigma_1&amp;\ &amp;\ &amp;\ \\\
&amp;\sigma_2&amp;\ &amp;\ \\\ &amp;\ &amp;\ddots&amp;\ \\
\ &amp;\ &amp;\
&amp;\sigma_r\end{bmatrix}\begin{bmatrix}\cdots&amp;v_1^{T}&amp;\cdots\\\cdots&amp;v_2^T&amp;\cdots\\\
&amp;\vdots&amp;\
\\\cdots&amp;v_r^T&amp;\cdots\end{bmatrix}^T=\tilde{U}\tilde{\Sigma}\tilde{V}^T
\]</span> Here we find that the truncated SVD <span
class="math inline">\(\tilde{U}\tilde{\Sigma}\tilde{V}^T\)</span> is the
best rank-<span class="math inline">\(r\)</span> matrix approximating
the data matrix <span class="math inline">\(X\)</span>.Thus,
high-dimensional data may be well described by a few dominant patterns
given by the columns of <span class="math inline">\(\tilde{U}\)</span>
and <span class="math inline">\(\tilde{V}\)</span>.Like the mentioned in
the first section,we realize that the truncated singular vectors <span
class="math inline">\(\tilde{U}\)</span> provides a coordinate
transformation from the high-dimensional measurement space into a
low-dimensional pattern space.</p>
<p>The Eckart-Young theorem states that the absolute best approximation
to the matrix <span class="math inline">\(X\)</span> of rank r,
Theorem(Eckart-Young) The optimal rank-r approximation to <span
class="math inline">\(X\)</span>, in a least-squares sense, is given by
the rank-r SVD truncation <span
class="math inline">\(\tilde{X}\)</span>, <span class="math display">\[
argmin_{\tilde{X},\ s.t.\ rank(\tilde{X})=r}\left\Vert
X-\tilde{X}\right\Vert_F=\tilde{U}\tilde{\Sigma}\tilde{V}^T
\]</span> The Ecakrt-Young theorem guarantees that the best possible
matrix approximation to <span class="math inline">\(X\)</span> of rank
<span class="math inline">\(r\)</span> is given by the firsr <span
class="math inline">\(r\)</span> truncated SVD.</p>
<p>Finally,we should mention an important point. At beginning of
discussing the SVD, we define the matrices <span
class="math inline">\(U\)</span> and <span
class="math inline">\(V\)</span> are unitary. However,if we truncated at
rank r,the truncated matrices <span
class="math inline">\(\tilde{U}\)</span> and <span
class="math inline">\(\tilde{V}\)</span> are no longer square matrices,
so they are not unitary matrix again. They satisfy that <span
class="math inline">\(\tilde{U}^T\tilde{U}=\tilde{V}^TV=I,\
\tilde{U}\tilde{U}^T\not=I\)</span></p>
]]></content>
      <categories>
        <category>Reduced Order Model</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
</search>
