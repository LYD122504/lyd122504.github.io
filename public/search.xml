<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ANSI-Bit Fields</title>
    <url>/2025/03/06/ANSI-Bit%20Fields/</url>
    <content><![CDATA[<p>我们在前面提到了用空间换时间的字节对齐规则,会发现结构体其实会浪费很多的空间以用来提高程序运行速度.在这一部分,我们将讨论结构体中的节省空间的技巧,也就是所谓的位域和柔性数组.</p>
<span id="more"></span>
<p><a id="orgaf4ef34"></a></p>
<h3 id="位域">位域</h3>
<p>我们先考虑如下的实际例子,我们需要判断一个变量是否为extern,static以及关键字.如果我们用最为直接的方式,我们只需要设置多个char变量作为flag,分别设置0或1,来表示是否的二元状态.但是这样的话,我们需要开辟多个字节的空间,这样会浪费很多的空间.</p>
<p>我们先利用屏蔽码集合来解决这个问题,如</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> KEYWORD 01</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXTERNAL 02</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STATIC 04 </span></span><br></pre></td></tr></table></figure>
<p>值得注意的是,这些数字必须是2的幂次;这样我们就可以通过位运算来进行判断.例如:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">flag|=EXTERNAL|STATIC;<span class="comment">//将flag的external和static位置为1</span></span><br><span class="line">flah&amp;=~(EXTERNAL|STATIC);<span class="comment">//将flag的external和static位置为0</span></span><br></pre></td></tr></table></figure>
<p>位域指信息在存储时,并不需要占用一整个字节，而只需要占用一个或几个二进制位即可.例如,如果我们设置多个flag,分别用于判断变量是否为extern,static或const;常见的做法是用三个char变量来存储这三个flag,但这样的话,我们需要开辟三个字节的空间,然而实际上flag的取值只有0和1两个状态,因此我们完全可以只使用一个二进制位来存储每个flag.这样的话,我们只需要开辟一个字节的空间即可.这样的技巧就是位域.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> is_keyword:<span class="number">1</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> is_external:<span class="number">1</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> is_static:<span class="number">1</span>;</span><br><span class="line">&#125; flags;</span><br></pre></td></tr></table></figure>
<p>这样他只开辟了一个unsigned
int的空间.其调用和正常的结构体成员一样,通过StructName.BitName来调用.位域的使用方法大体需要遵循如下几点:</p>
<ol type="1">
<li><p>定义位域时,可以指定成员的位域宽度,即成员所占的位数</p></li>
<li><p>位域的宽度不能超过其类型的位数,因为位域必须适用于所用的整数类型(如int,unsigned
int等)</p></li>
<li><p>位域可以单独使用,也可以和其他成员一起使用,如</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> a:<span class="number">1</span>;</span><br><span class="line">  <span class="type">int</span> b;</span><br><span class="line">  <span class="type">int</span> c:<span class="number">2</span>;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>我们进一步讨论位域的几个空间占用的问题:</p>
<ol type="1">
<li><p>不可以跨字节存储,如</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> a:<span class="number">3</span>;</span><br><span class="line">  <span class="type">char</span> b:<span class="number">4</span>;</span><br><span class="line">  <span class="type">char</span> c:<span class="number">5</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>这里我们需要开辟9个二进制位,但是char只有8个二进制位,因此我们需要开辟两个字节.但实际上我们会发现,a和b已经占用了7个二进制位,因此一个字节只剩下了1个空闲的二进制位,但是c需要5个二进制位,因此我们会选择空闲掉这个空间,开辟一个新的字节空间来存储c.</p>
<ol type="1">
<li><p>不可以跨类型存储,如</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> a:<span class="number">1</span>;</span><br><span class="line">  <span class="type">int</span> b:<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>虽然这个例子里面,我们只需要两个二进制位,但我们发现这两个变量的类型不同,因此我们不能仅开辟一个字节的空间,而应该按照对应类型大小开辟.char开辟1个字节,但其需要与int对齐,所以需要额外开辟3个空闲字节;int则需要开辟4个字节,这样一共开辟8个字节.实际上在GCC下,只需要开辟4个字节,这是一种极度节省空间的方法,先开辟类型最大的空间,然后再根据实际情况来存储.
在位域中,还有一些特殊的用法,如:</p>
<ol type="1">
<li><p>无名位域:位域成员可以没有名字,只给出数据类型和位宽,</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span> m: <span class="number">12</span>;</span><br><span class="line">   <span class="type">int</span>  : <span class="number">20</span>;  <span class="comment">//该位域成员不能使用</span></span><br><span class="line">   <span class="type">int</span> n: <span class="number">4</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里的无名位域的作用一般用于填充或调整成员位置.并且因为其没有名字,所以无名位域是不可以被使用的.</p></li>
<li><p>位域的大小为0:这表示该位域为空域,其只能在无名位域中使用,下一个域则以下一个类型单元开始存放,如</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">char</span> m: <span class="number">1</span>;</span><br><span class="line">   <span class="type">short</span> l:<span class="number">2</span>;</span><br><span class="line">   <span class="type">int</span>  : <span class="number">20</span>;  <span class="comment">//该位域成员不能使用</span></span><br><span class="line">   <span class="type">int</span> n: <span class="number">4</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里的n会在第四个字节开始存放.</p></li>
</ol>
<p><a id="org83cae67"></a></p>
<h3 id="柔性数组">柔性数组</h3>
<p>柔性数组的产生其实是与coding中对动态结构体的需求有关.在日常的编程中,我们可能希望在结构体里存放一个长度是动态的数组,一般的做法是在结构体中定义一个指针成员,用这个指针指向一个动态开辟的数组空间.然而这一操作会对内存管理带来极大的困扰,因为我们需要在使用完这个结构体后,手动释放这个指针指向的空间.而柔性数组其实就是在结构体中存放一个长度动态的数组.</p>
<p><a id="org279e2b1"></a></p>
<h4 id="柔性数组的使用">柔性数组的使用</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> a;</span><br><span class="line">  <span class="type">double</span> b;</span><br><span class="line">  <span class="type">int</span> c[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>柔性数组成员的两个特征:</p>
<ol type="1">
<li>柔性数组成员只能是结构体的最后一个成员</li>
<li>柔性数组成员的数组长度为0,因此柔性数组成员不占用结构体的空间.故上面的struct空间为16个字节.</li>
</ol>
<p>因此,对于柔性数组,我们可以按照如下角度来理解:</p>
<ol type="1">
<li>柔性方面:柔性数组成员的长度是动态的,所管理的空间可大可小,因此我们可以根据实际情况来动态调整空间大小.</li>
<li>数组成员方面:形式为数组形式,但大小为0,其次,被定义在结构体内部.</li>
</ol>
<p><a id="org43a792b"></a></p>
<h4 id="传统结构体指针成员使用">传统结构体指针成员使用</h4>
<p>如果我们仅考虑静态的结构体,可能并不是很容易体现柔性数组的优势,但如果我们考虑结构体的动态生成,就会十分明显的体现出柔性数组的优势.例如:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="type">int</span>* ptr;</span><br><span class="line">&#125;Test;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> sz = <span class="number">10</span>;</span><br><span class="line">    Test* pt = (Test*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Test));</span><br><span class="line">    pt-&gt;ptr = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>) * sz);</span><br><span class="line">    pt-&gt;size = sz;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pt-&gt;size; i++)</span><br><span class="line">        pt-&gt;ptr[i] = i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pt-&gt;size; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, pt-&gt;ptr[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(pt-&gt;ptr);</span><br><span class="line">    <span class="built_in">free</span>(pt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们可以发现,传统方式下有两个缺点:</p>
<ol type="1">
<li>结构体成员ptr是一个指针,因此我们需要为之开辟空间.</li>
<li>对于申请的结构体空间和指针空间,我们需要分开申请和释放;因此这并不利于内存管理,及其容易出现内存泄漏的问题,从而导致程序运行效率低下.</li>
</ol>
<p><a id="org6427183"></a></p>
<h4 id="柔性数组成员的使用">柔性数组成员的使用</h4>
<p>柔性数组成员的使用可以很好的解决上面的问题,</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="type">int</span> ptr[<span class="number">0</span>];</span><br><span class="line">&#125;Test;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> sz = <span class="number">10</span>;</span><br><span class="line">    Test* pt = (Test*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Test)+<span class="built_in">sizeof</span>(<span class="type">int</span>)*sz);</span><br><span class="line">    pt-&gt;size = sz;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pt-&gt;size; i++)</span><br><span class="line">        pt-&gt;ptr[i] = i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pt-&gt;size; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, pt-&gt;ptr[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(pt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里其实主要的区别在于,我们在malloc的时候不仅为结构体开辟了空间,还为柔性数组开辟了空间.我们可以这么理解柔性数组成员,柔性数组成员其实就是一个指针,这个指针指向紧贴着结构体空间后的空间,当我们同时开辟结构体和柔性数组空间时,柔性数组成员其实就是指向柔性数组空间的首元素.因此,我们不需要将开辟空间的操作分开,而是一次性完成,这样就很好的解决了内存管理的问题.</p>
]]></content>
      <categories>
        <category>C Language</category>
      </categories>
      <tags>
        <tag>Computer Science</tag>
        <tag>C Language</tag>
      </tags>
  </entry>
  <entry>
    <title>ANSI-字节对齐</title>
    <url>/2025/03/02/ANSI-Byte/</url>
    <content><![CDATA[<p>现代计算机的内存空间是以Byte为基本单位划分的.从理论上说,我们可以将任意的数据类型存放在任意的内存空间之上,但实际上,在现代计算机中存在一种叫做字节对齐的机制,以保证数据存放依照一定的规则进行.所以对齐其实和数据在内存中的存放位置有关,如果一个变量的内存地址正好为他的整数倍,则称之为自然对齐.例如在32位系统中,如果一个int类型的地址为0x00000004,则为自然对齐.而我们接下来讨论的字节对齐主要针对自定义类型,例如结构体,联合体等.</p>
<span id="more"></span>
<p><a id="org3b4e663"></a></p>
<h3 id="字节对齐的作用和优势">字节对齐的作用和优势</h3>
<p>字节对齐的作用主要是为了提高内存的访问速度,从而提高程序运行性能.这是因为访问未对齐的内存时,可能需要做两次内存访问,而后做一个内存拼接操作,才可以得到正确的数据.而如果我们按照字节对齐的思路来设计内存,那么我们每次只需要一次内存访问即可得到正确的数据.所以字节对齐的主要含义是牺牲空间来换取时间.</p>
<p>例如如果每次访问要么从0x01-0x04或0x05-0x08,硬件并不支持一次访问就可以从0x02-0x05.这样的话如果我们不对齐字节,是存在将int数据存储到0x02-0x05的可能性,这样的话我们就需要先读取一遍0x01-0x04,保留0x02-0x04;而后再读取一遍0x05-0x08,保留0x05;最后将二者拼接起来,才能得到正确的数据,如此就会降低程序的运行效率.</p>
<h3 id="字节对齐的规则">字节对齐的规则</h3>
<p><a id="orgd17b927"></a></p>
<h4 id="基本数据类型的自身对齐值">基本数据类型的自身对齐值</h4>
<p>虽然我们所说的字节对齐主要针对自定义类型,但自定义类型实际上是基本数据类型的组合,因此我们需要先了解基本数据类型的自身对齐值,其实也就是基本数据类型的大小.由于不同的编译器和不同的操作系统对于基本数据类型的大小有不同的规定,我们以char为1字节,short为2字节,int为4字节,long为4字节,float为4字节,double为8字节为例进行讨论.</p>
<p><a id="org2228615"></a></p>
<h4 id="自定义类型的自身对齐值">自定义类型的自身对齐值</h4>
<p>自定义类型的自身对齐值是指自定义类型(一般指struct,union)中的成员变量的自身对齐值中的最大值.在这样的对齐规则下,自定义类型的空间占用绝不是简单的成员变量的空间大小之和.我们将在后面的例子中给出相关例子以及计算空间的规则.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> a; <span class="comment">//1</span></span><br><span class="line">  <span class="type">double</span> b;<span class="comment">//1</span></span><br><span class="line">  <span class="type">int</span> c;<span class="comment">//1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在计算结构体的空间占用时,具体流程如下:</p>
<ol type="1">
<li>首先我们需要根据基本类型的自身对齐值来先初步判断结构体的空间占用;</li>
<li>其次我们按照从上往下对齐的规则来进行第二步的字节对齐,即前面开辟的空间之和是下一个数据类型的整数倍即可,这里的整数倍特指大于空间之和的最小整数倍;</li>
<li>最后,我们还要保证结构体的整体开辟空间是自身对齐值的整数倍,这样才能保证结构体的整体对齐.</li>
</ol>
<p>这里其实我们可以发现,虽然我们做的字节对齐绝不是简单的在结构体空间的末尾加上一些空白空间,而是在适当位置加上空白空间,这样才能保证结构体的整体对齐.在上面这个例子中,我们已知char的自身对齐值为1,
double的自身对齐值为8,
int的自身对齐值为4;char与double对齐时,需要在其后面加上7个空白字节,使得开辟空间是double的整数倍;double与int对齐时,由于double和之前的char一共开辟了16个字节,而int是4个字节,已经是其整数倍,故不需要额外加空白字节;最后由于我们整个结构体开辟了20个字节,但是结构体的自身对齐值是成员变量的自身对齐值中的最大值,即8,所以我们需要在结构体的末尾加上4个空白字节,使得结构体的整体对齐值为8的整数倍.所以最终结构体的空间占用为24个字节.</p>
<p>从这里,我们其实可以意识到,尽管我们定义相同内容的结构体,由于不同的定义顺序,可能会导致结构体的空间占用不同.例如</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> a; <span class="comment">//1</span></span><br><span class="line">  <span class="type">int</span> b;<span class="comment">//1</span></span><br><span class="line">  <span class="type">double</span> c;<span class="comment">//1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样的定义方式我们只需要开辟16个字节,因此我们可以看到,结构体的定义顺序是有一定的影响的.如果我们希望节省结构体定义的空间,我们可以在定义时按照基本数据类型的自身对齐值从小到大的顺序进行定义,这样可以减少结构体的空间占用.</p>
<p><a id="orgf3aef24"></a></p>
<h4 id="程序指定的自身对齐值">程序指定的自身对齐值</h4>
<p>在C/C++中,我们可以用#pragma
pack(value)来指定程序中的自身对齐值,这样可以改变程序中的自定义类型的自身对齐值.这里如果value=1,则相当于取消对齐.这样的话自定义类型的空间就是成员变量的空间之和.这里设置的value一般而言是要求2的整数次幂,例如1,2,4,8,16等等.如此,我们可以根据实际情况来设置自定义类型的自身对齐值,从而节省空间.
例如:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(4)</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> a;</span><br><span class="line">  <span class="type">double</span> b;</span><br><span class="line">  <span class="type">int</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里由于我们设置了自身对齐值为4,这样的话我们按照上面的推导规则,char与double对齐时,因为我们显式设置了程序的字节对齐值为4,所以我们只需要在其后面补3个空白字节即可;double与int对齐时,因为之前开辟的空间是12个字节,int是4个字节,所以我们不需要补空白字节;最后我们看到整个结构体的空间占用为16个字节,这样他是我们设置的自身对齐值的整数倍,所以我们不需要再补空白字节.</p>
<p>值得注意的是,我们设置的自身对齐值是可能与前面提到的自定义类型的自身对齐值有冲突的,这时候,我们就需要讨论后续的对齐规则,也就是所谓的有效对齐值.</p>
<p><a id="org9419fb2"></a></p>
<h4 id="自定义类型的有效对齐值">自定义类型的有效对齐值</h4>
<p>自定义类型的有效对齐值是指自定义类型的自身对齐值和程序指定的自身对齐值中的最小值.这样的话,我们可以根据有效对齐值来计算自定义类型的空间占用.例如</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(4)</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> a;</span><br><span class="line">  <span class="type">short</span> b;</span><br><span class="line">  <span class="type">double</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>按照上面的规则,我们逐步分析,char与short对齐时,虽然我们设置了程序的字节对齐值为4,但是short的自身对齐值为2,所以我们只需要按照2字节对齐即可,所以我们只需要在char后面补一个空白字节即可;在short与double对齐时,因为之前开辟的空间是4个字节,而double的自身对齐值为8,但我们设置了程序的字节对齐值为4,所以我们不需要做什么操作;最后我们看到整个结构体的空间占用为12个字节,这样他是有效对齐值4的整数倍.</p>
<p><a id="org41f0052"></a></p>
<h3 id="额外的情况">额外的情况</h3>
<p><a id="orgee8c989"></a></p>
<h4 id="联合体的字节对齐">联合体的字节对齐</h4>
<p>上面我们讨论的都是结构体的字节对齐,但是联合体其实与之十分类似,但是由于结构体是为每个成员开辟了独立的空间,但是联合体则是所有成员共用一个空间,因此二者的空间占用计算是不同的.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">union</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> a[<span class="number">10</span>];</span><br><span class="line">  <span class="type">short</span> b;</span><br><span class="line">  <span class="type">double</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在这个例子中,我们可以意识到,如果我们分别为不同的成员开辟空间,那么我们需要为char[10]开辟10个字节,为short开辟2个字节,double开辟8个字节,根据联合体的定义,我们只需要开辟最大的成员的空间,即10个字节;但值得注意的是,联合体的空间占用也是需要满足字节对齐的,联合体的自身对齐值是其成员的自身对齐值的最大值,也就是8.同样我们也需要要求联合体整体空间是自身对齐值的整数倍,因此我们只需要在联合体的末尾加上6个空白字节即可,使得联合体的整体对齐值为8的整数倍.</p>
<p>这里我们要强调的是,我们所说的自身对齐值指针对变量类型,而不是变量的大小,就像我们这个例子所提到的char[10],他的对齐值是1,而不是10.</p>
<p><a id="orgbbea7ae"></a></p>
<h4 id="内嵌结构体的字节对齐">内嵌结构体的字节对齐</h4>
<p>在实际使用中,我们可能会出现需要在struct中嵌套struct的情况.我们按照上面的思想对其进行分析,</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">short</span> a;</span><br><span class="line">  <span class="keyword">struct</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">double</span> b[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">    <span class="type">char</span> d;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">long</span> e; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们先从内部的struct分析,double
b[10]需要开辟80个字节,但其的对齐值是8.double和int对齐时,double[10]开辟出的80个空间是int的整数倍,所以我们不需要额外补充空白字符;int与char对齐时,int以前开辟的空间为84个字节,是char的整数倍.因此不需要开辟空白字节;但是由于内部的struct的自身对齐值为8,所以我们需要在末尾补上3个字符,使得整体开辟88个字节,符合struct的自身对齐值的整数倍.但是值得注意的是,如果我们分析struct
A的时候,内部struct的对齐值并不是88,而是其成员类型的最大对齐值.所以我们可以开始分析struct
A.short与内部struct对齐时,short的字节空间为2,并不是内部struct的整数倍,因此我们需要在short后面补6个空白字节,使得short的空间为8的整数倍;内部struct与long对齐时,内部struct的空间以前开辟的空间为96,是long的整数倍,所以我们不需要额外开辟空白字节.最后我们看到整个struct
A的空间占用104个字节,这样他是struct A的自身对齐值的整数倍.</p>
<p>但是这里我们需要注意的是,如果我们在内部struct给了一个类型命名,那么struct
A的字节占用会有一个很大的变化,如</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span></span><br><span class="line"> &#123;</span><br><span class="line">   <span class="type">short</span> a;</span><br><span class="line">   <span class="keyword">struct</span> <span class="title class_">t</span></span><br><span class="line">   &#123;</span><br><span class="line">     <span class="type">double</span> b[<span class="number">10</span>];</span><br><span class="line">     <span class="type">int</span> c;</span><br><span class="line">     <span class="type">char</span> d;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="type">long</span> e; </span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>
<p>这样的话,我们会认为struct
t是一个内嵌类型,并不会为只分配空间,所以也就是说,struct
t的类型定义和typedef的作用是一样的,并不会为其分配空间.所以我们在分析struct
A的时候,只需要按照除了内部struct以外的成员变量来分析即可.但是值得注意的是,这里如果我们定义了变量的话,那么就需要考虑空间占用.</p>
<p>其次我们上面讨论的内嵌类型只针对C++,在C中并没有这样的概念,所以在C中,我们需要为内嵌类型分配空间.</p>
]]></content>
      <categories>
        <category>C Language</category>
      </categories>
      <tags>
        <tag>Computer Science</tag>
        <tag>C Language</tag>
      </tags>
  </entry>
  <entry>
    <title>输入和输出(Chapter7)</title>
    <url>/2025/05/26/ANSI-Chapter7/</url>
    <content><![CDATA[<p><a id="orga2619a4"></a></p>
<h2 id="标准输入输出">标准输入输出</h2>
<p>标准的输入设备一般指键盘,而标准的输出设备一般指屏幕.我们一般使用EOF作为判断输入流结束的标志,而符号常数EOF在头文件&lt;stdio.h&gt;中定义,一般而言其值会被设定成-1.在Windows电脑下,我们可以通过Ctrl+Z来输入EOF,而在Linux下,我们可以通过Ctrl+D来输入EOF;特别注意的是Ctrl+Z必须在行首输入,如果使用的是VS,则需要连续输入三次Ctrl+Z才可以发送EOF.</p>
<span id="more"></span>
<p>我们可以通过符号&lt;来实现输入重定向,其可将键盘输入替换为文件输入,如</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">prog &lt;infile //将infile文件的内容作为prog的输入,这里的prog是一个可执行文件</span><br></pre></td></tr></table></figure>
<p>这样的重定向会是prog的输入流来自于infile文件,而不是键盘输入.值得注意的是,虽然我们在命令行中会通过这个操作做输入重定向,但是这并不会被视作命令行参数,因为对于程序而言,从什么来源获得输入流并不重要.
进一步, 我们可以通过管道机制,将一个程序的输出作为另一个程序的输入,如</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">prog1 | prog2 //将prog1的输出作为prog2的输入</span><br></pre></td></tr></table></figure>
<p>相应的,我们可以通过符号&gt;来实现输出重定向,其可以将屏幕输出替换为文件输出,如</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">prog &gt;outfile //将prog的输出重定向到outfile文件中</span><br></pre></td></tr></table></figure>
<p>这样的重定向会将prog的输出流输出到outfile文件中,而不是屏幕输出.</p>
<p>这里我们需要注意的是,这些重定向操作主要是在Unix环境下可行的,如果我们在Windows系统下的cmd中利用&lt;做输入重定向,他是会报错的;所以如果我们需要在Windows系统下进行输入输出重定向,我们需要利用管道操作:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Get-Content infile | .\prog.exe</span><br></pre></td></tr></table></figure>
<p>但是输出重定向可以正常使用.</p>
<p><a id="orge11e183"></a></p>
<h2 id="printf函数">Printf函数</h2>
<p>主要是对于精度和宽度的控制的一些补充,%m.n的形式解释的比较模糊，具体对不同的类型有不同的效果；</p>
<ol type="1">
<li>对字符串类型(字符数组)而言，m用来控制输出的长度，如果长度超过m，则忽略其存在，不然则以右对齐，并做空格补全，n表示控制输出的字符个数，一旦n大于字符长度则完成字符输出即可</li>
<li>对整型数据而言，m用来控制输出长度，如果长度超过m，则忽略其存在，不然则以右对齐，并做空格补全，n则用于控制其输出数字长度，如果n大于其长度，那么会在输出的int左端补0；不然则默认输出。</li>
<li>对浮点型数据而言，n指的是控制输出的小数部分，如果n大于小数部分的长度，那么就四舍五入；反之则在后面补0；在n控制了以后，如果长度超过了m，那么就完整输出；不然就在左侧补空格</li>
</ol>
<p><a id="orgc652375"></a></p>
<h2 id="variable-length-argument-lists">Variable-length argument
lists</h2>
<p>我们通过查看printf的函数声明可以发现,printf的参数列表是一个可变长参数列表,其声明如下:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* format, ...)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这里的…表示可变长参数列表.在C语言中,头文件stdarg.h中定义了一组宏,这些宏可以帮助我们遍历可变长参数列表.</p>
<ol type="1">
<li>va_list类型用于声明一个变量,其将一次引用各参数,一般用ap来记作va_list类型变量,其为argument_
pointer的缩写.</li>
<li>va_start将ap初始化为指向第一个无名参数的参数指针.在使用ap之前,必须先调用va_start.此外,参数列表中必须存在一个有名参数,以便va_start能够找到无名参数列表的起始位置.</li>
<li>va_arg将返回一个参数,并将安排指向下一个参数.va_arg使用一个类型名来决定返回的对象类型,指针移动的步长.</li>
<li>va_end必须在函数返回前调用,其将完成一些必要的清理工作.</li>
</ol>
<p><a id="org6728d5a"></a></p>
<h2 id="scanf-函数">Scanf 函数</h2>
<p>scanf的一些进一步说明：</p>
<ol type="1">
<li>空白字符会使scanf函数在读操作中略去输入中的一个或多个空白字符。空白字符可以是空格，制表符和新行符。非空白符使得scanf函数在读取过程中剔除与这个非空白字符相同的字符。</li>
<li>控制串中的空白符使scanf在输入流中跳过一个或多个空白行。本质上，控制串中的空白符使scanf在输入流中读取，但不保存结果直到遇到第一个非空白字符</li>
<li>如果format写的是“%d,%d”那么输入的时候也要用,作为分隔符；如果没有写，那么就需要用空格或制表符等空白字符。</li>
<li>虽然scanf会忽略空白字符，但是在读取单字符时，其并不会被忽略；并且scanf在读取字符串时，遇到空白字符会中断读取，只记录空白字符以前的，我们可以通过额外设置参数，来使其读取</li>
</ol>
<p>这里有个很好玩的点需要注意,double类型的变量在scanf中的占位符是%lf,而不是%f,因为%f会损失一些精度;但是在printf其占位符可以是%f.
还有一些sscanf之类的,其实只是将scanf的输入流换成了字符串流,其余的操作都是一样的.</p>
<p><a id="orgb8fea54"></a></p>
<h2 id="file-access">File Access</h2>
<p>cat命令用于链接文件并打印到标准输出设备上,其主要作用是用于查看和链接文件内容.我们可以利用输入输出重定向的方式,用其覆盖文件内容,&gt;是输出重定向,会覆盖原文件的内容;&gt;&gt;则是在原有的文件的基础上追加内容.</p>
<p>在读取文件内容之前,需要用fopen函数来打开外部文件,此时返回文件指针,后续会用于读取和写入文件内容.文件指针指向一个结构体,其中包含文件的信息,如缓冲区的位置,缓冲区当前的字符位置,文件是否正在被读取或写入以及是否有错误或到达文件末尾.但这个已经在stdio.h封装完成,用户不需要考虑这些细节.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">FILE* fp=<span class="built_in">fopen</span>(name,mode);</span><br></pre></td></tr></table></figure>
<p>name表示文件路径,且其中需要包含文件名;mode则表示如何使用打开的文件,'r'表示只读,'w'表示只写,'a'表示追加.如果某些系统将文件分为文本文件和二进制文件,那么对于后者的模式我们必须在模式字符串后加上'b',如'wb'表示以二进制方式打开文件进行写操作.值得注意的是,如果我们对于文件采用写或者追加操作,即使文件不存在,系统也会试图创建一个文件.但是写和追加操作的不同在于,写操作会完全覆盖原有文件内容,而追加操作则是在保持原有文件的基础之上在其后追加内容.而我们如果对于文件采用读操作,那么一旦文件不存在,系统就会报错;一旦fopen报错,他的返回值就是NULL.</p>
<p>getc返回文件的下一个字符,其需要输入一个文件指针,用来表明其要读取的文件.如果到文件末尾或者读取文件发生错误,那么其会返回EOF;putc则是getc的反面,其作用则是一个输出函数,将字符c写入到fp指向的文件,并返回写入的
字符.如果发生错误,则返回EOF.值得注意的是,getc和putc并不是函数而是一个宏.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getc</span><span class="params">(FILE *fp)</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">putc</span><span class="params">(<span class="type">int</span> c,FILE *fp)</span></span></span><br></pre></td></tr></table></figure>
<p>当一个C语言程序运行的时候,操作系统会自动打开标准输入,标准输出和标准错误三个文件,并提供相应的三个文件指针stdin,stdout,stderr.这三个文件指针在头文件stdio.h中给出声明.一般而言,stdin对应于键盘,stdout和stderr对应于屏幕;但是stdin和stdout可以通过输入输出重定向或者管道操作来将对应的设备进行修改.</p>
<p>getc和putc提供了从文件读写单个字符的方式,而类似于scanf和printf,我们同样有从文件中格式化读写的函数fscanf和fprinf</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fscanf</span><span class="params">(FILE* fp,<span class="type">char</span>* format,...)</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fprintf</span><span class="params">(FILE* fp,<span class="type">char</span>* format,...)</span></span></span><br></pre></td></tr></table></figure>
<p>其与正常的scanf和printf的区别在于,他需要在第一个参数提供一个指向读写的文件的指针,第二个则是格式串.</p>
<p>最后,我们在完成对文件的操作以后,我们需要用fclose来断开文件指针和外部文件的链接,并释放文件指针以供其他文件使用.这是因为大部分的操作系统其实控制了一个程序最多可以同时打开的文件数.因此如果我们不需要某个文件,应该及时关闭.fclose的另一个作用其实就是会强制将缓冲区中尚未写入磁盘的剩余数据立即刷新到文件中,其可以保证缓冲区数据正确保存.而缓冲区的存在是因为当程序如果频繁调用putc或者fprintf等函数向文件写入数据,如果每次写入操作都要操作磁盘,那么程序运行就会十分低效;因此就需要用缓冲区,数据会先暂存在内存的缓冲区中,当缓冲区被填满时,系统才会直接写入磁盘,这样可以减少磁盘操作的次数,显著提升了程序性能.如果最后没有用fclose,虽然大部分系统执行完程序会自动刷新缓冲区,但一旦出现程序异常终止可能就会有数据泄漏的风险.</p>
<p>如果我们不需要stdin和stdout,实际上也可以用fclose把他们关闭了,如果我们需要可以用freopen函数把他重新打开,一般来是重新打开会把标准输入输出文件重定向为本地文件.</p>
<p><a id="org6eb367c"></a></p>
<h2 id="error-handing">Error Handing</h2>
<p>这里我们需要明确的是,前面所提到的输入输出重定向和管道操作是针对stdout和stdin的,而srderr是独立于stdout的一个文件指针,故其一直指向屏幕.其次,标准库函数exit()也提供了一种终止调用程序的执行方式.任何调用这个程序的参数进程都可以获得exit的参数值.因此可以借此来定位程序的报错位置.一般而言,参数值0表示一切正常,而非0值则表示出现了异常情况.exit的调用会为已经打开的输出文件调用fclose函数,以将缓冲区中的所有输出写入相应的文件.</p>
<p>在shell中运行的每个命令都用了退出状态码,退出状态码一般是一个0~255的整数值,在命令结束的时候会由命令传给shell.
Linux中给出了一个专属变量?来保存上一个执行命令的退出状态码,必须要在查看的命令后马上查看.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo $?</span><br></pre></td></tr></table></figure>
<p>默认状态下,shell会以脚本中的最后一个命令作为退出状态码.exit()其实可以自定义制定shell命令的退出状态码.由于退出状态码的取值范围为0~255,所以如果不在这个范围内,会通过取模运算来使其控制在范围内.</p>
<p>exit函数的优势在于:</p>
<ol type="1">
<li>其可以在其他函数调用,而不仅仅是main函数中调用.</li>
</ol>
<p>exit()是一个库函数,通常定义在stdlib.h.这个函数的主要功能是终止程序的执行并返回一个状态码到调用进程,一般是os或者是shell.由于exit只是一个库函数,因此可以在程序的任何位置,任何函数或方法内部调用,而不仅仅在main,这意味着只要在运行过程中遇到了不可恢复的错误或者某个特定的错误条件,可以立即调用exit来终止程序,不需要用多层函数调用一直返回到main函数.</p>
<ol type="1">
<li>可以用模式查找程序查找这些调用.</li>
</ol>
<p>当我们正在维护或者调试大型程序,可以用模式匹配工具快速定位所有调用exit的位置.这是因为很多情况过早或过晚进行程序终止可能导致了代码的bug.</p>
<p>exit是一个带参数的函数,执行完以后会将控制权交给内核;而return只是一个关键字,其执行完会将控制权交给调用函数而非内核.其次,我们讨论exit()和exit_
()的差异;exit()需要处理一些善后工作后,再将控制权交给内核,而exit_
()则是立即将控制权交给内核.因此exit()其实是exit_()的一个封装,其流程如下所示:</p>
<ol type="1">
<li>exit函数逆序调用通过atexit或者on_exit登记的终止处理程序_;</li>
<li>然后按需多次调用fclose,关闭所有标准I/O流;</li>
<li>删除由tmpfile函数创建的临时文件.</li>
</ol>
<p>完成在用户空间所需要做的事情后,exit()就可以调用exit_()来让内核处理终止进程的剩余工作.</p>
<p>注意的是接下来介绍的函数并不是用来判断文件操作是否出现错误,而是在文件操作已经出现错误的时候用来检查错误的原因和类型.</p>
<p>函数ferror的函数原型为</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ferror</span><span class="params">(FILE* stream)</span></span>;</span><br></pre></td></tr></table></figure>
<p>ferror函数用于判断使用某个文件指针的过程中,是否发生了错误;如果使用过程中没有错误,那么ferror函数返回0;否则,ferror函数将返回一个非零的值.调用ferror函数时,我们只需要将待检查的文件指针传入即可.</p>
<p>函数feof的函数原型为</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">feof</span><span class="params">(FILE* stream)</span></span>;</span><br></pre></td></tr></table></figure>
<p>feof函数判断文件是否读取到文件末尾.如果文件没有到达文件末尾,那么feof函数返回0;否则,feof函数将返回一个非零值.因为feof其实是通过判断fp是否已经读取到了EOF字符,所以我们在调用feof函数之前需要用fgetc函数或者fgets函数读取,然后再判定.</p>
<p><a id="orgcafc95e"></a></p>
<h2 id="line-input-and-output">Line Input and Output</h2>
<p>标准库提供了一个从文件中读取行的函数fgets,其函数原型为</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> *<span class="title">fgets</span><span class="params">(<span class="type">char</span> *line,<span class="type">int</span> maxline,FILE *fp)</span></span></span><br></pre></td></tr></table></figure>
<p>fgets函数从fp指向的文件中读取下一个输入行(包括换行符),将其存放到字符数组line中.输入的maxline表示最多一次性读取maxline-1个字符,这是因为字符串的最后的字符是需要用'\0'占据,因此只能输入maxline-1个字符.通常情况,fgets返回line,如果遇到了文件结尾或者发生了错误,则返回NULL.</p>
<p>输出函数fputs将一个字符串(不需要包含换行符)写入到一个文件中:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fputs</span><span class="params">(<span class="type">char</span> *line,FILE *fp)</span></span></span><br></pre></td></tr></table></figure>
<p>如果发生错误,该函数会返回EOF,否则会返回一个非负值.
与fgets,fputs类似的是,C语言提供了gets和puts两个库函数,但他们只对stdin文件和stdout文件进行操作.需要注意的是,gets函数在读取字符串时将删除结尾的换行符,而puts函数在写入字符串时则会在结尾补上一个换行符.</p>
<p><a id="org30336ed"></a></p>
<h2 id="miscellaneous-functions">Miscellaneous Functions</h2>
<p><a id="orgfdc6cfd"></a></p>
<h3 id="command-execution">Command Execution</h3>
<p>函数system(char*s)执行包含在字符串s的命令,然后继续执行当前程序.而s的内容则很大程度上与使用的操作系统有关.在Unix环境下,有如下demo</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">system</span>(<span class="string">&quot;date&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>会先去执行程序date,其就是在标准输出上输出当天的日期和时间.system函数会返回一个整型的状态值,其值来自于执行的命令并于具体的系统有关.在UNIX系统中其返回exit的状态值.</p>
<p><a id="org324f2b9"></a></p>
<h3 id="存储管理函数">存储管理函数</h3>
<p>malloc函数的函数声明如下所示:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *<span class="title">malloc</span><span class="params">(<span class="type">size_t</span> n)</span></span>;</span><br></pre></td></tr></table></figure>
<p>当分配成功时,其会返回一个无类型指针,该指针指向一个n个字节长度的空闲空间,但是这些空间是没有经过初始化的.我们需要先对无类型指针做一个强类型转换,同时对得到指针指向的空间初始化或者赋值;分配失败则会分配NULL.</p>
<p>calloc函数的函数声明如下所示:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *<span class="title">calloc</span><span class="params">(<span class="type">size_t</span> n,<span class="type">size_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure>
<p>与malloc不同,calloc接受两个参数,第一个表示要被分配的元素个数,第二个表示元素的空间占用大小.所以其实calloc可以视作就是malloc的更为灵活的一个版本,但是与malloc不同的是,calloc分配的空间是会被默认初始化为0的.</p>
<p>realloc函数的函数声明如下所示:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="title">realloc</span><span class="params">(<span class="type">void</span> *ptr,<span class="type">size_t</span> size)</span></span></span><br></pre></td></tr></table></figure>
<p>realloc的作用是重新分配内存空间,在动态分配中十分重要,一般适用于调整之前用malloc或者calloc开辟的空间大小.</p>
<p>参数ptr指向一个需要重新分配的内存块,该内存块是之前由malloc,calloc或者realloc开辟的,也就是其需要可以动态分配的才可以;如果很特殊,我们考虑一个空指针,那么就会重新分配一个新的内存块,函数会返回一个指向他的指针.size为内存块的大小;特殊的情况为如果size=0且ptr非0那么就会释放ptr,并返回空指针.</p>
<p>如果空间分配成功,realloc返回指向新内存块的指针;否则,返回NULL,并且原来的内存块仍然保持不变(并没有释放).值得强调的是,realloc可能会将内存块移动到新地方(如果在原位置没有足够的空间容纳新的大小).如果移动成功,ptr会指向新位置.需要特别注意,旧的ptr指针需要被更新为realloc返回的新地址.如果内存分配失败,realloc返回NULL,而原始的内存块不会被释放.为避免内存泄漏,应该使用一个临时指针来接收realloc的返回值,并检查是否为NULL.</p>
]]></content>
      <categories>
        <category>C Language</category>
      </categories>
      <tags>
        <tag>Computer Science</tag>
        <tag>C Language</tag>
      </tags>
  </entry>
  <entry>
    <title>ANSI-KMP算法</title>
    <url>/2024/08/28/ANSI-KMP/</url>
    <content><![CDATA[<p>在C语言程序设计这本书的第四章中提到了strindex 函数的编写;
其针对的问题是如何在主串(文本串)中找到某种类型的子串,
也就是我们常说的字符串匹配问题. 显然这个方法是存在朴素求解算法的,
在此我们将介绍除朴素求解算法以外的, 另一种优化的匹配算法, 即 KMP 算法和
KMP 算法的两种不同的实现思路.</p>
<span id="more"></span>
<h2 id="暴力搜索法-brute-force">暴力搜索法 (Brute Force)</h2>
<h3 id="算法思想">算法思想</h3>
<p>对于文本串 T 和模式串 P,
从文本串的第一个字符与模式串的第一个字符开始匹配; 如果相等,
那么比较位置同时后移, 比较第二个字符是否匹配, 以此类推;
直到出现模式串结束, 那么输出文本串的位置; 或者出现有一个不匹配的字符,
那么将文本串回退到最早比较的下一个字符, 模式串回退到开始, 重新循环.</p>
<h3 id="算法实现">算法实现</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">strindex</span><span class="params">(<span class="type">char</span>* text,<span class="type">char</span>* pattern)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i,j,k;</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;s[i]!=<span class="string">&#x27;\0&#x27;</span>;i++)<span class="comment">//文本串的循环</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">for</span>(k=i,j=<span class="number">0</span>;pattern[j]!=<span class="string">&#x27;\0&#x27;</span>&amp;&amp;pattern[j]==text[k];j++,k++)</span><br><span class="line">          <span class="comment">//模式串的循环</span></span><br><span class="line">	;</span><br><span class="line">    <span class="keyword">if</span>(j&gt;<span class="number">0</span>&amp;&amp;pattern[j]==<span class="string">&#x27;\0&#x27;</span>)<span class="comment">//判断是否为真正匹配结束</span></span><br><span class="line">      <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="算法分析">算法分析</h3>
<p>我们假设文本串的长度为 <span class="math inline">\(n\)</span>,
模式串的长度为 <span class="math inline">\(m\)</span>.</p>
<p>最坏的情况是类似于文本串为AAAAAAAB, 模式串为AAAB,这样的话,
需要匹配<span class="math inline">\((n-m+1)m\)</span> 次, 时间复杂度为
<span class="math inline">\(O(nm)\)</span>.</p>
<p>最好的情况则是第一次匹配就成功, 那么时间复杂度就是 <span
class="math inline">\(O(m)\)</span>.</p>
<p>如果我们考虑每种情况以等概率的情况出现, 我们可知 BF
算法的平均时间复杂度为 <span class="math inline">\(O(nm)\)</span>.</p>
<h2 id="kmp-算法">KMP 算法</h2>
<p>我们在上面发现对于文本串为AAAAAAAB, 模式串为AAAB的匹配,
每次都是在最后一个字母匹配出错, 然后就要将模式串和文本串同时回退,
重新比较; 这一步会消耗大量的时间, 并且完全没有利用到前面匹配的结果;
因此KMP算法的提出就是为了解决上面提到的问题:
其利用了匹配失败以前的匹配成功的结果, 从而将时间复杂度降到了 <span
class="math inline">\(O(n+m)\)</span>.</p>
<h3 id="kmp-算法的基本思想">KMP 算法的基本思想</h3>
<p>其核心思想就是当出现不匹配的情况,
利用已知匹配的结果避免回退文本串的指针并且尽可能少的回退模式串的指针.</p>
<p>例如, 如果我们匹配到第 j 个字符串出现了字符不匹配现象,
那么我们已知的是 P[0:j-1]=T[i:i+j-1], BF
算法对这个的处理是直接回退文本指针和模式指针, 并不利用这一良好性质. 而
KMP 算法则是需要寻找 P[0:j-1] 的最长相等前后缀,因为已知
P[0:j-1]=T[i:i+j-1]; 假设 P[0:j-1] 的最长相等前后缀长度为
k,那么你就可以通过一个连等式快速得到需要回退的位置, 即
P[0:k-1]=P[j-k:j-1]=T[j-k:j-1]; 如此可知实际上,
即使我们用暴力搜索重新去计算, 只不过是不断地失败,
直到达到上面所说的情况而已.</p>
<h3 id="基于-pmt-的-kmp-算法">基于 PMT 的 KMP 算法</h3>
<p>上面介绍了 KMP 算法的基本思想, 接下来我们就用不同的实现思路去实现 KMP
算法的思想. 首先我们引入 PMT (Partial Match Table, 部分匹配表) 的概念,
其实这个表就是将要介绍的前缀表.</p>
<h4 id="前缀表的定义">前缀表的定义</h4>
<p>前缀表在 KMP 算法中的作用是用来控制模式指针的回退,
其记录的是字符串的最长相等前后缀的长度,
其用于寻找当出现模式串与文本串不匹配的时候,
模式串应该从哪里开始重新匹配.</p>
<p>例如对于文本串 T=aabaacaabaaf, 模式串为 P=aabaaf;
在第一次字符串匹配时, P[5]和T[5]不匹配了, 如果用 BF 算法,
那么我们下一次匹配就是 P[0] 和 T[1] 的比较; 但显然我们通过朴素的思考,
因为 P[0:4]=aabaa 的最长相同前后缀为 aa, 所以利用 KMP
算法的下一次匹配实际上是考虑 P[2] 和 T[5] 的匹配, 显然如此,
匹配速度有很大的提升.</p>
<p>前缀表是记录下标 i 之前 (包括 i)
的字符串中的最长相同前后缀的长度.</p>
<p>对于一个字符串的前缀指的是包含首字符, 但不包含尾字符的字符串; 例如
aabaaf 的前缀集合为 {a,aa,aab,aaba,aabaa}</p>
<p>对于一个字符串的后缀指的是包含尾字符, 但不包含首字符的字符串; 例如
aabaaf的后缀集合为 {f,af,aaf,baaf,abaaf}</p>
<h4 id="前缀表的计算思路及代码实现">前缀表的计算思路及代码实现</h4>
<ol type="1">
<li>引入两个指针 i 和 j; j 用来指示前缀的末尾, i 用来指示后缀的末尾;
换言之, i 会从 0 开始遍历模式串的每一个下标, j 则是用于记录 P[0:i-1]
的最长相等前后缀的长度.</li>
<li>如果模式串的第 i 位和模式串的第 j 位相等, 那么 j++, i++即可</li>
<li>如果模式串的第 i 位和模式串的第 j 位不相等, 那么就要做一个持续回退;
因为已知 P[j]!=P[i], 但是 P[0:j-1]=P[i-j:i-1]; 那么我们可以用 j=pmt[j-1]
来回退到 P[0:j-1] 的最长相等前后缀的后一位; 这一步的依据是首先
P[0:j-1]=P[i-j:i-1], 并且我们假设 k 为 P[0:j-1] 的最长相等前后缀长度,
那么 P[0:k-1]=P[j-k:j-1]=P[i-k:i-1], 如此就可以去比较 P[k] 和 P[i].</li>
<li>更新 pmt 数组</li>
</ol>
<p>代码实现如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">generate_PMT</span><span class="params">(<span class="type">const</span> <span class="built_in">string</span> &amp;pattern,<span class="type">int</span>* pmt)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">    pmt[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;pattern.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(j&gt;<span class="number">0</span>&amp;&amp;pattern[i]!=pattern[j])</span><br><span class="line">            j=pmt[j<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span> (pattern[i]==pattern[j])</span><br><span class="line">            j++;</span><br><span class="line">        pmt[i]=j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>利用前缀表进行 KMP 算法匹配思路</p>
<ol type="1">
<li>设置两个指针 i 和 j; i 用来控制在文本串的移动; j
用来控制在模式串的移动</li>
<li>如果匹配没出错, 那么返回匹配的起点即可</li>
<li>如果匹配出错了, 那么分情况讨论,如果 j=0,
即模式串的第一个字符就与其不匹配, 那么就需要将文本串向后移动一位; 如果 j
不为0, 那么就用 j=pmt[j-1] 去更新匹配成功部分的最长相等前后缀.</li>
<li>输出结果</li>
</ol>
<h4 id="利用前缀表进行-kmp-算法代码实现">利用前缀表进行 KMP
算法代码实现</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">generate_PMT</span><span class="params">(<span class="type">const</span> string &amp;pattern,<span class="type">int</span>* pmt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">    pmt[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;pattern.<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(j&gt;<span class="number">0</span>&amp;&amp;pattern[i]!=pattern[j])</span><br><span class="line">            j=pmt[j<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span> (pattern[i]==pattern[j])</span><br><span class="line">            j++;</span><br><span class="line">        pmt[i]=j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">strindex</span><span class="params">(string text,string pattern)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">  	<span class="keyword">if</span> (text.<span class="built_in">size</span>()==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (pattern.<span class="built_in">size</span>()==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">pmt</span><span class="params">(pattern.size())</span></span>;</span><br><span class="line">    <span class="built_in">generate_PMT</span>(pattern,&amp;pmt[<span class="number">0</span>]);<span class="comment">//&amp;取地址</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;text.<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(j&gt;<span class="number">0</span>&amp;&amp;text[i]!=pattern[j])</span><br><span class="line">            j=pmt[j<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span>(text[i]==pattern[j])</span><br><span class="line">            j++;</span><br><span class="line">        <span class="keyword">if</span>(j==pattern.<span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">return</span> (i-pattern.<span class="built_in">size</span>()+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="用-next-数组实现-kmp-算法">用 next 数组实现 KMP 算法</h4>
<p>我们在此额外介绍前缀表的另一种表示形式, 也就是 next 数组,
在市面上很多算法书更多采用这种. 我们只介绍其中一种 next 数组生成方法,
也就是将前缀表整体右移以后, 在第一个位置补上 -1. 我们给出代码实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">generate_NEXT</span><span class="params">(<span class="type">const</span> string&amp; pattern, <span class="type">int</span>* next)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">-1</span>;</span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; pattern.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(j&gt;=<span class="number">0</span>&amp;&amp;pattern[i<span class="number">-1</span>]!=pattern[j])</span><br><span class="line">			j=next[j];</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">-1</span> || pattern[i<span class="number">-1</span>] == pattern[j])</span><br><span class="line">            next[i] = ++j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">strindex</span><span class="params">(string text,string pattern)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (text.<span class="built_in">size</span>()==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (pattern.<span class="built_in">size</span>()==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">next</span><span class="params">(pattern.size())</span></span>;</span><br><span class="line">    <span class="built_in">generate_NEXT</span>(pattern,&amp;next[<span class="number">0</span>]);<span class="comment">//&amp;取地址</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;text.<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(j&gt;<span class="number">0</span>&amp;&amp;text[i]!=pattern[j])</span><br><span class="line">            j=next[j];</span><br><span class="line">        <span class="keyword">if</span>(j==<span class="number">-1</span>||text[i]==pattern[j])</span><br><span class="line">            j++;</span><br><span class="line">        <span class="keyword">if</span>(j==pattern.<span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">return</span> (i-pattern.<span class="built_in">size</span>()+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="基于-dfa-的-kmp-算法">基于 DFA 的 KMP 算法</h3>
<h4 id="dfa-的定义">DFA 的定义</h4>
<p>自动机分为两类: DFA (确定性有限状态自动机) 和 NFA
(非确定性有限状态自动机), 二者均可用于字符串匹配问题, 我们在此仅使用 DFA
来完成 KMP 算法. 而 NFA 主要用于正则表达式的匹配问题.</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/LYD122504/picx-images-hosting@master/微信图片_20240829160304.6png3qwz50.png"
alt="微信图片_20240829160304" />
<figcaption aria-hidden="true">微信图片_20240829160304</figcaption>
</figure>
<p>由上图知, DFA 由状态 (带数字的圆圈) 和转换 (带模式串字母的箭头) 组成.
从上图知, 由于模式串为 ABABAC 六个字符, 因此 DFA 一共由七个状态,
其中状态 0 表示起始状态, 也就是未开始匹配的状态, 模式 6
为匹配成功的状态. 值得注意的是, 构建的 DFA 是基于模式串进行的,
文本串是一系列输入该 DFA 的参数; 从某种角度来说, 这与我们前面提到的 next
数组类似, 实际上这两个只是不同维度的同一内容而已.</p>
<p>进一步, 我们给出图中涉及的一些专业术语, 在字符串匹配问题上,
每个状态都表示模式串中各个字符串的索引值,
该图中给出了在每个状态下输入不同字符的状态的转换操作,
但实际上这些转换中只有 0-1-2-3-4-5-6 这一条是匹配转换(其实就是从第 i
个状态转换到第 i+1 个状态), 其余的转换操作都需要回退指针,
称之为非匹配转换.</p>
<h4 id="构建-dfa-的思路与算法实现">构建 DFA 的思路与算法实现</h4>
<p>在计算机内部, 我们用二维数组 DFA[char][state] 来表示上面介绍的 DFA,
其中 DFA[i][j] 具体含义是在状态 j 的情况下输入字符 i 之后,
状态转换的结果.</p>
<p>从构建DFA的流程中, 我们知道 DFA 的状态转换只有两种类型:
匹配转换或者非匹配转换.对此分类讨论即可得到构建 DFA 的算法</p>
<p>如果状态转换是匹配转换, 也就是在第 j 个状态下输入的字符是 pattern[j],
那么匹配成功, 我们可以转换到第 j+1 个状态, DFA[pattern[j]][j]=j+1;</p>
<p>假如状态转换是非匹配转换, 也就是在第 j 个状态下输入的字符并不是
pattern[j]. 为了后续讨论简便, 我们用 i 来表示输入的文本串字符位置, 但是
text[i] 不等于 pattern[j]. 此时, 因为出现了匹配失败的情况,
我们需要回退状态, 但是我们尽量要避免和暴力算法一样直接回退到开始,
而是尽可能少的回退, 并且不排除任何可能情况, 这就是 KMP 算法本身的思想.
虽然我们在第 j 个状态下匹配失败, 但是我们已知 Pattern[0~j-1] 和
text[i-j~i-1] 已经完成了匹配. 所以无论如何从 text[i-j]
开始去寻找模式串已经是不可能成立的了, 所以此时我们就可以从
text[i-j+1]开始分析, 如果我们输入的新字符串是 text[i-j+1~i-1],
那么会出现在什么状态? 由于这个新字符串依赖的不仅仅是文本串的内容,
实际上由于 Pattern[0~j-1]=text[i-j~i-1],
我们可以认为输入的新字符串实际上是 Pattern[1~j-1].
所以我们就得到了一系列等价表达, 即如果在第 j 个状态下输入的 text[i]
出现了非匹配转换, 其最终状态等价于输入text[i-j+1~i-1]以后再输入 text[i]
的状态,等价于输入 Pattern[1~j-1] 以后再输入 text[i] 的状态.</p>
<p>此时会发现如果我们要知道第 j 个状态下的非匹配转换结果,
其实我们只需要知道 输入 Pattern[1~j-1] 之后的状态; 由于我们的 DFA
构造是递推的, 所以这个状态的转换结果是已经构造了的,
我们可以直接得到这个结果, 换言之其实是一个 DP 过程. 为了讲解方便,
我们引入一个重启状态的概念, 重启状态就是如果我们在第 j
个状态下出现了非匹配转换, 那么由我们前面的讨论得知, 输入 Pattern[1~j-1]
得到的状态就是第 j 个状态的重启状态, 第 j
个状态的非匹配转换和重启状态的对应字符转换状态一致.</p>
<p>我们给出如下的例子来解释重启状态, 在上面的 DFA 的图中, 如果我们用
ABABAA 来输入这个 DFA 中, 在状态 5 中, 最后输入的字符是 A, 与 C 不匹配,
那么我们就需要去找这个状态的重启装态, 我们已知 Pattern[0~4]=ABABA,
寻找重启状态的话, 我们就需要输入 Pattern[1~4]=BABA, 通过查图,
我们可以发现状态 5 的非匹配转换和状态 3 的一致.</p>
<p>为了解释方便, 我们用重启状态数组来加以解释,
虽然我们在代码中是以数的形式存在, 但这并不影响. X[j+1] 表示输入
Pattern[1~j] 之后再输入 Pattern[j+1] 得到的结果, 但是我们知道输入
Pattern[1~j] 得到的状态其实是 X[j], 所以我们要求的 X[j+1] 实际上是在状态
X[j] 的基础上输入 Pattern[j+1] 的状态, 也就是
X[j+1]=DFA[Pattern[j]][X[j]]. 我们初始化 X[0]=0.</p>
<p>下面给出构建 DFA 的代码,</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">generate_DFA</span><span class="params">(<span class="type">const</span> string&amp; pattern, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;DFA)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DFA[pattern[<span class="number">0</span>]][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> X;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>, X = <span class="number">0</span>; j &lt; pattern.<span class="built_in">size</span>(); j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)<span class="comment">// 256是asc码的长度,需要将字符串内出现的所有可能字符都列入</span></span><br><span class="line">            DFA[i][j] = DFA[i][X];</span><br><span class="line">        DFA[pattern[j]][j] = j + <span class="number">1</span>;</span><br><span class="line">        X = DFA[pattern[j]][X];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实, 在 DFA 中寻找重启状态, 我们用的是 Pattern[1~j-1] 重新输入,
这个其实就是我们在 PMT 中寻找最长相等前后缀的过程, 只是 DFA
将其可视化了而已, 或者说, 我们在前面构造的重启状态数组实际上就是 PMT.
因此这两个办法理论上没有任何区别, 不过 DFA 在空间存储方面消耗更大,
他是一个二维数组.</p>
<h4 id="用-dfa-实现-kmp-的算法实现">用 DFA 实现 KMP 的算法实现</h4>
<p>如果我们已经构造了 DFA 数组, 我们只需要存储对应状态和依次输入文本串到
DFA 即可. 值得注意的是, 循环结束的原因是</p>
<ol type="1">
<li>达到匹配成功状态, 返回文本串匹配成功起点</li>
<li>文本串达到末尾, 也就是匹配失败, 返回 -1</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">generate_DFA</span><span class="params">(<span class="type">const</span> string&amp; pattern, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;DFA)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DFA[pattern[<span class="number">0</span>]][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> X;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>, X = <span class="number">0</span>; j &lt; pattern.<span class="built_in">size</span>(); j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)</span><br><span class="line">            DFA[i][j] = DFA[i][X];</span><br><span class="line">        DFA[pattern[j]][j] = j + <span class="number">1</span>;</span><br><span class="line">        X = DFA[pattern[j]][X];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">strindex</span><span class="params">(string text, string pattern)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> R = <span class="number">256</span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">DFA</span>(R, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(pattern.<span class="built_in">size</span>(), <span class="number">0</span>));</span><br><span class="line">    <span class="built_in">generate_DFA</span>(pattern, DFA);</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; text.<span class="built_in">size</span>() &amp;&amp; j &lt; pattern.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        j = DFA[text[i]][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j == pattern.<span class="built_in">size</span>())</span><br><span class="line">        <span class="keyword">return</span> i - pattern.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="kmp-算法分析">KMP 算法分析</h3>
<p>如果模式串长度为 <span class="math inline">\(m\)</span>, 文本串长度为
<span class="math inline">\(n\)</span>.</p>
<p>空间复杂度显然是 <span class="math inline">\(O(m)\)</span></p>
<p>对于时间复杂度分析, 我们只考虑 PMT 的情况, DFA 完全类似. 由于 PMT
需要求解 PMT 数组/Next 数组和 KMP 搜索两部分代码, 所以我们逐步分析.</p>
<ol type="1">
<li>求解 PMT 数组/ Next 数组; 外层的 for 循环需要迭代 <span
class="math inline">\(m-1\)</span> 次, 但是里面嵌套了一个 while 循环,
如果我们试图直接寻找 while 的循环次数, 虽然可以得到结果,
但是显然不太现实. 我们利用 j 的值的变化来近似分析时间复杂度. j
的变化只有两种情况, 要么加一, 要么 j=pmt[j-1] 减少.
但是减少的程度其实依赖于 j++ 的程度, 而 j++ 和 i++ 都是同时发生的,
所以最多发生 <span class="math inline">\(m-1\)</span> 次,
因此这一步的时间复杂度是 <span class="math inline">\(O(m)\)</span></li>
<li>搜索: for 循环走的次数是 <span class="math inline">\(n-1\)</span>,
while 的回退其实总体来说最多只可能走 <span
class="math inline">\(n-m\)</span> 因此一共复杂度 <span
class="math inline">\(O(n+m)\)</span></li>
</ol>
]]></content>
      <categories>
        <category>C Language</category>
      </categories>
      <tags>
        <tag>Computer Science</tag>
        <tag>C Language</tag>
      </tags>
  </entry>
  <entry>
    <title>ANSI-bit operation</title>
    <url>/2024/12/21/ANSI-bit/</url>
    <content><![CDATA[<h2 id="位运算操作符2.9-bitwise-operators">位运算操作符(2.9 Bitwise
Operators)</h2>
<p>在C语言中提供了六种位运算操作符, 分别为: 按位取与(&amp;),
按位取或(|), 按位取异或(^),
按位左移(<a id="orgc4f59dc"></a>)和按位取反(~).
值得注意的是这些操作符只能用于操作整数的数据类型,不论其是有符号整数还是无符号整数.
进一步, 整数类型的数据类型为 char, short, int 和 long
(根据在计算机内占据的字节多少排序). 至于浮点数,
由于位运算会直接操作二进制位, 因此可能会对浮点数的值造成难以预知的结果,
因此从语法层面直接禁止了对浮点数的位运算操作.</p>
<span id="more"></span>
<p><a id="org3679096"></a></p>
<h3 id="位运算操作符的含义">位运算操作符的含义</h3>
<p><a id="org3717b6c"></a></p>
<h4 id="按位取与">按位取与(&amp;)</h4>
<p>按位取与是将两个操作数的每位二进制互相进行取与操作,
如果两个操作数的对应位都为1, 那么结果的对应位为1, 否则为0. 例如: 1010
&amp; 1100 = 1000. 值得注意的是, 按位取与大部分的用处实际上将某些位取0.
例如, 如果我们希望将某个数n的后7项保持不变, 其他位取0,
那么我们可以用按位取与完成这个操作</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将n的后7位保持不变, 其他位取0</span></span><br><span class="line">  n&amp;<span class="number">0177</span></span><br></pre></td></tr></table></figure>
<p>这里面我们用到了八进制的表示方法, 即以0开头的数字表示八进制数.
所以0177实际上在二进制上就是0000000001111111, 也就是后7位为1, 其他位为0.
因为任意数与0取与都是0,所以我们可以用这个把想要的位置置0.</p>
<p>小结一下, 按位取与的用途主要是将某些位取0, 保留某些位.</p>
<p><a id="orgb8e3afa"></a></p>
<h4 id="按位取或">按位取或(|)</h4>
<p>按位取或是将两个操作数的每位二进制互相进行取或操作,
如果两个操作数的对应位有一个为1, 那么结果的对应位为1, 否则为0. 例如:
1010 | 1100 = 1110. 因此, 按位取或的主要用途是将某些指定位置置1,
并保留其他位置的值不变. 例如, 如果我们希望将某个数的从右数第七位置为1,
其他位保持不变, 那么我们可以用按位取或完成这个操作.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将n的第7位置1, 其他位保持不变</span></span><br><span class="line">  n|<span class="number">0100</span></span><br></pre></td></tr></table></figure>
<p><a id="orga13e48f"></a></p>
<h4 id="按位取异或">按位取异或(^)</h4>
<p>按位取异或是如果两个操作数的对应位取值不同, 那么结果对应位就为1,
反之则为0. 例如, 1010<sup>1100</sup>=0110.</p>
<p><a id="org79b106e"></a></p>
<h4 id="按位左移和按位右移">按位左移(&lt;&lt;)和按位右移(&gt;&gt;)</h4>
<p>按位左移和右移操作是将左操作数的二进制位向左或向右移动右操作数指定的位数.
因此, 右操作数必须是一个非负整数. 例如,
x&lt;&lt;2将x的二进制位整体向左移动两位,
并且在右边补0,这一操作的结果实际上是等价于对x乘4.但是右移操作并不能这么简单的总结,
因为右移操作会导致二进制高位的空缺,
因此如果我们考虑无符号整数的右移操作, 我们将二进制高位补0;
而如果我们考虑的是有符号整数的右移操作,
那就要与具体的底层代码实现有关:有的编译器会以符号位填补高位(算术移位),
有的编译器则会用0填补高位(逻辑移位).</p>
<p><a id="org38c3456"></a></p>
<h4 id="按位取反">按位取反(~)</h4>
<p>与前面的几个操作符不同的是, 按位取反是一元操作符.
按位取反是将操作数的每一位取反, 即0变为1, 1变为0. 例如, ~1010=0101.
我们在按位取与中提到了将n的后几位保持不变, 其余位取0,
在此我们将用按位取与和按位取反来实现, 将n的后七位取0,
其余位保持不变:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将n的后7位取0, 其余位保持不变</span></span><br><span class="line">  n&amp;~<span class="number">0177</span></span><br></pre></td></tr></table></figure>
<p>值得注意的是, 我们当然可以用 x&amp;0177700 来实现这个操作,
但这其实相当于我们假定了x的位数就是16位, 显然这不适合代码的可移植性.</p>
<p><a id="orgca07038"></a></p>
<h3 id="getbits-函数的设计思路与代码">getbits 函数的设计思路与代码</h3>
<p><a id="orgabbca12"></a></p>
<h4 id="getbits-函数功能">getbits 函数功能</h4>
<p>getbits 函数的形式为</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">getbits</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> x,<span class="type">int</span> p,<span class="type">int</span> n)</span></span></span><br></pre></td></tr></table></figure>
<p>返回无条件整数x二进制形式从右边数第p位开始向右数n位的字段对应的unsigned
int形式.
这里我们假设右边的第一位是第0位,n和p是合理的正值,输入错误处理暂时不考虑.</p>
<p><a id="org2be836b"></a></p>
<h4 id="getbits-函数设计思路">getbits 函数设计思路</h4>
<p>因为我们需要从右边数第p位开始向右数n位的字段,所以这个字段最右边其实是第p+1-n位,因此我们需要将这个字段移动到最右边,我们可以用按位右移的方式将其移动到最右端,</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">x&gt;&gt;=(p+<span class="number">1</span>-n);</span><br></pre></td></tr></table></figure>
<p>接下来,我们需要导出最右边的n个字段,也就是相当于保持最右边n位不变,其余位置0即可.从前面的操作符,我们知道,
我们只需要让前面得到的结果和后n位为1, 其余位为0的数按位取与即可.
因此我们关注点就在于如何生成这个后n位为1, 其余位为0;
如果我们考虑将这个数取反, 那么我们只需要去构造后n位为0, 高位为1;
显然这个结果我们可以通过按位左移全1的数得到,所以我们将这个过程转换成代码得到</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> y=~<span class="number">0</span>;</span><br><span class="line">y&lt;&lt;=n;</span><br><span class="line">y=~y;</span><br></pre></td></tr></table></figure>
<p><a id="org6b00caf"></a></p>
<h4 id="getbits-函数代码">getbits 函数代码</h4>
<p>Version 1</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">getbits</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> x,<span class="type">int</span> p,<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  x&gt;&gt;=(p+<span class="number">1</span>-n);</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> y=~<span class="number">0</span>;</span><br><span class="line">  y&lt;&lt;=n;</span><br><span class="line">  y=~y;</span><br><span class="line">  <span class="keyword">return</span> x&amp;y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们用操作符的优先级将上面的代码写的更加简洁得到Version2</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">getbits</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> x,<span class="type">int</span> p,<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (x&gt;&gt;(p+<span class="number">1</span>-n))&amp;(~(~<span class="number">0</span>&lt;&lt;n));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a id="orgc9f19c8"></a></p>
<h3 id="exercise-2-6">Exercise 2-6</h3>
<p>Exercise 2-6. Write a function setbits(x,p,n,y) that returns x with
the n bits that begin at position p set to the rightmost n bits of y,
leaving the other bits unchanged</p>
<p><a id="org44dc5bc"></a></p>
<h4 id="函数设计思路">函数设计思路</h4>
<p>这个函数是要将x的中间一部分字段替换成y最右边的部分字段,
因此我们需要将y最右边的部分字段提取出来,然后向左移动到对应的位置,</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> y1=y&amp;(~(~<span class="number">0</span>&lt;&lt;n));</span><br><span class="line">y1&lt;&lt;=(p+<span class="number">1</span>-n);</span><br></pre></td></tr></table></figure>
<p>值得注意的是, 这里的y1只有中间一段是y最右边的部分字段, 其余为全是0,
然而我们需要用这个来覆盖掉x对应位置的字段, 保持其余位不变.
因此我们可以用按位取或来完成这个操作,
但值得注意的是这里我们是需要将x相应位置的字段置0.
这样我们就可以将x的相应位置的字段被y1覆盖,其余位不变.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这一步是为了生成长为n的全1的字段数,其余数为0</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> x1=((<span class="type">int</span>)<span class="built_in">pow</span>(<span class="number">2</span>,n) - <span class="number">1</span>);</span><br><span class="line"><span class="comment">//左移p+1-n位,将其移动到对应的位置</span></span><br><span class="line">x1&lt;&lt;=(p+<span class="number">1</span>-n);</span><br><span class="line"><span class="comment">//x1此时是对应位置全1,其余位置为0,我们将其取反,得到对应位置全0,其余位置全1</span></span><br><span class="line">x1=~x1;</span><br><span class="line"><span class="comment">//最后我们将x相应的字段置0,其余位置保持不变</span></span><br><span class="line">x&amp;=x1;</span><br></pre></td></tr></table></figure>
<p><a id="orgf37ae72"></a></p>
<h4 id="代码实现">代码实现</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">unsigned</span> <span class="title">setbits</span><span class="params">(<span class="type">unsigned</span> x, <span class="type">int</span> p, <span class="type">int</span> n, <span class="type">unsigned</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((y &amp; ~(~<span class="number">0</span> &lt;&lt; n)) &lt;&lt; (p + <span class="number">1</span> - n)) | (x &amp; ~(((<span class="type">int</span>)<span class="built_in">pow</span>(<span class="number">2</span>,n) - <span class="number">1</span>) &lt;&lt; (p + <span class="number">1</span> - n)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a id="orgf03d9a9"></a></p>
<h3 id="exercise-2-7">Exercise 2-7</h3>
<p>Write a function invert(x,p,n) that returns x with the n bits that
begin at position p inverted (i.e., 1 changed into 0 and vice versa),
leaving the others unchanged</p>
<p><a id="org8c4a098"></a></p>
<h4 id="函数设计思路-1">函数设计思路</h4>
<p>我们的思路其实就是先将x的指定字段提取出来,
然后只对这一部分取反,再重新取代x相应位置的字段即可. 第一步,
提取x的指定字段, 我们已在getbits函数给出了; 接下来,
我们假设取出来的字段为y, 接下来我们需要对y的字段取反,
但是值得注意的是我们不能将y的高位取反, 换言之,
我们只改变y的右边n位二进制的值, 我们用按位取异或的方式来处理.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">y=y^((<span class="type">int</span>)<span class="built_in">pow</span>(<span class="number">2</span>,n)<span class="number">-1</span>);</span><br></pre></td></tr></table></figure>
<p>最后我们就回归了2-6的问题.</p>
<p><a id="orgcf6e4ac"></a></p>
<h4 id="代码实现-1">代码实现</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">invert</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> x, <span class="type">int</span> p, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//将x的指定字段提取出来</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> temp=(x&gt;&gt;(p+<span class="number">1</span>-n))&amp;~(~<span class="number">0</span>&lt;&lt;n);</span><br><span class="line">  <span class="comment">//将temp最右边n位数取反</span></span><br><span class="line">  temp^=((<span class="type">int</span>)<span class="built_in">pow</span>(<span class="number">2</span>,n)<span class="number">-1</span>);</span><br><span class="line">  <span class="comment">//将temp重新取代x相应位置的字段</span></span><br><span class="line">  <span class="keyword">return</span> (temp&lt;&lt;(p+<span class="number">1</span>-n))|(x&amp;~(((<span class="type">int</span>)<span class="built_in">pow</span>(<span class="number">2</span>,n)<span class="number">-1</span>)&lt;&lt;(p+<span class="number">1</span>-n)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a id="org14e5e12"></a></p>
<h3 id="exercise-2-8">Exercise 2-8</h3>
<p>Write a function rightrot(x,n) that returns the value of the integer
x rotated to the right by n positions.</p>
<p><a id="org59a3af6"></a></p>
<h4 id="函数设计思路-2">函数设计思路</h4>
<p>两个思路：</p>
<ol type="1">
<li>用循环的方式, 每次我们都将x的最右边的一位取出来，然后将x右移一位,
将取出来的位放到最左边, 重复n次即可.
因为这些技术细节其实都在前面解释过了, 这里我们就不去解释了.</li>
<li>这一种则是,我直接一次性将x的最右边n位取出来, 然后将x右移n位,
将取出来的n位放到最左边即可.</li>
</ol>
<p>但是这两个方法有一个问题,就是我们必须知道x本身在计算机占用的位数,
不然的话, 我们没法移动到合适的位置.
但我们可以通过按位右移的方式来解决这个问题, 假设x占用了4个二进制位,
我们将其按位右移四次, 那么x就变成了0, 因此我们就得到了x的位数</p>
<p><a id="org4b1e24e"></a></p>
<h4 id="代码实现-2">代码实现</h4>
<p>思路一</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">unsigned</span> <span class="title">rightrot</span><span class="params">(<span class="type">unsigned</span> x, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="type">int</span> length = <span class="built_in">len</span>(x);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="type">unsigned</span> temp = (x &amp; <span class="number">1</span>) &lt;&lt; (length - <span class="number">1</span>);</span><br><span class="line">                x = (x&gt;&gt;<span class="number">1</span>) | temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>思路二</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">unsigned</span> <span class="title">rightrot</span><span class="params">(<span class="type">unsigned</span> x, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="type">int</span> length = <span class="built_in">len</span>(x);</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> temp=x&amp;~(~<span class="number">0</span>&lt;&lt;n);</span><br><span class="line">        x=x&gt;&gt;n;</span><br><span class="line">        temp=temp&lt;&lt;(length-n);</span><br><span class="line">        x=x|temp;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获得x的位数的函数程序</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">len</span><span class="params">(<span class="type">unsigned</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; x != <span class="number">0</span>; x &gt;&gt;=<span class="number">1</span>)i++;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a id="org86951dd"></a></p>
]]></content>
      <categories>
        <category>C Language</category>
      </categories>
      <tags>
        <tag>Computer Science</tag>
        <tag>C Language</tag>
      </tags>
  </entry>
  <entry>
    <title>ANSI-Reverse Polish Calculator</title>
    <url>/2024/12/30/ANSI-cacul/</url>
    <content><![CDATA[<h2
id="逆波兰表达式计算器代码chapter4">逆波兰表达式计算器代码(Chapter4)</h2>
<p><a id="org3f3d92b"></a></p>
<h3 id="逆波兰表达式">逆波兰表达式</h3>
<p>我们使用最为频繁的计算表达式其实是中缀表达式,
也就是操作符在两个操作数之间. 这个的缺点在于,
加减乘除的优先级并不是简单的从左到右计算的, 而是存在一定的优先级.
因此如果我们想要得到想要的结果, 就必须使用括号来辅助我们的计算,
而括号的嵌套则会使计算的复杂度大幅增加. 所以, 我们引入逆波兰表达式,
也就是所谓的后缀表达式, 其特点在于将操作符直接置于操作数之后.
其具体的用法如, <span class="math inline">\((3-4)*5\)</span>
的逆波兰表达式为 <span class="math inline">\(3\ 4\ -\ 5\ *\)</span>;
<span class="math inline">\(3-4*5\)</span> 的逆波兰表达式为 <span
class="math inline">\(3\ 4\ 5\ *\ -\)</span>. 逆波兰表达式的优点在于,
他不需要括号, 也不需要考虑优先级, 只需要按照顺序进行计算即可.</p>
<span id="more"></span>
<p><a id="org00a5db2"></a></p>
<h3 id="计算器的设计思路">计算器的设计思路</h3>
<p>我们基于前面提到的逆波兰表达式的思想,
我们发现这个流程其实是符合后进先出的原则,
因此我们采用栈的数据结构来实现这个计算器. 具体思路如下:
我们每次从输入缓冲区中读取一个字符, 如果是数字, 那么我们就将其压到栈里;
如果是操作符, 暂时我们只考虑二元操作符,
那么我们就从栈顶弹出两个数进行计算, 如果操作数不够, 就弹出异常报错,
最后我们将计算的结果重新压入栈中. 如果我们在此过程中读取到了结束符,
弹出栈顶元素后, 检查栈是否为空, 如果为空, 那么我们就得到了计算结果,
如果不为空, 那么我们就得到了异常报错.</p>
<p><a id="org4ea7795"></a></p>
<h3 id="模块实现">模块实现</h3>
<p>我们将上述过程分成三个大模块和一个主函数, 分别是: getop, getch,
stack.</p>
<p><a id="orgc9f8cf7"></a></p>
<h4 id="stack模块栈操作模块">stack模块(栈操作模块)</h4>
<p>栈从修改的角度来说, 只有两种操作, 一种是压栈(push),
另一个则是弹栈(pop). 我们在此用数组的形式来实现栈,
我们设置一个指标pos作为标注下一个空闲栈的位置.
显然我们的push和pop操作都需要操作栈空间和栈指标,
因此我们在定义栈和指标的时候, 我们需要将其定义为全局变量.
代码如下所示</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXVAL 100<span class="comment">// maximum depth of val stack</span></span></span><br><span class="line"><span class="type">int</span> sp = <span class="number">0</span>; <span class="comment">// new free stack position</span></span><br><span class="line"><span class="type">double</span> val[MAXVAL]; <span class="comment">// value stack</span></span><br><span class="line"><span class="comment">// pop: pop and return top value from stack</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (sp)</span><br><span class="line">    <span class="keyword">return</span> val[--sp];</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;ERROR: empty stack.\n&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// push: push f onto value stack</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">double</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (sp &lt; MAXVAL)</span><br><span class="line">    val[sp++] = v;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ERROR: stack full, can not push %g\n&quot;</span>, v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里, 其实我们可以进一步要求sp和val是静态的,
也就是只能在本文件中使用, 这样的话, 会使代码更加安全.</p>
<p><a id="orgc676a68"></a></p>
<h4 id="getop模块获取操作数符模块">getop模块(获取操作数/符模块)</h4>
<p>这里我们需要考虑的是, 一个操作数可能是多位数, 也可能是小数; 至于负数,
我们可以用0-x的形式来表示. 其流程如下:
首先我们需要先跳过操作数/符之前的空格或制表符, 然后我们读取一个字符,
判断是不是数字, 如果不是数字部分,我们就将其返回; 如果是数字部分,
那我们将其收集起来并继续读取,
直到一个非数字的字符出现,在此我们又要判断是否是小数点, 如果是小数点,
也就是我们接下来读取小数部分; 反之则是已经读取结束. 值得注意的是,
我们在读取这些的过程经常会出现, 读取了一个字符, 以后发现不是我们想要的,
这时我们需要将其放回缓冲区(我们将会在后面的模块设置),
并不可以直接丢弃.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getop</span><span class="params">(<span class="type">char</span> s[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> i, c;</span><br><span class="line">  <span class="keyword">while</span> ((s[<span class="number">0</span>] = c = <span class="built_in">getch</span>()) == <span class="string">&#x27; &#x27;</span> || c == <span class="string">&#x27;\t&#x27;</span>)</span><br><span class="line">    ;</span><br><span class="line">  s[<span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">isdigit</span>(c) &amp;&amp; c != <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> c; <span class="comment">/* not a number */</span></span><br><span class="line">  i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">isdigit</span>(c)) <span class="comment">/* collect integer part */</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(s[++i] = c = <span class="built_in">getch</span>()))</span><br><span class="line">      ;</span><br><span class="line">  <span class="keyword">if</span> (c == <span class="string">&#x27;.&#x27;</span>) <span class="comment">/* collect fraction part */</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(s[++i] = c = <span class="built_in">getch</span>()))</span><br><span class="line">      ;</span><br><span class="line">  s[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">  <span class="keyword">if</span> (c != EOF)</span><br><span class="line">    <span class="built_in">ungetch</span>(c);</span><br><span class="line">  <span class="keyword">return</span> NUMBER;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a id="orgb9de190"></a></p>
<h4 id="getch模块获取字符模块">getch模块(获取字符模块)</h4>
<p>这个模块的作用是从输入缓冲区中读取一个字符, 并返回.
但是我们在这里需要考虑的是, 有时候我们读取了一个字符,
发现不是我们想要的, 那么我们就需要将其放回缓冲区, 以便下次读取.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFSIZE 100</span></span><br><span class="line"><span class="type">char</span> buf[BUFSIZE]; <span class="comment">/* buffer for ungetch */</span></span><br><span class="line"><span class="type">int</span> bufp = <span class="number">0</span>; <span class="comment">/* next free position in buf */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getch</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">/* get a (possibly pushed-back) character */</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">  <span class="keyword">if</span> (buf[bufp - <span class="number">1</span>] == EOF)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;EOF!&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> (bufp &gt; <span class="number">0</span>) ? buf[--bufp] : <span class="built_in">getchar</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ungetch</span><span class="params">(<span class="type">int</span> c)</span> <span class="comment">/* push character back on input */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (bufp &gt;= BUFSIZE)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ungetch: too many characters\n&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    buf[bufp++] = c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a id="org9564f38"></a></p>
<h3 id="主函数">主函数</h3>
<p>在主函数其实我们只需要不断调用getop函数,
并根据返回值的不同来进行不同的操作即可.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;calc.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXOP 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLINE 1000 <span class="comment">// length of a maximum line to be read</span></span></span><br><span class="line"><span class="comment">//reverse Polish calculator</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> type;</span><br><span class="line">    <span class="type">double</span> op2=<span class="number">0.0</span>;</span><br><span class="line">    <span class="type">char</span> s[MAXOP];</span><br><span class="line">    <span class="keyword">while</span> ((type = <span class="built_in">getop</span>(s)) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (type)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> NUMBER:</span><br><span class="line">            v = <span class="built_in">atof</span>(s);</span><br><span class="line">            <span class="built_in">push</span>(v);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">            <span class="built_in">push</span>(<span class="built_in">pop</span>() + <span class="built_in">pop</span>());</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">            <span class="built_in">push</span>(<span class="built_in">pop</span>() * <span class="built_in">pop</span>());</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">            op2 = <span class="built_in">pop</span>();</span><br><span class="line">            <span class="built_in">push</span>(<span class="built_in">pop</span>() - op2);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">            op2 = <span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (op2)</span><br><span class="line">                <span class="built_in">push</span>(<span class="built_in">pop</span>() / op2);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;ERROR: zero divisior.\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;\n&#x27;</span>:</span><br><span class="line">            op2 = <span class="built_in">pop</span>();</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\t%.8g\n&quot;</span>, op2);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ERROR: unknown command %s\n&quot;</span>, s);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里注意的是, 我们的减法和除法是有顺序的,
也就是我们需要先存储下第一个操作数,等第二个操作数弹出, 再操作,
这样才能保证我们的计算是正确的.</p>
<p><a id="org0165295"></a></p>
<h3 id="头文件">头文件</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//计算器头文件,用于声明需要的函数</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NUMBER <span class="string">&#x27;0&#x27;</span></span></span><br><span class="line"><span class="comment">// 缓冲区的输入操作</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getch</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ungetch</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="comment">//getop 输入字符串</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getop</span><span class="params">(<span class="type">char</span> s[])</span></span>;</span><br><span class="line"><span class="comment">//栈操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">double</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">pop</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p><a id="org13a1856"></a></p>
<h3 id="多文件编译过程">多文件编译过程</h3>
<p>C/C++ 程序执行流程其实是先将源文件编译成中间代码文件,
在windows下是.obj文件, 在linux下是.o文件,
然后再将这些文件链接成可执行文件. 举个例子,
我们如果对上面的代码编译,那么我们需要先对这些文件进行编译,也就是</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -c stack.c</span><br><span class="line">gcc -c getch.c</span><br><span class="line">gcc -c getop.c</span><br><span class="line">gcc -c main.c</span><br></pre></td></tr></table></figure>
<p>此时,我们会得到四个中间文件, 分别是stack.o, getch.o, getop.o, main.o.
然后我们再将这些文件链接成可执行文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -o calc stack.o getch.o getop.o main.o</span><br></pre></td></tr></table></figure>
<p>但是很显然如此操作, 如果我们修改了一个文件,
我们就要重新走一遍这个流程, 这样的效率是很低的.
因此我们可以使用makefile来自动化这个过程.
我们先给出一个上面的makefile文件的版本</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment">#version1</span></span><br><span class="line"><span class="comment">#在这个makefile中，目标文件（target）包含：执行文件edit和中间目标文件（*.o），依赖文件（prerequisites）就是冒号后面的那些 .c 文件和 .h文件。每一个 .o 文件都有一组依赖文件，而这些 .o 文件又是执行文件 edit 的依赖文件。依赖关系的实质上就是说明了目标文件是由哪些文件生成的，换言之，目标文件是哪些文件更新的</span></span><br><span class="line"><span class="comment">#在定义好依赖关系后，后续的那一行定义了如何生成目标文件的操作系统命令，一定要以一个tab键作为开头。make并不管命令是怎么工作的，他只管执行所定义的命令。make会比较targets文件和prerequisites文件的修改日期，如果prerequisites文件的日期要比targets文件的日期要新，或者target不存在的话，那么，make就会执行后续定义的命令。</span></span><br><span class="line"><span class="comment">#执行命令一定是以一个tab键作为开头的</span></span><br><span class="line"><span class="section">maincc:main.o getch.o getop.o stack.o</span></span><br><span class="line">g++ main.o getch.o getop.o stack.o -o maincc    <span class="comment">#用g++把中间文件链接编译成可执行文件,并且用-o将其命名为maincc</span></span><br><span class="line"><span class="comment">#这一步是告知计算机main.o文件的生成需要用到main.cpp文件</span></span><br><span class="line"><span class="section">main.o:main.cpp</span></span><br><span class="line">g++ -c main.cpp    <span class="comment">#用g++来将cpp文件编译成.o文件</span></span><br><span class="line"><span class="section">getop.o:getop.cpp</span></span><br><span class="line">g++ -c getop.cpp</span><br><span class="line"><span class="section">stack.o:stack.cpp</span></span><br><span class="line">g++ -c stack.cpp</span><br><span class="line"><span class="section">getch.o:getch.cpp</span></span><br><span class="line">g++ -c getch.cpp</span><br><span class="line"><span class="section">clean: </span></span><br><span class="line">rm -f main.o getch.o getop.o stack.o</span><br></pre></td></tr></table></figure>
<p>如果我们新增了一个文件, 那么我们需要在这个makefile文件里,
两处地方添加文件依赖,
可能会出现漏加的情况,因此我们引入一个变量来避免这个问题.</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment">#version 2</span></span><br><span class="line"><span class="comment">#由于版本1中,如果我们需要增加一个新的.o文件就需要手动修改三个地方,这在多任务下可能出现遗忘,因此引入makefile的变量即可</span></span><br><span class="line">objects=main.o getch.o getop.o stack.o</span><br><span class="line"><span class="section">maincc: <span class="variable">$(objects)</span></span></span><br><span class="line">g++ <span class="variable">$(objects)</span> -o maincc</span><br><span class="line"><span class="section">main.o:main.cpp</span></span><br><span class="line">g++ -c main.cpp    <span class="comment">#用g++来将cpp文件编译成.o文件</span></span><br><span class="line"><span class="section">getop.o:getop.cpp</span></span><br><span class="line">g++ -c getop.cpp</span><br><span class="line"><span class="section">stack.o:stack.cpp</span></span><br><span class="line">g++ -c stack.cpp</span><br><span class="line"><span class="section">getch.o:getch.cpp</span></span><br><span class="line">g++ -c getch.cpp</span><br><span class="line">.PHONY : clean</span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">-rm maincc  *.o</span><br></pre></td></tr></table></figure>
<p>这样, 我们只需要修改objects变量和下面的编译指令即可. 不过在此之前,
我们先解释一下最后的部分, 最后的部分作用其实就是删除中间文件和执行文件,
这可以保证我们文件干净. 这个-rm指的是如果有些文件不存在,
那就别管他继续往后删. .PHONY指的是clean是一个伪目标,
也就是不是一个文件.</p>
<p>事实上,
我们还可以进一步简化这个makefile文件,利用makefile的自动推导规则,
也就是makefile会自动推导出.o文件是由.cpp文件生成的,
因此我们可以将上面的makefile文件简化为</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment">#事实上,我们还可以对上面的版本进行简化,GNU下的make命令可以自动推导文件以及文件依赖关系后面的命令，于是我们就没必要去在每一个[.o]文件后都写上类似的命令，因为，我们的make会自动识别，并自己推导命令。</span></span><br><span class="line">objects=main.o getch.o getop.o stack.o</span><br><span class="line"><span class="section">maincc: <span class="variable">$(objects)</span></span></span><br><span class="line">    g++ <span class="variable">$(objects)</span> -o maincc</span><br><span class="line"><span class="section">main.o:main.cpp</span></span><br><span class="line"><span class="section">getop.o:getop.cpp</span></span><br><span class="line"><span class="section">stack.o:stack.cpp</span></span><br><span class="line"><span class="section">getch.o:getch.cpp</span></span><br><span class="line">.PHONY clean: </span><br><span class="line">    rm -f  *.o</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C Language</category>
      </categories>
      <tags>
        <tag>Computer Science</tag>
        <tag>C Language</tag>
      </tags>
  </entry>
  <entry>
    <title>ANSI-complicated</title>
    <url>/2025/01/21/ANSI-complicated/</url>
    <content><![CDATA[<h2 id="复杂声明chapter-5">复杂声明(Chapter 5)</h2>
<p>由于C语言设计指针的声明需要嵌套大量的括号且并不能简单的从左到右阅读,
因此给定一个复杂的声明, 我们极难快速分析出其含义. 在此,
我们需要写一个程序用来实现将C语言的复杂声明转换为文本,
同理还有一个将文本转为声明的程序.</p>
<span id="more"></span>
<h3 id="设计思路">设计思路</h3>
<p>我们将声明符分为两类,一类是dcl,其主要是前面会带有可选的*号的direct-dcl,其主要用来处理指针类型;第二类则是direct-dcl,其主要是如name,(dcl),direct-dcl(),direct-dcl[]的类型.很显然无论声明是什么形式,我们都可以将其视作dcl的形式,因此我们只需要设计两个函数dcl和dirdcl即可.</p>
<p>在设计dcl和dirdcl函数之前,我们需要先设计一个用来读取输入类型的函数gettoken,其作用不仅仅是读取下一个输入流的输入,更是识别下一个输入的符号类型,并返回其类型.大体我们可以将记号类型分为如下几种:NAME,PARENS,可能包含数字的BRACKETS,以及其他任意单个字符.这里我们逐一分析输入情况,首先我们需要跳过初始输入的空格和制表符;其次如果我们接收到左括号,那么如果紧接着右括号,那么我们就返回PARENS,否则代表了左括号后面还有内容,因此我们需要将已读取的字符重新压入缓冲区,并返回左括号.如果我们接受到的是左方括号,那么其后面只可能跟进数字,无所谓内部内容,我们只需要通过循环找到右方括号即可,并返回BRACKETS;如果我们接收到的是字母,那么我们是在读取一个名称,为了简便起见,我们忽略变量名中出现下划线的情况,因此我们只需要判断后续字符是否是字母或者数字,直到遇到第一个非数字或字母的字符,我们将其压回缓冲区,并返回NAME;最后,如果我们接收到的是其他字符,那么我们直接返回该字符.</p>
<p>在设计完输入类型读取函数之后,我们开始设计dcl函数,首先由我们前面的dcl类型的声明定义可知,我们的dcl函数只去处理指针类型的声明,因此我们需要统计*的个数并且在出现第一个非*字符时表明我们进入了dirdcl类型之中;值得注意的是,我们在函数栈弹出回到dcl过程中的时候,因为一个*就代表了一个指针形式,因此我们需要循环添加pointer
to语句.</p>
<p>对于dirdcl函数而言,如果输入标签为左括号,那么后续跟进的一定是dcl,值得注意的是,这样返回到dirdcl函数中的时候,我们需要进一步判断是否出现右括号,如果没有,则报错;如果输入标签为NAME,那么我们只需要输出这个名字即可;如果不是这两个形式的开头那么就需要报错.其次我们就要考虑后缀括号或方括号的情况:如果是括号,那么表示这是一个函数,我们只需要输出函数的形式即可;如果是方括号,那么表示这是一个数组,我们只需要输出数组的形式即可.</p>
<h3 id="代码实现">代码实现</h3>
<p>main函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFSIZE 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXTOKEN 100</span></span><br><span class="line"><span class="keyword">enum</span> &#123;NAME,PARENS,BRACKETS&#125;;</span><br><span class="line"><span class="type">char</span> buf[BUFSIZE];<span class="comment">//缓冲区</span></span><br><span class="line"><span class="type">int</span> bufp = <span class="number">0</span>;<span class="comment">//缓冲区空闲的后一位</span></span><br><span class="line"><span class="type">int</span> tokentype;<span class="comment">//最后一个字符的类型: 类型名NAME，括号PARENS，方括号BRACKETS</span></span><br><span class="line"><span class="type">char</span> token[MAXTOKEN];<span class="comment">// 最后一个token的字符串</span></span><br><span class="line"><span class="type">char</span> name[MAXTOKEN];<span class="comment">// 声明的变量名</span></span><br><span class="line"><span class="type">char</span> datatype[MAXTOKEN]; <span class="comment">// 声明的类型名</span></span><br><span class="line"><span class="type">char</span> out[<span class="number">1000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getch</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ungetch</span><span class="params">(<span class="type">int</span> c)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gettoken</span><span class="params">(<span class="type">void</span>)</span></span>;<span class="comment">//用来读取下一个字符</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dcl</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dirdcl</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//读取输入</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">gettoken</span>() != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//第一个输入一定是类型名</span></span><br><span class="line">        <span class="built_in">strcpy</span>(datatype, token);</span><br><span class="line">        out[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="built_in">dcl</span>();</span><br><span class="line">        <span class="keyword">if</span> (tokentype != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;syntax error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s: %s %s\n&quot;</span>, name, out, datatype);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>getch and ungetch(读取缓冲区与压入缓冲区)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getch</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (bufp &gt; <span class="number">0</span>) ? buf[--bufp] : <span class="built_in">getchar</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ungetch</span><span class="params">(<span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bufp &gt;= BUFSIZE)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ungetch: too many characters.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        buf[bufp++] = c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>dcl和dirdcl函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//dcl的用处是处理指针符号</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dcl</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> np;</span><br><span class="line">    <span class="keyword">for</span> (np = <span class="number">0</span>; <span class="built_in">gettoken</span>() == <span class="string">&#x27;*&#x27;</span>; np++);</span><br><span class="line">    <span class="built_in">dirdcl</span>();</span><br><span class="line">    <span class="keyword">while</span> (np--)</span><br><span class="line">        <span class="built_in">strcat</span>(out, <span class="string">&quot; pointer to&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//dirdcl处理的是类型名dirdcl()/dirdcl[]，圆括号(dcl)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dirdcl</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> type;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tokentype == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">dcl</span>();</span><br><span class="line">        <span class="keyword">if</span> (tokentype != <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;error: missing )\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (tokentype == NAME)<span class="comment">//变量名</span></span><br><span class="line">        <span class="built_in">strcpy</span>(name, token);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error: expected name or (dcl)\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> ((type = <span class="built_in">gettoken</span>()) == PARENS || type == BRACKETS)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (type == PARENS)</span><br><span class="line">            <span class="built_in">strcat</span>(out, <span class="string">&quot; function returning&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">strcat</span>(out, <span class="string">&quot; array&quot;</span>);</span><br><span class="line">            <span class="built_in">strcat</span>(out, token);</span><br><span class="line">            <span class="built_in">strcat</span>(out, <span class="string">&quot; of&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>gettoken函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gettoken</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">    <span class="type">char</span>* p = token;</span><br><span class="line">    <span class="comment">//处理空格</span></span><br><span class="line">    <span class="keyword">while</span> ((c = <span class="built_in">getch</span>()) == <span class="string">&#x27; &#x27;</span> || c == <span class="string">&#x27;\t&#x27;</span>);</span><br><span class="line">    <span class="comment">//处理括号	</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//完整括号</span></span><br><span class="line">        <span class="keyword">if</span> ((c = <span class="built_in">getch</span>()) == <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">strcpy</span>(token, <span class="string">&quot;()&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> tokentype = PARENS;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//括号里有内容</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">ungetch</span>(c);</span><br><span class="line">            <span class="keyword">return</span> tokentype = <span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//处理方括号</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (; (*p++ = c) != <span class="string">&#x27;]&#x27;</span>; c = <span class="built_in">getch</span>());</span><br><span class="line">        *p = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> tokentype = BRACKETS;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//处理类型名和变量名</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">isalpha</span>(c))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (*p++ = c; <span class="built_in">isalnum</span>(c = <span class="built_in">getch</span>());)</span><br><span class="line">            *p++ = c;</span><br><span class="line">        <span class="built_in">ungetch</span>(c);</span><br><span class="line">        *p = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> tokentype = NAME;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> tokentype = c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="exercise-5-18">Exercise 5-18</h3>
<p>Make dcl recover from input errors.</p>
<p>这里给的解决办法就是如果出现问题,我们就跳转到行末,然后设置一个标志位,再下一次输入修正错误.因此我们只需要补一个错误设置函数即可.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_false</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">    <span class="keyword">if</span> (tokentype != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        <span class="keyword">while</span> ((c = <span class="built_in">getch</span>()) != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">            ;</span><br><span class="line">    tokentype = <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    flag = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C Language</category>
      </categories>
      <tags>
        <tag>Computer Science</tag>
        <tag>C Language</tag>
      </tags>
  </entry>
  <entry>
    <title>ANSI-gcc.md</title>
    <url>/2025/06/07/ANSI-gcc/</url>
    <content><![CDATA[<h2 id="gccg-compiler-options">Gcc/G++ compiler options</h2>
<p>所谓程序的重定向,其实这里的程序并不是指C语言的源码程序,而是经过gcc编译器编译后的可执行文件.我们比较常用的gcc编译命令为</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc prog.c -o exec</span><br></pre></td></tr></table></figure>
<p>这里的prog.c表示C语言的源码文件,而-o
exec表示将编译后的可执行文件命名为exec.如果我们不去指定-o选项,那么gcc编译器会默认将编译后的可执行文件命名为a.out.</p>
<p>虽然我们只用了一条命令就完成了程序的编译,但实际上编译过程其实是分为四个阶段进行的,即预处理(Preprocessing),编译(Compilation),汇编(Assembly)和链接(Linking).</p>
<span id="more"></span>
<p><a id="orgcc1cd4b"></a></p>
<h3 id="预处理preprocessing">预处理(Preprocessing)</h3>
<p>预处理阶段的主要任务如下:</p>
<ol type="1">
<li>头文件展开:
处理#include指令,把所需要的头文件内容插入到当前位置.</li>
<li>宏定义替换: 替换所有宏定义(#define)为其定义的内容.</li>
<li>处理条件编译:
根据#if,#ifdef,#ifndef,#else,#elif和#endif指令,来决定程序中哪些代码需要保留;这些编译条件可以用来控制程序运行平台的差异以及调试程序功能.</li>
<li>删除注释: 所有注释会被移除,便于后续编译.</li>
<li>插入行号信息:
插入#line指令,用于记录原始文件位置,便于后续错误定位.</li>
</ol>
<p>预处理阶段的shell命令如下所示,</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -E prog.c</span><br><span class="line">gcc -E prog.c -o prog.i</span><br></pre></td></tr></table></figure>
<p>gcc并不保留预处理后的文件,但是我们可以通过-E选项来让程序在预处理阶段完成以后停止编译,并且保留预处理信息.如果我们只使用-E选项,那么gcc会将预处理后的结果输出到标准输出上(也就是显示器),但是他会报一个错误,when
writing output to : No such file or
directory.这是因为gcc默认会将预处理的结果输出到一个文件里面,但我们并没有指定输出文件.故我们可以在-E之后再加上-o选项,来指定输出文件的名称,这样gcc就会将预处理的结果输出到指定的文件,而非标准输出.值得注意的是,预处理的结果文件后缀名没有强制标准,但为了便于区分,一般我们会使用.i作为后缀名.</p>
<p><a id="org722cc17"></a></p>
<h3 id="编译compilation">编译(Compilation)</h3>
<p>gcc编译器的编译阶段指的是将源代码编译成汇编代码的过程,但这个阶段并不会进行汇编或链接操作.编译阶段的主要任务如下:</p>
<ol type="1">
<li>语法分析: 将源代码转换为语法树(AST),检查语法是否正确.</li>
<li>语义分析:
检查程序的变量类型,作用域和函数调用是否合理,同时在汇编代码中嵌入符号的声明和引用信息.</li>
<li>中间代码生成: 将语法树转换为中间代码.</li>
<li>优化: 对中间代码进行优化,提高执行效率.</li>
<li>目标架构相关指令生成:
将中间代码翻译成对应硬件的目标架构指令集,从而生成汇编代码.</li>
</ol>
<p>编译阶段的shell命令如下所示,</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -S prog.c</span><br><span class="line">gcc -S prog.i</span><br><span class="line">gcc -S prog.c -o test.s</span><br></pre></td></tr></table></figure>
<p>我们发现gcc的-S选项既可以从源代码文件开始编译,也可以从预处理后的文件开始编译.不同于预处理阶段的不会保存预处理结果,编译阶段的结果在默认情况下会保存在同名的.s文件.当然我们也可以用-o选项来指定输出文件的名称,这样gcc就会将编译后的结果输出到指定的文件中.</p>
<p>编译阶段的优化是一个非常重要的环节,因为它可以显著提高程序的执行效率.编译器会根据不同的优化级别进行不同程度的优化.在gcc中,我们可以通过-O选项来指定优化级别,具体如下:</p>
<ol type="1">
<li><p>-O0(不优化):
不进行优化,编译速度最快,一般是默认的级别;其生成的代码直接对应源代码,方便调试;代码体积较大,运行速度较慢.适用于开发调试阶段(确保代码逻辑正确);需要精确匹配源码和汇编代码的情况.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -S -O0 prog.c</span><br></pre></td></tr></table></figure></li>
<li><p>-O1(基本优化):
平衡优化和编译速度,进行一些简单的优化:删除未使用的代码块;合并常量;简单的循环优化(如减少临时变量存储);内联代码量小的函数.适用于需要一定优化但不想牺牲太多调试体验的情况.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -S -O0 prog.c</span><br></pre></td></tr></table></figure></li>
<li><p>-O2(推荐优化级别):
相比起-O1,他的优化策略更为激进,适用于发布版本:循环优化;指令调度;函数内联;更多的常量传播和死代码删除.代码的运行速度显著提升,但是其所需的编译时间会更长.调试的信息可能有所丢失,因为某些变量会被优化.适用于生产环境发布版本,需要较高的运行效率.值得注意的是,并不是更为激进的优化策略就能保证代码文件的大小更小,有时候-O2的优化会导致代码体积变大,因为编译器可能会将一些函数内联到调用处,从而增加代码的重复量.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -S -O2 prog.c</span><br></pre></td></tr></table></figure></li>
<li><p>-O3(激进优化):
他是gcc提供的最激进的优化基本,会可能导致代码的体积进一步变大:自动向量化(如使用SIMD指令集);更激进的内联和循环优化;可能改变浮点运算行为(影响精度).运行速度可能比-O2更快,但也可能引入问题(如代码膨胀或浮点误差).调试的信息可能会被改动的比较大,因此调试更为困难.适用于高性能计算(HPC),数值计算等对速度要求极高的场景.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -S -O3 prog.c</span><br></pre></td></tr></table></figure></li>
<li><p>-Os(优化代码大小):
其是在-O2的基础上优先减少代码体积;禁用可能增加代码大小的优化(如循环展开).适用于嵌入式系统,
内存受限的环境(如微控制器)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -S  -Os prog.c</span><br></pre></td></tr></table></figure></li>
</ol>
<p>可以用如下命令来查看gcc默认启用了哪些优化选项,</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -Q --help=optimizers | grep enabled</span><br></pre></td></tr></table></figure>
<p><a id="orga4cc90a"></a></p>
<h3 id="汇编assembly">汇编(Assembly)</h3>
<p>汇编阶段是在编译阶段得到的汇编代码的基础之上,用汇编器解析汇编指令,将其转换为CPU可直接执行的二进制指令(机器码)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -c prog.c -o test.o</span><br></pre></td></tr></table></figure>
<p>这里虽然我们只给出了从源代码文件开始编译的指令,但实际上可以从任意的中间文件(.i/.s)开始编译.同样,与编译阶段类似,gcc
-c会默认生成一个同名的后缀为.o的机器码文件;需值得注意的是,这个同名文件指的是与操作的文件同名,不一定会与源文件同名.</p>
<p>其主要任务如下:</p>
<ol type="1">
<li>符号与重定位信息处理:
为变量,函数等符号创建表,记录其位置与类型;生成重定位信息,以支持连接器在最终链接时解析地址.</li>
<li>节区分布:
将代码和数据分配到不同的节区(如.text节区存放代码,.data节区存放初始化数据,.bss节区存放未初始化数据),以便于链接器处理.</li>
<li>生成目标文件:
将处理后的机器码和符号表信息写入目标文件(.o文件),以供链接器使用.</li>
</ol>
<p><a id="org775eb54"></a></p>
<h3 id="链接linking">链接(Linking)</h3>
<p>链接阶段的主要任务是将多个目标文件(.o文件)和库文件(.a/.so)合并成一个可执行文件或共享库.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc prog.o -o exec</span><br></pre></td></tr></table></figure>
<p>这里调用的是gnu的ld连接器,完成链接操作.</p>
<p>其主要任务如下:</p>
<ol type="1">
<li><p>符号解析:
检查所有.o文件中使用的函数和变量名;找出它们的定义位置并建立正确的引用关系.
如:在main.o中用到了foo函数,但foo定义在foo.o中,链接器会将foo.o中的foo函数地址填入main.o的引用位置.</p></li>
<li><p>重定位:
每个.o文件内部的地址是从零开始的虚拟地址;连接器需要把这些地址重新计算成全局地址,也就是程序运行时的实际地址;修改目标文件中相关位置(代码和数据段)来修正地址引用.</p></li>
<li><p>合并节区:
将所有.o文件的相同节区合并成一个节区,如将所有的.text节区合并成一个大的.text节区,以便于最终生成可执行文件.</p></li>
<li><p>符号表和重定位信息清理:
可执行文件通常不再保留完整的符号表(除非带调试信息);重定位表信息也会被清除,因为地址已固定.</p></li>
<li><p>链接库文件:
如果使用了静态库(.a)或动态库(.so),链接器会将所需的库文件合并到最终的可执行文件中;对于动态库,链接器会记录库的路径和符号信息,以便运行时加载.</p></li>
</ol>
<h4 id="静态链接static-linking">静态链接(static linking)</h4>
<p>静态链接就是以一组可以重定位目标文件和命令行参数作为输入,生成一个完全链接的可以加载和运行的可执行目标文件作为输出.这其实是因为在大型程序下,我们会出现多个目标文件之间存在相互调用的情况,为了满足这种互相调用的关系,我们需要将这些源文件产生的目标文件做一个链接,从而形成一个可以执行的程序.由很多目标文件进行链接形成的是静态库,换言之,静态库也可以简单看成是一组目标文件的集合,也就是很多目标文件经过压缩打包后形成的一个文件.</p>
<p>其主要的缺点:</p>
<ol type="1">
<li><p>浪费内存空间,因为每个可执行程序中对所有需要的目标文件都要有一个副本,所以如果有多个程序使用同一个库,每个程序都会包含这个库的副本,导致内存浪费.</p></li>
<li><p>更新不便,如果库文件有更新,需要重新编译所有依赖这个库的程序,这在大型项目中可能非常麻烦.</p></li>
</ol>
<p>其的优点在于由于可执行文件已经具备了所有执行程序所需的任何东西,因此其在运行时速度会更快.</p>
<h4 id="动态链接dynamic-linking">动态链接(dynamic linking)</h4>
<p>动态链接是为了解决静态链接所提及的浪费内存和更新不便的问题而提出的.动态链接的基本思想是把程序按照模块拆分成各个相对独立部分,在程序运行时才将它们链接在一起形成一个完整的程序.其流程如下:</p>
<p>假设现在有两个程序prog1.o和prog2.o,这两者共用同一个库lib.o,假设首先运行程序prog1,系统首先加载prog1.o,当系统发现prog1.o中用到了lib.o,即prog1.o依赖于lib.o,那么系统接着加载lib.o,如果prog1.o和lib.o还依赖于其他目标文件,则依次全部加载到内存中.当prog2运行时,同样的加载prog2.o,然后发现program2.o依赖于lib.o,但是此时lib.o已经存在于内存中,这个时候就不再进行重新加载,而是将内存中已经存在的lib.o映射到prog2的虚拟地址空间中,从而进行链接(这个链接过程和静态链接类似)形成可执行程序.</p>
<p>其主要的优点:</p>
<ol type="1">
<li>节省内存空间,因为多个程序可以共享同一个库文件的内存映射,避免了重复加载相同的库.</li>
<li>更新方便,如果库文件有更新,只需要替换库文件即可,不需要重新编译所有依赖这个库的程序,只要保证接口不变即可.</li>
</ol>
<p>其的缺点在于由于程序在运行时才进行链接,因此会增加程序的启动时间和运行时的开销,因为需要在运行时解析符号和地址.</p>
]]></content>
      <categories>
        <category>C Language</category>
      </categories>
      <tags>
        <tag>Computer Science</tag>
        <tag>C Language</tag>
      </tags>
  </entry>
  <entry>
    <title>ANSI-Extern, Const和Static 的用法</title>
    <url>/2024/09/11/ANSI-extern/</url>
    <content><![CDATA[<h3 id="extern-的用法">Extern 的用法</h3>
<p>在 C 语言中, 修饰符 extern 用在变量或者函数声明之前,
用来标识变量或者函数的定义在别的文件中已经给出,
告知编译器运行到此变量或函数时, 在其他位置寻找其定义.
其常见的用法如下:</p>
<span id="more"></span>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> a;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> b;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> l &gt; r ? l : r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">max</span>(a, b) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">20</span>;</span><br></pre></td></tr></table></figure>
<p>此处如果不在开头加上 extern int a,那么main函数是无法访问变量 a,b 的,
即使变量 a,b 是一个外部变量, 但其作用域是定义以后至程序结束, 而修饰符
extern 引导的变量声明延拓了该外部变量的存在域. 实际上, extern
修饰符主要还是在多源文件的情况下使用.</p>
<h4 id="extern-修饰变量的声明">Extern 修饰变量的声明</h4>
<p>　extern关键字可以用来修饰变量，表示该变量在别的文件中已有声明。例如：我们在文件file1.c中声明了变量int
var，然后我们又需要再file2.c中使用该变量，则可在文件file2.c中声明extern
int var，就可在文件file2.c中使用该变量了。</p>
<p>值得强调的是 extern 修饰的是变量的声明,
变量的声明仅仅向编译器传递了变量的信息, 但并不会分配内存;
分配内存是通过变量定义来实现的. 因此我们如果使用 extern 修饰变量声明,
是不可以同时在其后初始化, 因为声明并不会对变量, 对内存操作的. 其次, 使用
extern 修饰声明的变量一定要是全局变量, 这是因为如果声明的是局部变量,
那么他的存活域只在某个函数体内部,
在其他文件中引用这个变量也是没有意义的.</p>
<p>进一步, 我们可以讨论由 extern 修饰的变量声明对应的存活域. 首先,
由前面的介绍知道, extern 声明的变量只能是全局变量, 但是如果 extern
修饰的变量声明位于某个函数体内, 那么其存活域也只在这个函数内部,
与在函数内部设置的局部变量一致.</p>
<h4 id="extern-修饰函数声明">Extern 修饰函数声明</h4>
<p>从本质来看, extern 修饰函数声明与修饰变量声明是等价的.
但我们更为常用的引用其他文件的函数是通过头文件的方式来引用的.
在程序实现层面, 这两种方式是有所不同的,
引用头文件的编译处理是一种预处理方式, 而extern
修饰的声明则是代码链接层面的实现. 因此一般而言,
如果需要大批量引用函数声明, 那么就用头文件更为便利,
而如果只是引用少数函数, 那么用 extern 修饰声明即可.</p>
<h4 id="extern-用来实现链接指定">Extern 用来实现链接指定</h4>
<p>extern用来进行链接指定一般来说是用来实现混合编程.
例如我们如果要在C++程序中调用C代码, 那么我们就需要用extern
"C"来声明.</p>
<p>extern "C" 可用于单一语句</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> “C” <span class="function"><span class="type">double</span> <span class="title">sqrt</span><span class="params">(<span class="type">double</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>也可以是复合语句, 相当于复合语句中的声明都加了 extern “C”</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> “C”</span><br><span class="line">&#123;</span><br><span class="line">      <span class="function"><span class="type">double</span> <span class="title">sqrt</span><span class="params">(<span class="type">double</span>)</span></span>;</span><br><span class="line">      <span class="function"><span class="type">int</span> <span class="title">min</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样可以包含头文件，相当于头文件中的声明都加了extern “C”
(不建议这样写，会有嵌套可能)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> “C”</span><br><span class="line">&#123;</span><br><span class="line">      ＃include &lt;cmath&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>值得注意的是, extern "C" 是不可以用在函数内部的,
且如果函数有多个声明, 可以全都加上 extern "C", 也可以只加一个,
后续声明会遵循第一个链接指示符的规则.</p>
<h3 id="static-的用法">Static 的用法</h3>
<p>static 的用法其实只有三个: 隐藏, 保持变量持久, 默认初始化为0</p>
<h4 id="static-的主要功能隐藏">Static 的主要功能:隐藏</h4>
<p>当我们同时编译多个源文件时, 普通的全局变量和函数 (即未加 static 的)
都是全局可访问的.</p>
<p>例如, 对于多源文件main.cpp和test.cpp如下所示</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main source</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="type">char</span> a;    <span class="comment">// extern variable must be declared before use</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, a);</span><br><span class="line">    <span class="function"><span class="keyword">extern</span> <span class="type">void</span> <span class="title">msg</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="built_in">msg</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>test.cpp结构如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> a = <span class="string">&#x27;A&#x27;</span>; <span class="comment">// global variable</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">msg</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述可以运行是因为在test.cpp文件中的全局变量并没有加static,因此其余文件可以随意的利用修饰符extern来调用全局变量和函数.
如果加上static, 那么他就会对其余的源文件隐藏, 只能在本文件中使用.
因此利用这一特性我们可以在不同的源文件定义同名变量与同名函数,
不会出现命名冲突, 也不会出现数据混用的情况. static
可用于修饰函数也可以用来修饰变量; 如果针对函数, 那么 static
的作用仅限于隐藏; 而对于变量, 那么 static 就有接下来的两个作用.</p>
<h4 id="保持变量内容的持久">保持变量内容的持久</h4>
<p>与自动变量存储在栈区不同, static变量会存储在静态存储区.
虽然全局变量也会存储在静态存储区, 但是与全局变量相比,
static变量主要的特性是对变量的隐藏.</p>
<p>如果static用于声明内部变量,
那么static类型的内部变量和函数内部的自动变量一样,只能在函数内部使用,
但不同的一点是, 函数内部的自动变量会在函数运行结束自动释放内存,
下一次运行需要重新声明, 重新分配内存; 而static类型变量则不会,
她只在第一次声明时分配内存且完成初始化, 不会随着函数的返回而释放空间,
一直等到重新调用函数时,其值为上次结束时的值.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fun</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count = <span class="number">10</span>;    <span class="comment">// 首次运行时,会将静态变量完成初始化,而后不会再运行,下一次的值是由上次存储的数据来保证.</span></span><br><span class="line">    <span class="keyword">return</span> count--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> count = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;global\t\tlocal static\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(; count &lt;= <span class="number">10</span>; ++count)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\t\t%d\n&quot;</span>, count, <span class="built_in">fun</span>());    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="默认初始化为-0">默认初始化为 0</h4>
<p>实际上, 全局变量也有这个特性,
这是因为全局变量和静态变量都存储在静态存储区, 静态存储区的字节默认为
0x00. 善用这个特性, 可以极大简便程序的编写复杂度,
如果我们考虑一个稀疏矩阵, 如果我们设置局部变量,
那么我们需要先将变量全部置为0, 而后一个个添加非零元素;
实际上我们可以直接用静态变量, 这样的话, 我们只需要添加非零元素即可.
这同样对字符串有相同的操作.</p>
<h3 id="const-的用法">Const 的用法</h3>
<p>const 用来修饰一个变量, 那么他的值从某种角度来说就是不能被改变的.
这其实很类似与C语言中的#define的宏命令, 这两个之间还是有较大的差异:</p>
<ol type="1">
<li>#define 是预处理指令, 其在预处理阶段就会完成文本替换.
而const则是对变量的修饰,因此他需要在后续的语法编译的时期,
程序还要检查其类型是否正确, 对比更加安全.</li>
<li>const 可以保护被修饰的内容, 防止意外修改,
从而来增强程序的鲁棒性.</li>
<li>const 常量是不通过编译器分配内存空间的, 而是将其纳入符号表;
这样使得他在运行过程中不需要存储和读取内存的时间, 提高了运行效率.</li>
</ol>
<h4 id="修饰局部变量">修饰局部变量</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a=<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="type">const</span> a=<span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>这两个语句表示的是同一条命令, 即定义整型const常量a并初始化为1.
由于const常量后续将不再允许被修改,
因此我们在定义const常量的同时一定要对其进行初始化.
其实对于这种基本类型的const修饰十分简单,
我们考虑const字符串,可以知道他的一些优势.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* ptr=<span class="string">&quot;Hello world!&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>如果这里我们不加上const限定符, 那在程序中可能出现 ptr[3]='L' 的命令,
他会因为对只读区域的写入而报错, 也就是在程序运行时报错; 而如果我们用
const 限制符, 那么在程序编译期间, 就会因为试图修改const常量而报错.</p>
<h4 id="常量指针和指针常量">常量指针和指针常量</h4>
<p>值得注意的是 const 的使用在此处将会十分灵活, 因为他涉及到指针的内容,
因此比较复杂.</p>
<p>首先, 我们先考虑常量指针, 其声明方式如下所示,</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>* ptr;</span><br><span class="line"><span class="type">int</span> <span class="type">const</span> * ptr;</span><br></pre></td></tr></table></figure>
<p>常量指针的含义为指针指向的内容是常量.
不可以通过常量指针来修改对应的值. 需要注意的是,</p>
<ol type="1">
<li><p>这里的常量指针不能修改对应的值,只是不能通过常量指针修改;
但允许通过其他的引用来修改, 例如</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* pn=&amp;a;</span><br><span class="line">*pn=<span class="number">10</span>; <span class="comment">//报错,因为pn是常量指针</span></span><br><span class="line">a=<span class="number">10</span>; <span class="comment">//允许运行, 因为这是其他的引用并没有常量的限制</span></span><br></pre></td></tr></table></figure></li>
<li><p>常量指针指向的值不能修改, 但是可以修改常量指针指向的对象,
也就是可以将常量指针指向不同的位置.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x=<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> y=<span class="number">6</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* pn=&amp;x;</span><br><span class="line">pn=&amp;y;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>其次, 我们讨论指针常量, 其定义声明如下所示</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* <span class="type">const</span> pn;</span><br></pre></td></tr></table></figure>
<p>指针常量指的是这个指针本身就是一个常量,
我们在运行过程中不可以重新给该指针常量重新赋值,
但是我们可以用这个指针修改他指向的内容. 例如</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span>* <span class="type">const</span> n = &amp;a;</span><br><span class="line">*n = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>这两种const常量的定义的区别仅在于 const 限定符与 * 的位置关系,
如果const在* 左边, 那么定义的就是常量指针; 如果const在* 右边,
那么定义的就是指针常量. 特殊的实际上, 我们可以将上面的两种定义合并,
得到指向常量的常指针的定义</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>* <span class="type">const</span> a=<span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>指针指向的位置不能改变并且也不能通过这个指针改变变量的值，但是依然可以通过其他的普通指针改变变量的值.</p>
<h4 id="修饰函数的参数">修饰函数的参数</h4>
<p>根据前面讨论的常量指针和指针常量, const修饰函数的参数也为两种</p>
<ol type="1">
<li><p>防止修改指针指向的内容</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">StringCopy</span><span class="params">(<span class="type">char</span> *strDestination, <span class="type">const</span> <span class="type">char</span> *strSource)</span></span>;</span><br></pre></td></tr></table></figure>
<p>其中函数内部是不能随意修改strSource指向的内容,
在编译期间就会报错.</p></li>
<li><p>防止修改指针的地址</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>* <span class="type">const</span> p1, <span class="type">int</span>* <span class="type">const</span> p2)</span></span>;</span><br></pre></td></tr></table></figure>
<p>不能随意修改p1和p2的地址.</p></li>
</ol>
<h4 id="修饰函数的返回值">修饰函数的返回值</h4>
<p>如果给以“指针传递”方式的函数返回值加 const
修饰，那么函数返回值（即指针）的内容不能被修改，该返回值只能被赋给加const
修饰的同类型指针.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">Getstring</span><span class="params">()</span></span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* str=<span class="built_in">Getstring</span>();</span><br></pre></td></tr></table></figure>
<h4 id="修饰全局变量">修饰全局变量</h4>
<p>全局变量的作用域是整个文件，我们应该尽量避免使用全局变量，因为一旦有一个函数改变了全局变量的值，它也会影响到其他引用这个变量的函数，导致除了bug后很难发现，如果一定要用全局变量，我们应该尽量的使用const修饰符进行修饰，这样防止不必要的人为修改，使用的方法与局部变量是相同的。</p>
<h3 id="代码运行的内存分配">代码运行的内存分配</h3>
<p>C/C++程序经过编译器完成编译链接等等处理工作以后得到的二进制文件,
其包含栈(stack), 堆(heap), 数据段, BSS段, 代码段. 其中数据段,
BSS段和代码段是程序编译完成就已经分配完成了, 无需等代码运行;
而堆区和栈区需要程序被加载到内存开始运行时才会分配.</p>
<ol type="1">
<li><p>栈区(stack): 由编译器自动分配和释放内存.
该区一般用于存储函数参数, 局部变量等值.
其操作方式类似于数据结构中提到的栈.</p></li>
<li><p>堆区(heap): 程序员通过 new 命令和 malloc 命令,
可以动态申请某个大小的内存. 注意的是, 此区的内存和栈区的不同,
并不能由编译器自动释放, 而是由程序员通过 delete 命令和 free
命令来手动释放内存, 如果不释放, 长期使用下, 申请内存超过了堆区大小,
那么就会发生内存泄漏现象.</p></li>
<li><p>数据段:
数据段属于静态内存分配,所有有初值的全局变量和用static修饰的静态变量，常量数据都在数据段中。实际上可以认为其分为两块数据段:1.只读数据段
2. 读写数据段.</p>
<p>在只读数据段中,
一般用来存储程序使用时不会发生变化的数据.一般是用const修饰的变量或者程序中使用的文字常量存储在此处.
特殊的还有常量存储区（特殊的常量存储区，属于静态存储区）</p>
<p>　　1) 常量占用内存,只读状态,决不可修改 　　2)
常量字符串就是放在这里的，程序结束后由系统释放</p>
<p>读写数据段:用来存储那些已经完成初始化的全局变量或者初始化的静态变量.
已初始化数据是在程序中声明，并且具有初值的变量，这些变量需要占用存储器的空间，在程序执行时它们需要位于可读写的内存区域内，并且有初值，以供程序运行时读写</p></li>
<li><p>BSS段: 存储未初始化的全局变量或者静态（全局）变量. 其是可读写的,
编译器给处理成0. 未初始化数据是在程序中声明, 但是没有初始化的变量,
这些变量在程序运行之前不需要占用存储器的空间. 与读写数据段类似,
它也属于静态数据区. 但是该段中数据没有经过初始化.
未初始化数据段只有在运行的初始化阶段才会产生,
因此它的大小不会影响目标文件的大小.</p></li>
<li><p>代码段:
存放函数体的二进制代码,所有语句经过编译后产生的CPU指令都会存放在此处.</p></li>
</ol>
]]></content>
      <categories>
        <category>C Language</category>
      </categories>
      <tags>
        <tag>Computer Science</tag>
        <tag>C Language</tag>
      </tags>
  </entry>
  <entry>
    <title>Lecture series on graph theory 1</title>
    <url>/2022/03/28/Graph1/</url>
    <content><![CDATA[<p>Def. A graph is a <font color=red>discrete structure/combinational
structure</font> consisting of vertices and edges which connect to a
pair of vertices.</p>
<p>Usually, a vertex is represented by a dot and an edge is represented
by a line (straight or curved) joining two vertices.</p>
<span id="more"></span>
<p><img
src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220226/2022-02-26_212559.jpg" /></p>
<center>
<font color=red size=4>The green points mean crossing of the
edges,rather than vertices  </font>
</center>
<p>A vertex is incident with an edge if the edge join the vertex to
another vertex, which is also called the end of the edge.</p>
<p>Two vertices are adjacent to each other if there is an edge joinging
them.</p>
<p><img
src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220226/2022-02-26_214218.jpg" /></p>
<center>
<font color=red size=4>We say that the vertex v is incident with the
edge e<br>The vertex u is adjacent to the vertex v because uv is an edge
of G</font>
</center>
<p>A graph is simple if there is at most one edge between any two
vertices and there is no edge joining a vertex itself.</p>
<p><img
src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220226/2022-03-28_185112.jpg" /></p>
<p>In short, a graph is simple if and only if it has no multi-edges and
no loops.Next, unless otherwise specified, we will discuss simple graphs
by default.</p>
<p>For any given simple graph <span
class="math inline">\(G(V,E)\)</span>，V is the vertex set and E is the
edge set. <span class="math display">\[
if\ \lvert V\rvert=n,\lvert E\rvert\leq\binom{n}{2}
\]</span> A graph is complete if the graph has an edge between every
pair of vertices.A complete graph of n vertices is usually denoted by
<span class="math inline">\(K_n\)</span></p>
<p><img
src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220226/2022-03-28_185902.jpg" /></p>
<p>The degree of a vertex v of G, denoted by <span
class="math inline">\(d_G(v)\)</span>, is the number of edges incident
with it.</p>
<p>The maximum degree of G is defined as <span
class="math inline">\(\Delta(G):=\max\{d_G(x)|v\in V(G)\}\)</span></p>
<p>The minimum degree of G is defined as <span
class="math inline">\(\delta G:=\min\{d_G(v)|v\in V(G)\}\)</span></p>
<p>The average degree of G is defined as <span
class="math inline">\(d(G):=\frac{\lvert E(G)\rvert}{\lvert
V(G)\rvert}\)</span>, this index is used to measure the density of the
graph.According to this index, graph can be divided into dense graph and
sparse graph</p>
<p>A neighbor of v in G is a vertex joined to v by an edge of G.The
neighborhood of a vertex v in G is the set of all neighbors of v in G,
denoted by <span class="math inline">\(N_G(v)=\{u|u\in V(G),uv\in
E(G)\}\)</span>.We have <span class="math inline">\(d_G(v)=\lvert
N_G(v)\rvert\)</span> easily.</p>
<p><img
src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220226/2022-03-28_185933.jpg" /></p>
<p><font color=red>This picture shows the multi-level neighbors of v. If
u is both a second-level neighbor and a third-level neighbor of v, it is
classified as a second-level neighbor. <br>Here we give the set
representation of neighbors: <br><span
class="math inline">\(N_1(v)=N_G(v),N_2(v)=N_G(N_1(v))-N_1(v)\cup\{v\},\
N_3(v)=N_G(N_2(v))-N_1(v)\)</span><br>and if <span
class="math inline">\(w\in N_3(v),\ distance(w,v)=3\)</span></font></p>
<p>A graph is even if every vertex of G has an even degree.</p>
<p><img src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220226/2022-03-28_185942.jpg" style="zoom:50%;" /></p>
<p><strong>Proposition(Handshaking Lemma)<br>Every graph has an even
number of vertices with odd degree.</strong></p>
<p>Proof.</p>
<p>Let <span class="math display">\[
\left\{\begin{aligned}X&amp;=\{x|x\in V(G)\ and\
d_G(x)\equiv0(mod\ 2)\}\\Y&amp;=\{y|y\in V(G)\ and\
d_G(y)\equiv1(mod\ 2)\}\end{aligned}\right.
\]</span> Then,<span class="math inline">\(\sum_{x\in
X}d_G(x)+\sum_{y\in Y}d_G(y)=2\lvert E(G)\rvert\)</span></p>
<p>So, <span class="math inline">\(\sum_{y\in Y}d_G(y)\equiv0(mod\
2)\)</span>.It follows immediately that <span
class="math inline">\(\lvert Y\rvert\equiv0(mod\ 2)\)</span></p>
<p>So the proposition holds.</p>
<p>Question:Let G be an n-vertex graph.How many edges will force G to
have a triangle?(Mantel's Theorem)</p>
<p>Def A walk of G is <font color=red>a sequence of vertices and edges
of G</font>such that (i)both the first element and the last element of
the sequence are vertices and (ii) any two consecutive elements in the
sequence contains one vertex and one edge which are incident with each
other.</p>
<p><img
src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220226/2022-03-28_200038.jpg" /></p>
<p><font color=red>We give two different walks: <span
class="math inline">\(w_{1}=v_1e_1v_2e_2v_3e_2v_2e_1v_1,\ 
w_2=v_2e_2v_3e_3v_4e_4v_2\)</span><br>For walk,vertex can be repeated,
edge can be repeated.</font></p>
<p>A walk is open if the first vertex is not equal to the last vertex.
<font color=red><span
class="math inline">\(w_0=v_2e_2v_3e_3v_4e_4v_2e_1v_1\)</span></font></p>
<p>A walk is a trail if it does not have repeated edges.
<font color=red><span class="math inline">\(w_0\)</span> is a
trail</font></p>
<p>A trail is a path if it does not have repeated vertices.</p>
<p><font color=red><span
class="math inline">\(w_3=v_1e_1v_2e_2v_3e_3v_4=v_1v_2v_3v_4\)</span> is
a path</font></p>
<p>A cycle is a closed trail( or path) without repeated vertices
(vertices and edges) <font color =red>except the first vertex and the
last vertex. <span
class="math inline">\(w_4=v_2e_2v_3e_3v_4e_4v_2\)</span></font></p>
<p>A graph is connected if for any two vertices x and y, there is a path
joining x and y.</p>
<p><img
src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220226/2022-03-28_200053.75zqcj50zpw0.jpg" /></p>
<p>A subgraph H of G is a graph with <span
class="math inline">\(V(H)\subset V(G),E(H)\subset E(G)\)</span></p>
<p>A maximal connected subgraph of G is called a connected component.
<font color=red>Maximal means anything bigger than it is not
connected</font></p>
<p>An edge e of G is bridge or cut-edge if #connected components of
G-e&gt;#connected components of G</p>
<p><img src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220226/2022-03-28_200107.7d9xw8946f80.jpg" style="zoom:67%;" /></p>
<p><font color=red>#connected components of G-<span
class="math inline">\(e_1\)</span>=3&gt;2=#connected components of
G<br>Both <span class="math inline">\(e_1\)</span> and<span
class="math inline">\(e_2\)</span> are bridges/cut-edges</font></p>
<p><strong>Thm(BJJ,Fan)<br>Every graph without bridges has a family of
cycles which covers every edge exactly 2k times for any integer <span
class="math inline">\(k\ge2\)</span></strong></p>
<p>A subgraph H is spanning if <span
class="math inline">\(V(H)=V(G)\)</span></p>
<p>A subgraph H is induced by <font color=red> <span
class="math inline">\(S\subset V(G)\)</span></font>, if <span
class="math inline">\(V(H)=S\)</span> and for any two vertices <span
class="math inline">\(x,y\in S\)</span>, <span
class="math inline">\(xy\in E(H)\Leftrightarrow xy\in E(G)\)</span></p>
<p>A subgraph H is induced by <font color=red> <span
class="math inline">\(S\subset E(G)\)</span></font>, if <span
class="math inline">\(E(H)=S\)</span> and <span
class="math inline">\(v\in V(H)\)</span>a if and only if v is incident
with an edge in S.</p>
<p><img
src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220226/2022-03-28_213047.4nctxwr5lzc0.jpg" /></p>
<p>Let <span class="math inline">\(x,y\in V(G)\)</span>, the distance
between x and y in G is the length of the shortest path joining x and y,
denoted by <span class="math inline">\(dist_G(x,y)\)</span>. In other
words, <span class="math display">\[
dist_G(x,y)=\min\{\lvert E(P)\rvert\big|P\ is\ a\ path\ joining\ x\ and\
y\}
\]</span>
<img src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220226/2022-03-28_215149.3o033gismx60.jpg" style="zoom:67%;" /></p>
<p><font color=red><span class="math inline">\(dist_G(x,y)=k\)</span>,
this means finding a shortest path between any two vertices x and y is
easy</font></p>
<p><font color=red>However, finding a longest path between any two
vertices x and y.Given an integer k, is there an (x,y)-path with length
k?They are NPC problems</font></p>
]]></content>
      <categories>
        <category>Graph Theory</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Operation Research</tag>
      </tags>
  </entry>
  <entry>
    <title>CS229 Notes for Lecture 2</title>
    <url>/2024/07/30/CS229%20Notes%20for%20Lecture%202/</url>
    <content><![CDATA[<h1 id="lecture-1">Lecture 1</h1>
<p><a id="org8b14315"></a></p>
<h2 id="introduction-of-supervised-learning">Introduction of supervised
learning</h2>
<p>在介绍监督学习(Supervised
learning)之前,我们先罗列一些常用的符号,以便于后续的讨论:</p>
<ul>
<li><p><span class="math inline">\(m\)</span>: 训练样本的数量</p></li>
<li><p><span class="math inline">\(n\)</span>: 特征的数量</p></li>
<li><p><span class="math inline">\(x\)</span>: 输入变量(input variable),
或称为输入特征(input feature/attribute)</p></li>
<li><p><span class="math inline">\(y\)</span>: 输出变量(output
variable), 或称为目标变量(target variable)</p></li>
<li><p><span class="math inline">\((x,y)\)</span>: 表示训练样本; <span
class="math inline">\((x^{(i)}, y^{(i)})\)</span>: 第 i 个训练样本(<span
class="math inline">\(i^{th}\)</span> training example)</p></li>
<li><p><span class="math inline">\(\mathcal{X}\)</span>:
输入变量的空间(input space)</p></li>
<li><p><span class="math inline">\(\mathcal{Y}\)</span>:
输出变量的空间(output space)</p>
<span id="more"></span></li>
</ul>
<p>监督学习的目标是基于已知的训练样本, 学习出一个假设(hypothesis) <span
class="math inline">\(h: \mathcal{X} \rightarrow \mathcal{Y}\)</span>,
使得 <span class="math inline">\(h(x)\)</span>
能够尽可能地接近真实的输出 <span class="math inline">\(y\)</span>.
根据输出变量的类型,我们可以将监督学习分成两类问题:</p>
<ol type="1">
<li>回归问题(Regression): 输出变量的取值是连续的</li>
<li>分类问题(Classification): 输出变量的取值是离散的</li>
</ol>
<p>我们可以从下图来直观理解监督学习的过程:</p>
<p><img
src="https://cdn.jsdelivr.net/gh/LYD122504/picx-images-hosting@master/2024-07-30_16-29-16_screenshot.lz8nr081.png" />
因此,监督学习的关键就是利用学习算法(learning algorithm)从训练集(training
set)中学习出一个符合条件的假设 <span class="math inline">\(h\)</span>,
进一步其实监督学习的关键就是去构造一个合适的学习算法.</p>
<p>而在构造学习算法的过程中, 我们需要考虑以下几个问题:</p>
<ol type="1">
<li>训练集样本是什么样的?</li>
<li>假设函数是什么样的?</li>
<li>如何表示假设函数?</li>
</ol>
<p><a id="org172f874"></a></p>
<h2 id="linear-regression">Linear regression</h2>
<p>在本节中, 我们将假设函数 <span class="math inline">\(h\)</span>
限制在线性函数形式下考虑回归问题, 这一问题也被称之为线性回归问题(Linear
Regression). 在线性回归问题中, 我们试图去构造一个线性的假设函数,
因此我们可以直接形式的写出假设函数的结构如下: <span
class="math display">\[h(x)=\theta_0+\theta_1x_1+\cdots+\theta_nx_n\]</span>
其中, <span class="math inline">\(\theta_i(i=0,\cdots,n)\)</span>
是参量(parameter), 如果我们将其确定下来,
那么我们就可以得到一个确定的假设函数 <span
class="math inline">\(h\)</span>. 但为了形式上的简洁,
我们引入一个虚特征(dummy feature) <span
class="math inline">\(x_0=1\)</span>,
这样我们就可以将上面的假设函数写成更为紧凑的形式: <span
class="math display">\[h(x)=\sum_{i=0}^n\theta_ix_i=\theta^Tx\]</span>
其中, <span
class="math inline">\(\theta=(\theta_0,\cdots,\theta_n)^T\)</span>
是学习算法的参数向量(parameter vector), <span
class="math inline">\(x=(x_0,\cdots,x_n)^T\)</span>. 在此值得注意的是,
虽然我们只考虑 <span class="math inline">\(n\)</span> 个输入特征,
但由于我们为了方便引入了虚特征, 因此实际上我们考虑的 <span
class="math inline">\(\theta\)</span> 和 <span
class="math inline">\(x\)</span> 是一个 <span
class="math inline">\(n+1\)</span> 维的向量. 其次,
虽然我们在此给出的假设函数符号是 <span
class="math inline">\(h(x)\)</span>, 但实际上更为明确的写法应该是 <span
class="math inline">\(h_{\theta}(x)\)</span>, 这样可以表示假设函数 <span
class="math inline">\(h\)</span> 不仅依赖于输入特征 <span
class="math inline">\(x\)</span>, 还依赖于参数向量 <span
class="math inline">\(\theta\)</span>; 只是在不引起混淆的情况下,
我们可以省略 <span class="math inline">\(\theta\)</span> 的表示.</p>
<p>根据上面的假设函数的结构,
我们可以知道学习算法的工作是选择一个合适的参数向量,
这样就可以导出一个假设, 因此如何选择合适的参数向量就是学习算法的关键.
从直观上来说, 对于训练集样本, 我们希望选择出来的参数向量能够使得 <span
class="math inline">\(h(x)\)</span> 尽可能地接近真实的输出 <span
class="math inline">\(y\)</span>. 因此我们需要先定义一个函数用来度量
<span class="math inline">\(h(x)\)</span> 和 <span
class="math inline">\(y\)</span> 之间的差距, 我们称之为成本函数(cost
function): <span
class="math display">\[J(\theta)=\frac{1}{2}\sum_{i=1}^m(h(x^{(i)})-y^{(i)})^2\]</span>
此处的 <span class="math inline">\(\frac{1}{2}\)</span>
是因为可以消去因求导得到的<span class="math inline">\(2\)</span>,
并不影响最后结果. 根据我们前面介绍的选择参数向量 <span
class="math inline">\(\theta\)</span> 的目标,
我们将其转化为一个优化问题, 即找到一个 <span
class="math inline">\(\theta\)</span> 使得 <span
class="math inline">\(J(\theta)\)</span> 最小, 其数学形式如下: <span
class="math display">\[\min_{\theta}J(\theta)=\min_{\theta}\frac{1}{2}\sum_{i=1}^m(h(x^{(i)})-y^{(i)})^2\]</span></p>
<p><a id="org5e1d335"></a></p>
<h2 id="gradient-descentgd">Gradient Descent(GD)</h2>
<p>此节中, 我们将用梯度下降算法(Gradient Descent)来求解上面的优化问题.
值得注意的是, 梯度下降算法是一种迭代算法,
其基本思想是通过不断更新迭代参数向量 <span
class="math inline">\(\theta\)</span> 的值, 使得成本函数 <span
class="math inline">\(J(\theta)\)</span> 不断减小, 直到收敛到最小值.</p>
<p>我们可以给出梯度下降算法的框架如下:</p>
<ol type="1">
<li>Start with some <span class="math inline">\(\theta\)</span>. For
example, <span class="math inline">\(\theta=0\)</span>.</li>
<li>Keep changing <span class="math inline">\(\theta\)</span> to reduce
<span class="math inline">\(J(\theta)\)</span>.</li>
<li>Repeat 2. until convergence.</li>
</ol>
<p>从上面的框架中我们可以看出, 梯度下降算法的关键就是如何更新参数向量
<span class="math inline">\(\theta\)</span> 的值, 其更新的规则如下:
<span
class="math display">\[\theta_j:=\theta_j-\alpha\frac{\partial}{\partial\theta_j}J(\theta)\
\text{for each value of }j\]</span> 这里的 <span
class="math inline">\(\alpha\)</span> 是学习率(learning rate),
用来控制参数向量 <span class="math inline">\(\theta\)</span> 的更新步长;
但这个值的选取是一个极具经验性的问题,
因为学习率太小则会导致收敛速度太慢, 而学习率太大则会导致算法无法收敛.
因此实际中, 应该尝试多组学习率, 从而选择一个最为合适的学习率.</p>
<p>由于我们已知成本函数 <span class="math inline">\(J(\theta)\)</span>
的具体形式, 因此我们可以直接求出其关于参数向量 <span
class="math inline">\(\theta\)</span> 的偏导数的具体形式为: <span
class="math display">\[\begin{aligned}\frac{\partial}{\partial\theta_j}J(\theta)&amp;=\frac{\partial}{\partial\theta_j}\frac{1}{2}\sum_{i=1}^m(h(x^{(i)})-y^{(i)})^2\\
&amp;=\sum_{i=0}^m(h(x^{(i)})-y^{(i)})\frac{\partial}{\partial
\theta_j}(h(x^{(i)})-y^{(i)})\\
&amp;=\sum_{i=0}^m(h(x^{(i)})-y^{(i)})\frac{\partial}{\partial
\theta_j}(\sum_{k=0}^n\theta_kx_k^{(i)}-y^{(i)})\\
&amp;=\sum_{i=0}^m(h(x^{(i)})-y^{(i)})x_j^{(i)}\end{aligned}\]</span>
根据上面的偏导数的具体形式,
我们可以将梯度下降算法的更新规则写成更为具体的形式: <span
class="math display">\[\theta_j:=\theta_j-\alpha\sum_{i=0}^m(h(x^{(i)})-y^{(i)})x_j^{(i)},\
j=0,1,\dots,n\]</span> 从这个更新规则中,
我们可以发现每更新一次需要用全部训练样本的数据,
因此我们将这种梯度下降算法称之为批量梯度下降算法(Batch Gradient
Descent).其的主要优点就是计算稳定, 他一定可以朝着极小值的方向前进;
但是缺点也很明显, 因为他每次更新参数都需要用到全部的训练样本,
因此如果训练样本数据量很大的情况,
那么他的计算量就会花费大量时间在调用全部训练样本上.</p>
<p>因此, 为了避免每次更新参数都需要用到全部训练样本的数据,
我们可以引入随机梯度下降算法(Stochastic Gradient Descent, SGD),
其的更新规则如下: <span class="math display">\[
\theta_j:=\theta_j-\alpha(h(x^{(i)})-y^{(i)})x_j^{(i)},\ j=0,1,\dots,n\
(\text{for }i=1\ \text{to }m)\]</span> 此时,
每次更新我们都只用了一个训练样本的数据,
因此这样会大幅度减少更新计算量;操作过程是在第一次更新中,
我们选用第一个训练样本更新参数; 在第二次更新中,
我们选用第二个训练样本更新参数, 以此类推. 但值得注意的一点是,
随机梯度下降算法由于每次都是用一个训练样本的数据,
因此他的更新方向是不稳定的, 因此他可能会在极小值附近不断震荡;
但他优点就是每次迭代的计算量小, 尤其是在训练样本数据量很大的情况下,
他的优势就会更加明显. 不仅如此, 如果我们考虑较为复杂的优化问题,
随机梯度下降算法是有可能帮助我们跳出局部极小值,
因此随机算法对于机器学习是很重要的优化算法.</p>
<p>虽然SGD可能达不到最小值, 而是在最小值附近震荡,
但我们可以在某个容忍精度下停止迭代,这样得到的参数也是一个比较好的参数.
但实际上, 我们一般是在使用SGD的过程中, 随时间增长慢慢地减小学习率的值,
这样即使参数会在最小值附近震荡, 但随着学习率 <span
class="math inline">\(\alpha\)</span> 的减小, 参数的震荡范围越来越小,
近似认为达到了最小值.</p>
<p>最后, 我们给出另一个梯度下降算法的idea,
他结合了批量梯度下降算法和随机梯度下降算法的优点,
这就是小批量梯度下降算法(Mini-batch Gradient Descent).
他并不是每次迭代都只用一个训练样本的数据(会使得下降方向不稳定),也不用全部训练样本的数据(会使得计算量过大),
而是每次迭代用一小部分训练样本的数据, 他每次迭代都用 <span
class="math inline">\(k\)</span> 个训练样本的数据, 其既降低了计算量,
又保持了下降方向的稳定性. 至于 <span class="math inline">\(k\)</span>
的选取, 其一般是在算法运行之前人为选取的.</p>
<p>不过事实上, 如果成本函数 <span
class="math inline">\(J(\theta)\)</span> 的结构并不是很好的情况下,
那么会出现以下几种情况:</p>
<ol type="1">
<li>收敛到函数的局部最小值(local minimum), 而不是全局最小值(global
minimum).</li>
<li>收敛到函数的驻点(saddle point).</li>
<li>微分值接近于 <span class="math inline">\(0\)</span>
就停下来，但这里只是比较平缓，并不是极值点。</li>
</ol>
<p>但值得注意的是,我们在这里考虑线性回归问题,
其成本函数其实是一个二次函数, 因此他是不存在局部最小值和驻点的,
因此只要他能收敛, 那么就一定是收敛到全局最小值.</p>
<p><a id="org0d1c713"></a></p>
<h2 id="normal-equation">Normal Equation</h2>
<p>上面我们介绍的GD是一种迭代算法, 但实际上对于线性回归问题,
我们可以直接用代数的方法求解出最优参数向量 <span
class="math inline">\(\theta\)</span>, 这种方法被称之为正规方程(Normal
Equation). 但需要声明的是, 正规方程只适用于线性回归问题.
在推导正规方程以前, 我们先引入矩阵导数的记号: <span
class="math display">\[\begin{aligned}\nabla_{\theta}J(\theta)&amp;=\begin{pmatrix}\frac{\partial
J}{\partial \theta_0}\cdots \frac{\partial J}{\partial
\theta_n}\end{pmatrix}^T,\ \theta\in\mathbb{R}^{n+1}\\
\nabla_Af(A)&amp;=\begin{pmatrix}\frac{\partial f}{\partial
A_{11}}&amp;\cdots&amp;\frac{\partial f}{\partial A_{1q}}\\\vdots&amp;
&amp;\vdots\\\frac{\partial f}{\partial
A_{p1}}&amp;\cdots&amp;\frac{\partial f}{\partial A_{pq}}\end{pmatrix},\
A\in\mathbb{R}^{p\times q}\end{aligned}\]</span>
因此我们希望能够将成本函数 <span
class="math inline">\(J(\theta)\)</span> 写成紧凑的矩阵向量形式,
在此之前, 我们先引入一些矩阵符号来辅助推导成本函数的矩阵形式: <span
class="math display">\[\begin{aligned}X&amp;=\begin{pmatrix}\cdots&amp;(x^{(1)})^T&amp;\cdots\\
&amp;\vdots&amp; \\\cdots&amp;(x^{(m)})^T&amp;\cdots\end{pmatrix}
\text{design matrix}\\
\vec{y}&amp;=\begin{pmatrix}y^{(i)}&amp;\cdots&amp;y^{(m)}\end{pmatrix}^T
\text{label vector}\end{aligned}\]</span> 这里值得注意的是,
我们构造的这个 design matrix 的行向量在记号上是训练样本的转置,
但是实际上, 我们考虑的是训练样本的特征再加上虚特征 <span
class="math inline">\(x_0\)</span>, 所以这个 design matrix 的维度为
<span class="math inline">\(m\times (n+1)\)</span>. 依据这些记号,
我们给出成本函数的矩阵形式为: <span
class="math display">\[J(\theta)=\frac{1}{2}\sum_{i=1}^m(h(x^{(i)})-y^{(i)})^2=\frac{1}{2}(X\theta-\vec{y})^T(X\theta-\vec{y})\]</span>
由于我们知道线性回归问题的核心问题就是最小化成本函数,
这个从导数的角度来看, 就是成本函数对参数向量的导数为0; 其数学形式如下:
<span
class="math display">\[\nabla_{\theta}J(\theta)=\nabla_{\theta}\frac{1}{2}(X\theta-\vec{y})^T(X\theta-y)=X^TX\theta-X^T\vec{y}=0\]</span>
所以线性回归问题对应的正规问题为: <span
class="math display">\[X^TX\theta=X^T\vec{y}\Rightarrow
\theta=(X^TX)^{-1}X^T\vec{y}\]</span> 这里有一个问题就是如果 <span
class="math inline">\(X^{T}X\)</span> 不可逆, 那么 <span
class="math inline">\((X^TX)^{-1}\)</span> 并不存在, 那我们可以用 <span
class="math inline">\((X^TX)^{-1}\)</span> 的伪逆来代替.</p>
]]></content>
      <categories>
        <category>CS229</category>
      </categories>
      <tags>
        <tag>Computer Science</tag>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>Lecture series on graph theory 2</title>
    <url>/2022/03/28/Graph2/</url>
    <content><![CDATA[<p>First, we try to prove the Mantel's Theorem, which was presented as a
question in the last blog post.</p>
<p><strong>Thm(Mantel's Theorem)<br>Let G be a graph with n vertices. If
G does not contain a triangle, then</strong> <span
class="math display">\[
\lvert E(G)\rvert\leq\frac{n^2}{4}
\]</span> Before the proof begin, we introduce what triangle means.</p>
<span id="more"></span>
<p><img
src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220226/2022-03-29_220946.jpg" /></p>
<p><font color=red><span
class="math inline">\(C=v_1v_2v_3v_4v_5v_1\)</span> is a
5-cycle.Generally, k-cylce has k vertices.Specially, we call a 3-cycle
as a triangle</font></p>
<p>Now, let's take a few examples to find potential patterns which may
help to prove this theorem.</p>
<p><img
src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220226/63DEEBC1B5B34ABA2048219295C11EF6.jpg" /></p>
<p><font color=red>In general, we can divide n vertices into two groups,
then we add all edges between two groups.Because there is no edge
joining the vertices from the same side, if there is a cycle in graph,
it must be an even cycle, such as alternating left-hand and right-hand
sides.<br>If n is even, #edges=<span
class="math inline">\(\frac{n}{2}\cdot\frac{n}{2}=\frac{n^2}{4}\)</span>,
if n is odd, #edges=<span
class="math inline">\(\frac{n+1}{2}\cdot\frac{n-1}{2}=\frac{n^2-1}{4}\leq\frac{n^2}{4}\)</span></font></p>
<hr />
<p><strong>Proof of the Mantel's Theorem</strong></p>
<p>Let G be an n-vertex graph without a triangle.</p>
<p><img
src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220226/2022-03-29_225536.jpg" /></p>
<p><span class="math inline">\(\forall x,y\in V(G)\)</span>, if <span
class="math inline">\(xy\in E(G)\)</span>, <span
class="math inline">\(N_G(x)\cap N_G(y)=\emptyset\)</span> because G has
no triangle.</p>
<p>Because <span class="math inline">\(N_G(x)\cup N_G(y)\subset
V(G)\)</span>, <span class="math inline">\(d_G(x)+d_G(y)\leq
n\)</span></p>
<p>From the above formula, we have <span class="math display">\[
\sum_{xy\in E(G)}(d_G(x)+d_G(y))\leq\sum_{xy\in E(G)}n=n\cdot\lvert
E(G)\rvert \tag{1}
\]</span> <img
src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220226/2022-03-29_225550.4v4nzok1fwc0.jpg" /></p>
<p>We find that <span class="math inline">\(d_G(x)\)</span> appears in
<span
class="math inline">\(d_G(x)+d_G(y_1),d_G(x)+d_G(y_2),\dots,d_G(x)+d_G(y_{d_G(x)})\)</span>
<span class="math display">\[
So\ \sum_{xy\in E(G)}(d_G(x)+d_G(y))=\sum_{x\in V(G)}d_G(x)\cdot
d_G(x)=\sum_{x\in V(G)}d_G(x)^2\tag{2}
\]</span> From (1) &amp; (2), we have <span class="math display">\[
\sum_{x\in V(G)}d_G(x)^2\leq n\cdot\lvert E(G)\rvert\tag{3}
\]</span> According to the relationship between degree and edge: <span
class="math inline">\(\sum_{x\in V(G)}d_G(x)=2\lvert E(G)\rvert\)</span>
and the Cauchy-Schwarz inequality:<span
class="math inline">\((\sum_{k=1}^n a_k^2)(\sum_{k=1}^n
b_k^2)\geq(\sum_{k=1}^na_kb_k)^2\)</span>, we have <span
class="math display">\[
\sum_{x\in V(G)}d_G(x)^2\geq \frac{(\sum_{x\in
V(G)}d_G(x))^2}{n}=\frac{4\lvert E(G)\rvert^2}{n}\tag{4}
\]</span> From (3) &amp; (4), <span class="math inline">\(\frac{4\lvert
E(G)\rvert^2}{n}\leq \sum_{x\in V(G)}d_G(x)^2\leq n\cdot \lvert
E(G)\rvert\)</span> which implies <span class="math inline">\(\lvert
E(G)\rvert \leq\frac{n^2}{4}\)</span></p>
<hr />
<p>If a graph G has more than <span
class="math inline">\(\frac{n^2}{4}\)</span> edges, then G has a
triangle.</p>
<p><font color=red>Furthermore, we can extend the triangle to k-cycle
and obtain the Erdős-Gallai's Theorem <br>We can also extend the
triangle to a complete graph with k vetices, which are called k-clique
and obtain the Turán's Theorem</font></p>
<p>Tree: A tree is a connected graph without cycles.</p>
<p><strong>Proposition: Every tree with at least two vetices has at
least two vertices of degree one</strong></p>
<hr />
<p><strong>Proof</strong></p>
<p>Let P be the longest path of G. Then both end vertices of P have
degree one in G.If not, we suppose that <span
class="math inline">\(u,v\in V(P),\ uv\in E(P)\)</span> and u is the end
vertex of P, but <span class="math inline">\(d_G(u)&gt;1\)</span>.</p>
<p>Case 1:</p>
<p><img
src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220226/2022-04-04_204919.4qpcnrekreg0.jpg" /></p>
<p><span class="math inline">\(w\not\in V(P)\)</span> and <span
class="math inline">\(wu\in E(G)\)</span>,then <span
class="math inline">\(\tilde{P}=P+wu\)</span> is longer than P. This
contradicts the fact that P is the longest path.</p>
<p>Case 2:</p>
<p><img
src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220226/2022-04-04_204927.tn63688yr68.jpg" /></p>
<p><span class="math inline">\(w\in V(P),w\not=v\)</span> and <span
class="math inline">\(wu\in E(G)\)</span>, then we can find that there
is a cycle. This contradicts the fact that G is a tree.</p>
<hr />
<p>A vertex of a tree is a leaf if it has degree one.</p>
<p><strong>Proposition: A connected graph with n vertices is a tree if
and only if it has n-1 edges. </strong></p>
<hr />
<p><strong>Proof</strong></p>
<p><span class="math inline">\(\Rightarrow\)</span> n=1, G has no
edges.</p>
<p>Now, we assume that it is correct for a tree with n-1 vertices to
have n-2 edges.From this assumption, we want to deduce that a tree with
n vertices has n-1 edges.</p>
<p>Since <span class="math inline">\(n\ge2\)</span>, G has a vertex v of
degree one. Let u be the only neighbor of v in G. Because G is a tree
with n vertices, G-v is a tree with n-1 vertices. According to the
asssumption,<span class="math inline">\(\lvert
E(G-v)\rvert=(n-1)-1\)</span>. <span class="math display">\[
\lvert E(G)\rvert=\lvert E(G-v)\rvert+1=(n-1)-1+1=n-1
\]</span> <span class="math inline">\(\Leftarrow\)</span> Let G be a
connected graph with n vertices and n-1 edges. We claim that G has a
vertex of degree one.</p>
<p>We prove this claim first.If not, <span class="math inline">\(\forall
x\in V(G)\)</span>, assume <span
class="math inline">\(d_G(x)\ge2\)</span></p>
<p>Then we have <span class="math inline">\(\lvert
E(G)\rvert=\frac{1}{2}\sum_{x\in V(G)}d_G(x)\ge\frac{1}{2}\cdot2\lvert
V(G)\rvert=n&gt;n-1\)</span> which contradicts that <span
class="math inline">\(\lvert E(G)\rvert=n-1\)</span>. The contradiction
implies the claim holds.</p>
<p>From this claim, G has a vertex of degree one. Use the induction on
G-v. Since G-v has n-1 vertices and <span
class="math inline">\((n-1)-1\)</span> edges. By inductive hypothsis,
G-v is a tree and has no cycles.Since v is a degree one vertex, G has no
cycles. Therefore, G is a tree.</p>
<hr />
<p><strong>Corollary: Every graph with minimum degree at least two
contains a cycle.</strong></p>
<p>A spanning tree of G is a connected spanning subgraph of G without
cycles.</p>
<p><font color=red>Problem: counting the number of edge-disjoint
spanning trees in a graph.<br>If the number of edge-disjoint spanning
trees is large, the graph is well-connected. (Related to
edge-connectivity of the graph)</font></p>
<p>Now we introduce two classic search algorithms in graph theory.</p>
<p>A breadth-first-search tree of a graph (BFS-tree)</p>
<p><img src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220226/2022-04-05_111757.6pnsx44gbus0.jpg" style="zoom: 50%;" /></p>
<ol type="i">
<li><p>Start at <span class="math inline">\(x=x_0\)</span> and join x to
all neighbors of x, Let <span
class="math inline">\(N_1=N_G(x)\)</span></p></li>
<li><p>For each <span class="math inline">\(y\in N_i\)</span>, join y to
all neighbors of y without creating cycles and let <span
class="math inline">\(N_{i+1}=\cup_{y\in N_i}N_G(y)\)</span></p></li>
</ol>
<p>The algorithm will take <span class="math inline">\(O (\lvert
V\rvert+\lvert E\rvert)\)</span> steps to find a BFS-tree rooted at
<span class="math inline">\(x_0\)</span>.</p>
<p>A deepth-first-search tree of a graph (DFS-tree)</p>
<p><img src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220226/微信图片_20220405111924.6g6tlxqwfto0.jpg" style="zoom:15%;" /></p>
<ol type="i">
<li><p>Start at <span class="math inline">\(x=x_0\)</span> and <span
class="math inline">\(T_0=\{x_0\}\)</span></p></li>
<li><p>Join x to one of its neighbor <span class="math inline">\(x_1\in
N_G(x_0)\)</span> and<span
class="math inline">\(T_1=\{x_0,x_1\}\)</span></p></li>
<li><p>If <span class="math inline">\(N_i=N_G(x_i)\backslash
T_i\not=\emptyset\)</span>, then join <span
class="math inline">\(x_i\)</span> to a vertex <span
class="math inline">\(x_{i+1}\in N_i\)</span> and let <span
class="math inline">\(T_{i+1}=T_i\cup\{x_{i+1}\}\)</span> and <span
class="math inline">\(x_{i+1}\to x_i\)</span></p></li>
</ol>
<p>If <span class="math inline">\(N_i=N_G(x_i)\backslash
T_i=\emptyset\)</span>, then set <span class="math inline">\(x_{i-1}\to
x_{i}\)</span> and <span
class="math inline">\(N_{i-1}=N_G(x_{i-1})\backslash T_i\to N_i\)</span>
and continue.</p>
<p>Eulerian graph:</p>
<p><font color=red>Problem: Let G be a graph.When does G have a closed
trail which contains all edges of G?</font></p>
<p>A closed trail is Eulerian if the trail go through all edges of G. A
graph is called Eulerian if it has an Eulerian trail.</p>
<p><strong>Proposition: Every Eulerian graph is a connected graph which
has only even-degree vertices</strong></p>
<hr />
<p><strong>Proof</strong> Let G be an Eulerian graph. Then G has an
Eulerian trail, denoted by <span
class="math inline">\(T=v_1e_1v_2e_2\cdots v_me_mv_1\)</span>. So G is
connected.</p>
<p>Now, orient the edges of G along the trail T such that, for an edge
<span class="math inline">\(e_i\)</span> in T, orient <span
class="math inline">\(e_i\)</span> from <span
class="math inline">\(v_i\)</span> to <span
class="math inline">\(v_{i+1}\)</span>. Since T has no repeated edges,
every edge receives exactly one orientation. For each vertex <span
class="math inline">\(v_i\)</span>, T visits <span
class="math inline">\(v_i\)</span> and then leaves <span
class="math inline">\(v_i\)</span>, which implies <span
class="math display">\[
\# edges\ oriented\ towards\ v_i=\#edges\ oriented\ away\ from\ v_i
\]</span> But the degree of <span class="math inline">\(v_i\)</span>
satisfies <span class="math display">\[
\begin{aligned}
d_G(v_i)&amp;=\# edges\ oriented\ towards\ v_i+\#edges\ oriented\ away\
from\ v_i\\
&amp;\equiv0(mod\ 2)
\end{aligned}
\]</span> So every vertex of G has an even degree.</p>
<hr />
<p>A cycle decomposition D of a graph G is a set of egde-disjoint cycles
<span class="math inline">\(D=\{C_1,C_2,\dots,C_k\}\)</span> such
that<br />
<span class="math display">\[
\cup_{C_i\in D}E(C_i)=E(G)
\]</span> <strong>Proposition: Every even graph has a cycle
decomposition.</strong></p>
<hr />
<p><strong>Proof</strong> Let G be an even graph. Suppose to the
contrary that G does not have a cycle decomposition.</p>
<p>Assume G is a minimal counterexample.If G has a vertex v of degress
zero, the G-v is a subgraph of G and hence is not a counterexample. So
G-v has a cycle decomposition. So does G, a contradiction to that G is a
counterexample.</p>
<p>So assume that<span class="math inline">\(\delta(G)\ge2\)</span>.
Then by corollary, G has a cycle C. Then, G-E(C) is an even subgraph of
G. So G-E(C) has a cycle decomposition D. Then, <span
class="math inline">\(D\cup\{C\}\)</span> is a cycle-decomposition of G,
which contradicts that G is a counterexample. So prop. holds.</p>
<hr />
<p><font color='red'>Corollary: Every Eulerian graph has a cycle
decomposition.</font></p>
<p><font color='red'>（conjecture,Hajos,1968）All Eulerian graph with n
vertex. How many cycles in a cycle decomposition D?<span
class="math inline">\(\lvert
D\rvert\le\frac{n-1}{2}\)</span>?</font></p>
]]></content>
      <categories>
        <category>Graph Theory</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Operation Research</tag>
      </tags>
  </entry>
  <entry>
    <title>Lecture series on graph theory 3</title>
    <url>/2022/05/20/Graph3/</url>
    <content><![CDATA[<p>Given a graph G, <span class="math inline">\(T=\{v|d_G(v)\equiv1\
mod\ 2\}\)</span>, a subgraph P is called a parity subgraph if <span
class="math display">\[
d_P(v)\equiv\left\{
\begin{aligned}
&amp;0\ mod\ 2,\ v\not\in T\\
&amp;1\ mod\ 2,\ v\in T
\end{aligned}
\right.\qquad i.e.\ d_P(v)\equiv d_G(v)
\]</span> <span class="math inline">\(G-E(P)\)</span> is an even
subgraph <font color='red'>( i.e. every vertex of G-E(P) has even
degree)<br>Problem: To find a parity subgraph with the minimum number of
edges.</font></p>
<span id="more"></span>
<p>More general, let <span class="math inline">\(T\subset V(G)\)</span>,
a set of edges <span class="math inline">\(J\)</span> is called a <span
class="math inline">\(T\)</span>-join if all the edges of <span
class="math inline">\(J\)</span> induce a subgraph, s.t. <span
class="math inline">\(d_J(v)\equiv1\ mod\ 2\Leftrightarrow v\in
T\)</span>, <font color='red'>A parity subgraph of G is a <span
class="math inline">\(T\)</span>-join of G where <span
class="math inline">\(T=\{v|d_G(v)\equiv1\ mod\ 2\}\)</span><br>Problem:
To find a <span class="math inline">\(T\)</span>-join with the minimum
number of edges.</font></p>
<p><strong>Bipartite Graph</strong></p>
<p>A graph is bipartite if its vertex set can be partitioned into two
sets X and Y such that every edge of G joins a vertex of X and a vertex
of Y.</p>
<p><font color='red'>For example.</font></p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220226/2022-05-22_185717.5b3liqdtj4g0.jpg"
alt="2022-05-21_121856" />
<figcaption aria-hidden="true">2022-05-21_121856</figcaption>
</figure>
<p><strong>Proposition. A graph is bipartite <span
class="math inline">\(\Leftrightarrow\)</span> it has no odd
cycles</strong></p>
<hr />
<p><strong>Proof</strong></p>
<p><span class="math inline">\(\Rightarrow\)</span> Let <span
class="math inline">\(G\)</span> be a bipartite graph and let <span
class="math inline">\((X,Y)\)</span> be a bipartition of <span
class="math inline">\(G\)</span>. Color vertices in X by red and
vertices in Y by blue. Let <span class="math inline">\(C\)</span> be a
cycle. Then the red vertices and blue vertices appear alternatively on
<span class="math inline">\(C\)</span>. So <span
class="math inline">\(C\)</span> has an even number of vertices.
Therefore, <span class="math inline">\(G\)</span> has no odd cycles.</p>
<p><span class="math inline">\(\Leftarrow\)</span> Let v be a vertex of
<span class="math inline">\(G\)</span>. Let <span
class="math inline">\(X=\{x|d_G(x,v)\equiv0(mod\ 2)\}\)</span> and <span
class="math inline">\(Y=\{y|d_G(y,v)\equiv 1(mod\ 2)\}\)</span></p>
<p>Since <span class="math inline">\(G\)</span> has no odd cycle, there
is no edges joining two vertices from the same part. So G is
bipartite.</p>
<hr />
<p><font color='red'>Every part in the bipartition induce the graph
without edges.</font></p>
<p>A vertex subset <span class="math inline">\(I\)</span> of <span
class="math inline">\(V(G)\)</span> is independent if <span
class="math inline">\(G\)</span> has no edges joining any two vertices
of <span class="math inline">\(I\)</span>.</p>
<p>The maximum cardinality of independent sets is called the independent
number of <span class="math inline">\(G\)</span>.</p>
<p><font color='red'>Problem: Determine the independent number of a
given graph <span class="math inline">\(G\)</span> (NPC)</font></p>
<p>If G is bipartite, the its independent number <span
class="math inline">\(\alpha(G)\geq\frac{n}{2}\)</span>.</p>
<p><font color='red'><strong>(The Four color problem) Every graph drawn
on the plane without crossing edges has a vertex partition into four
independent sets.<br>According to the above, if G is a plane graph,
<span class="math inline">\(\alpha(G)\geq\frac{\lvert
V(G)\rvert}{4}\)</span></strong></font></p>
<hr />
<p><strong>Second Proof of the Mantel's Theorem</strong></p>
<p><font color='red'>Recall: Let G be an n-vertex graph without
triangle, then <span class="math inline">\(\lvert
E(G)\rvert\leq\frac{n^2}{4}\)</span></font></p>
<p>Let x be a vertex of G such that <span
class="math inline">\(d_G(x)=\Delta(G)\)</span>. So <span
class="math inline">\(N_G(x)\)</span> is an independent set of G. <span
class="math display">\[
\lvert E(G)\rvert\leq\sum_{y\not\in N_G(x)}d_G(y)\leq(n-d_G(x))\Delta
(G)=(n-d_G(x))d_G(x)\leq\frac{n^2}{4}
\]</span> and equality holds <span class="math inline">\(\Leftrightarrow
n-d_G(x)=d_G(x),\ i.e.\ d_G(x)=\frac{n}{2}\)</span></p>
<hr />
<p><strong>Degenerated Graph</strong></p>
<p>A graph G is k-degenerate if every subgraph of G has a vertex of
degree at most k. <font color='red'>A tree is 1-degenerate</font></p>
<p>A graph G is k-colorable if the vertex of G can be colored by k
different colors such that any vertex subset with same color is an
independent set. i.e. the vertex set of G can be partitioned into k
independent subsets.</p>
<p><strong>Proposition: A k-degenerated graph is
(k+1)-colorable</strong></p>
<hr />
<p><strong>Proof.</strong> Let G be k-degenerate graph. Then G has a
vertex v of degree at most k.</p>
<p>Use induction on the number of vertex.</p>
<p>The inductive hypothesis implies that <span
class="math inline">\(G-v\)</span> is (k+1)-colorable. All vertices in
<span class="math inline">\(N_G(x)\)</span> have been colored by at most
k different colors in any (k+1)-coloring of G-v. Then color v by the
(k+1)th color. So G is (k+1)-colorable.</p>
<hr />
<p><font color='red'>1-factor is a spanning subgraph in which every
vertex has degree one.</font></p>
<p><font color='red'>1-degenerate graph is a tree(or a
forest)</font></p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220226/2022-05-21_190614.g013sfif35c.jpg"
alt="2022-05-21_190614" />
<figcaption aria-hidden="true">2022-05-21_190614</figcaption>
</figure>
<p><strong>Corollary. Every graph G is <span
class="math inline">\((\Delta(G)+1)\)</span>-degenerate</strong></p>
<p><strong>Def. A Planar graph is a graph with a drawing on the plane
<span class="math inline">\(\mathbb{R}^2\)</span></strong> . A connected
region of <span class="math inline">\(\mathbb{R}^2-G\)</span> is a face
of G.</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220226/2022-05-21_191223.3jzn0lp4vyg0.jpg"
alt="2022-05-21_191223" />
<figcaption aria-hidden="true">2022-05-21_191223</figcaption>
</figure>
<p><strong>Thm(Euler Formula) Let G be a planar graph, and let n,m and f
be the numbers of vertex,edges and faces of G, Then </strong> <span
class="math display">\[
n-m+f=2
\]</span> <strong>Proposition. Every planar graph is
5-degenerate</strong></p>
<hr />
<p><strong>Proof.</strong> Let G be a planar graph. It suffices to show
that G has a vertex of degree at most five. Without loss of generality,
assume that G is a maximal planar graph (<font color='red'>i.e. every
face is bounded by a triangle</font>). Otherwise, we can add edges to G
to keep it to be a planar graph.</p>
<p>Since every edge appears on the boundaries of two faces and every
face contains exactly three edges, it follows that <span
class="math display">\[
3f=2m\Rightarrow f=\frac{2}{3}m
\]</span> Let <span class="math inline">\(\delta=\delta(G)\)</span>, the
minimum degree of G, then <span class="math display">\[
\delta n\leq\sum_{x\in V(G)}d_G(x)=2m\Rightarrow n\leq\frac{2}{\delta}m
\]</span> By Euler's Formula: <span
class="math inline">\(n-m+f=2\)</span> <span class="math display">\[
2=n-m+\frac{2}{3}m\leq(\frac{2}{\delta}-\frac{1}{3})m
\]</span> Therefore, <span
class="math inline">\(\frac{2}{\delta}-\frac{1}{3}&gt;0\Rightarrow
\delta&lt;6\Leftrightarrow \delta\leq5\)</span></p>
<p>Every planar graph has a vertex of degree at most 5, which implies a
planar graph is 5-degenerate.</p>
<hr />
<p><strong>Corollary. Every planar graph is 6-colorable.</strong></p>
<p><font color='red'>Actually we can use Kempe chain to prove the
proposition that every planar graph is 5-colorable.<br>Problem:What kind
of Eulerian graphs having an even-cycle
decomposition?<br>Conjecture(Akiyama,1980s) Every planar graph with n
vertices has an induced 2-degenerate graph with at least n/2
vertices.<br>Conjecture(Albertson&amp;Berman,1970s) Every planar graph
with n vertices has an induced 1-degenerate graph with at least n/2
vertices.</font></p>
<p><strong>Matrices and Graphs</strong></p>
<p><img
src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220226/2022-05-21_235307.fn17ct60tvc.jpg" /></p>
<p><font color='red'>A is a symmetric matrix and because we only
consider simple graphs, its diagonal elements are all zero.</font></p>
<p><img
src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220226/2022-05-21_235516.2htdkwuxlpy0.jpg" /></p>
<p>A square matrix A is symmetric if <span
class="math inline">\(A^T=A\)</span></p>
<p>A scalar <span class="math inline">\(\lambda\)</span> is eigenvalue
of A if there exists a non-zero vector <span
class="math inline">\(\vec{X}\)</span>, s.t. <span
class="math inline">\(A\vec{X}=\lambda\vec{X}\)</span> and <span
class="math inline">\(\vec{X}\)</span> is called an eigenvector of A
with respect to <span class="math inline">\(\lambda\)</span>.</p>
<p>A basis <span class="math inline">\(B\)</span> of a vector space is
orthonormal if <span class="math inline">\(||\vec{X}||=1\)</span> for
any <span class="math inline">\(\vec{X}\in B\)</span>, and <span
class="math inline">\(&lt;\vec{X_1},\vec{X_2}&gt;=0\)</span> for any
<span class="math inline">\(\vec{X_1},\vec{X_2}\in B\)</span></p>
<p><strong>Thm. Let A be a real symmetric <span
class="math inline">\((n\times n)\)</span>-matrix. Then A is a
diagonizable and <span class="math inline">\(\mathbb{R}^n\)</span> has
orthonormal basis of eigenvectos of A</strong> <span
class="math display">\[
A\sim\left(\begin{matrix}
   \lambda_1 &amp; \dots &amp;0\\
   \vdots &amp; \ddots &amp;\vdots\\
   0 &amp; \dots &amp;\lambda_n\\
  \end{matrix}\right)
\]</span></p>
<p><strong>Proposition. All eigenvalues of a real symmetric <span
class="math inline">\((n\times n)\)</span>-matrix is real</strong></p>
<hr />
<p><strong>Proof</strong> We assume that A is a <span
class="math inline">\(n\times n\)</span> matrix, <span
class="math inline">\(\lambda\)</span> is an eignevalue of A.</p>
<p>Assume that <span class="math inline">\(\vec{X}\)</span> is an
eigenvector of <span class="math inline">\(\lambda\)</span>, Then <span
class="math display">\[
\begin{aligned}
\lambda||\vec{X}||&amp;=&lt;\lambda\vec{X},\vec{X}&gt;=&lt;A\vec{X},\vec{X}&gt;=\vec{X^T}A\vec{X}\\&amp;=\vec{X^T}A^T\vec{X}=(A\vec{X})^T\vec{X}=&lt;\vec{X},A\vec{X}&gt;=\bar{\lambda}||\vec{X}||
\end{aligned}
\]</span> So <span
class="math inline">\(\lambda=\bar{\lambda}\Rightarrow\lambda\)</span>
is real.</p>
<hr />
<p>A real symmetric matrix A is positive semi-definite if ,for all <span
class="math inline">\(\vec{X}\in\mathbb{R}^n\)</span>, <span
class="math inline">\(\vec{X}^TA\vec{X}\geq0\)</span> and A is positive
definite if <span
class="math inline">\(\vec{X}^TA\vec{X}&gt;0\)</span></p>
<p><strong>Proposition. All eigenvalues of a positive semi-definite
<span class="math inline">\(\Leftrightarrow\ \exists\)</span> a matrix
B, s.t. <span class="math inline">\(A=B^TB\)</span></strong></p>
<hr />
<p><strong>Proof.</strong><span
class="math inline">\(\Rightarrow\)</span> We assume that A is a
positive semi-definite matrix.</p>
<p>Then A is diagonaizable and assume that <span
class="math inline">\(A=Q^TDQ\)</span> where D is a diagonable matrix
with eigenalues on its diagonal. Note that all egienvalues of A are
non-negative. <span class="math display">\[
A=Q^TDQ=Q^TD^{\frac{1}{2}}D^\frac{1}{2}Q=(\sqrt{D}Q)^T(\sqrt{D}Q)=B^TB,\quad
where\ B=\sqrt{D}Q
\]</span> <span class="math inline">\(\Leftarrow\)</span> Let <span
class="math inline">\(A=B^TB\)</span>.</p>
<p>Then for any <span
class="math inline">\(\vec{X}\in\mathbb{R}^n\)</span>, <span
class="math inline">\(\vec{X}^TA\vec{X}=\vec{X}^TB^TB\vec{X}=(B\vec{X})^TB\vec{X}=||B\vec{X}||\geq0\)</span></p>
<p>So A is positive semi-definite.</p>
]]></content>
      <categories>
        <category>Graph Theory</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Operation Research</tag>
      </tags>
  </entry>
  <entry>
    <title>Lecture series on graph theory 4</title>
    <url>/2022/05/22/Graph4/</url>
    <content><![CDATA[<p><strong>Proposition. The adjacency matrix of a graph is a real
symmetric matrix.</strong></p>
<span id="more"></span>
<p><img
src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220226/2022-05-22_131847.16yosr9l8xs0.jpg" /></p>
<p><font color='red'>Here we broefly discuss the topic of random
matrices.<br>Probability of adjacent connection between <span
class="math inline">\(R_j\)</span> and <span
class="math inline">\(C_j\)</span>, <span
class="math inline">\(P(R_j\sim C_j)=\frac{1}{2}\)</span>, <span
class="math inline">\(\ P(R_j\not\sim C_j)=\frac{1}{2}\)</span></font>
<span class="math display">\[
P(A(G)\ is \ invertible)=P(M\ is\ invertible)
\]</span> <strong>Thm Let G be a graph. The number of walks from <span
class="math inline">\(v_i\)</span> to <span
class="math inline">\(v_j\)</span> of length k is equal to the <span
class="math inline">\((i,j)\)</span>-entry of <span
class="math inline">\((A(G))^k\)</span></strong></p>
<hr />
<p><strong>Proof</strong></p>
<p>Let <span class="math inline">\(A(G)=(a_{ij})_{n\times n}\)</span>.
Then <span class="math inline">\((i,j)\)</span>-entry of <span
class="math inline">\((A(G))^k\)</span> is given by <span
class="math display">\[
[(A(G))^k]_{ij}=\sum a_{ii_1}a_{i_1i_2}\cdots a_{i_{k-1}j}
\]</span> where the sum ranges over all sequences <span
class="math inline">\((i_1,i_2,\dots,i_{k-1})\)</span> with <span
class="math inline">\(i_t\in[n]=\{1,2,\dots,n\}\)</span> <span
class="math display">\[
\begin{aligned}
(A(G))^2_{ij}&amp;=(A(G)\cdot
A(G))_{ij}=\sum_{i_1=1}^na_{ii_1}a_{i_1j}\\
(A(G))^3_{ij}&amp;=((A(G))^2\cdot
A(G))_{ij}=\sum_{i_2=1}^n(\sum_{i_1=1}^na_{ii_1}a_{i_1i_2})a_{i_2j}=\sum_{i_1,i_2=1}^{n}a_{ii_1}a_{i_1i_2}a_{i_2j}\\
\end{aligned}
\]</span> By the definition of adjacency matrix, <span
class="math inline">\(a_j=1\Leftrightarrow v_iv_j\in E(G)\)</span></p>
<p>It follows that the summand <span
class="math inline">\(a_{ii_1}a_{i_1i_2}\cdots a_{i_{k-1}j}\)</span> is
1 <span class="math inline">\(\Leftrightarrow\ v_iv_{i_1}v_{i_2}\cdots
v_{i_{k-1}}v_j\)</span> is a walk of length k. Hence the summing over
all <span class="math inline">\((i_1,\cdots,i_{k-1})\)</span> just gives
the total number of walks of length k from <span
class="math inline">\(v_i\)</span> to <span
class="math inline">\(v_j\)</span></p>
<hr />
<p>A(G) is <span class="math inline">\(n\times n\)</span> symmetric
matrix. All n eigenvalues of A(G) are real. Assume the n eigenvalues
satisfy <span class="math display">\[
\lambda_1\geq\lambda_2\geq\cdots\geq\lambda_n
\]</span> <font color='red'>Note that <span
class="math inline">\(\lambda_1+\lambda_2+\cdots+\lambda_n=0\)</span>,some
eigenvalues could be negative.<br>If G is a bipartite graph, the
eigenvalues are symmetric about origin.</font></p>
<p><strong>Thm Let G be a graph with eigenvalues <span
class="math inline">\(\lambda_1,\cdots,\lambda_n\)</span>. Then the
number of closed walks in G of length k is given by</strong> <span
class="math display">\[
w_G(k)=\lambda_1^k+\cdots+\lambda_n^k
\]</span></p>
<hr />
<p><strong>Proof</strong></p>
<p>Let G be a graph with adjacency matrix A(G). Then it follows from the
above theorem that <span class="math display">\[
w_G(k)=\sum_{i=1}^n[(A(G))^k]_{ii}=tr(A(G)^k)
\]</span> Since A(G) has <span class="math inline">\(\lambda_i\)</span>
as an eigenvalue with <span
class="math inline">\(i\in\{1,2,\cdots,n\}\)</span>, the matrix <span
class="math inline">\(A(G)^k\)</span> has eigenvalue <span
class="math inline">\(\lambda_i^k\)</span>for <span
class="math inline">\(i\in\{1,2,\cdots,n\}\)</span></p>
<p><font color='red'><span
class="math inline">\(A(G)\vec{v_i}=\lambda_i\vec{v_i},\quad
A(G)^k\vec{v_i}=A(G)^{k-1}A(G)\vec{v_i}=A(G)^{k-1}\lambda\vec{v_i}=\lambda_i^k\vec{v_i}\)</span></font></p>
<p>Then, <span
class="math inline">\(tr(A(G)^k)=\sum_{i=1}^n\lambda_i^k\)</span>, so
<span
class="math inline">\(w_G(k)=tr(A(G)^k)=\sum_{i=1}^n\lambda_i^k\)</span></p>
<hr />
<p><strong>Incidence matrix and Laplacian matrix</strong></p>
<p>Let G be a graph s.t. <span
class="math inline">\(V(G)=\{v_1,v_2,\cdots,v_n\}\)</span> and <span
class="math inline">\(E(G)=\{e_1,e_2,\cdots,e_m\}\)</span> <span
class="math display">\[
B(G)=(b_{ij})_{n\times m}\ where\
b_{ij}=\left\{\begin{aligned}&amp;1\quad v_i\ is\ incident\ with\ e_j\\
&amp;0\quad v_i\ isn&#39;t\ incident\ with\ e_j\end{aligned}\right.
\]</span> <img
src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220226/2022-05-22_162156.x0o95v76evk.jpg" /></p>
<p><font color='red'>We can find that evey column has two non-zero
entries.</font></p>
<p><img
src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220226/2022-05-22_162610.6c5zcmwtfbc0.jpg" /></p>
<p><font color='red'>We can find that each column of <span
class="math inline">\(\vec{B}\)</span> has one entry of 1, one entry of
-1 and other entry of 0.Therefore, add all entries in column and get
0</font></p>
<p><img
src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220226/2022-05-22_163017.jpg" /></p>
<p><span class="math inline">\(D(G)\)</span> is a diagonal matrix whose
diagonal entries are the degrees of vertices.</p>
<p>Laplacian matrix of G: <span class="math inline">\(L(G)=
D(G)-A(G)=\vec{B}\cdot\vec{B}^T\)</span></p>
<p><strong>Proposition. Let G be a graph. Then L(G) is positive
semi-definite and consequently, all eigenvalues of L(G) are real and
non-negative.</strong> <span class="math display">\[
\beta_1\geq\beta_2\geq\cdots\geq\beta_n\geq0
\]</span> <span class="math inline">\(\tau(G)\)</span>= the total number
of spanning trees in G.</p>
<p><strong>Thm(Matrix Tree Theorem) Let G be a graph with vertices <span
class="math inline">\(v_1,\dots,v_n\)</span>. Then <span
class="math inline">\(\tau(G)=det(L_0(G))\)</span> where <span
class="math inline">\(L_0(G)\)</span> is obtained from <span
class="math inline">\(L(G)\)</span> by deleting the i-th row and i-th
column for any <span
class="math inline">\(i\in[n]=\{1,2,\dots,n\}\)</span></strong></p>
<hr />
<p><strong>Proof.</strong></p>
<p><img
src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220226/2022-05-22_174049.4vsowf7szwq0.jpg" /></p>
<p>If T is a spanning tree, either <span class="math inline">\(e\in
T\)</span> or <span class="math inline">\(e\not\in T\)</span>.</p>
<p>An edge e of G is said to be contracted if it is deleted and its ends
are identified, the resulting graph is denoted by <span
class="math inline">\(G\cdot e\)</span>.</p>
<p><img
src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220226/2022-05-22_174508.6er13gzch2o0.jpg" /></p>
<p>If <span class="math inline">\(e\not\in T\)</span>, T is a spanning
tree of G-e; if <span class="math inline">\(e\in T\)</span>, <span
class="math inline">\(T\cdot e\)</span> is a spanning tree of <span
class="math inline">\(G\cdot e\)</span>.</p>
<p>Therefore, <span class="math inline">\(\tau(G)=\tau(G-e)+\tau(G\cdot
e)\)</span></p>
<p>Use induction on the number of edges of G.</p>
<p>If G has no edges and n=1, so <span
class="math inline">\(\tau(G)=1=det(L_0(G))\)</span> where <span
class="math inline">\(L_0(G)\)</span> is a <span
class="math inline">\(0\times 0\)</span> matrix with determinant 1 by
convenience.</p>
<p>If <span class="math inline">\(n&gt;1\)</span>, then <span
class="math inline">\(\tau(G)=0\)</span>, and <span
class="math inline">\(L_0(G)\)</span> is a 0-matrix in which every entry
is 0. So <span class="math inline">\(\tau(G)=det(L_0(G))\)</span> .</p>
<p>Therefore, the statement holds for <span
class="math inline">\(|E(G)|=0\)</span>.</p>
<p>Assume the statement holds all graph with number of edges less than
<span class="math inline">\(|E(G)|\)</span>.</p>
<p>By recordering the vertices of G, we may assume that <span
class="math inline">\(i=1\)</span> and <span
class="math inline">\(v_1v_2\in E(G)\)</span>, Let <span
class="math inline">\(e=v_1v_2\)</span>. Then <span
class="math inline">\(\tau(G)=\tau(G-e)+\tau(G\cdot e)\)</span>.</p>
<p>By inductive hypothesis, <span
class="math inline">\(\tau(G-e)=det(L_0(G-e))\)</span> and <span
class="math inline">\(\tau(G\cdot e)=det(L_0(G\cdot e))\)</span>.</p>
<p>Assume <span
class="math inline">\(L_0(G)=\begin{pmatrix}d_2&amp;P\\P^T&amp;R\end{pmatrix}\)</span>
obtained from <span
class="math inline">\(L(G)=\left(\begin{array}{c:c:c}d_1&amp;1&amp;\cdots\\\hdashline1&amp;d_2&amp;P\\\hdashline\vdots&amp;P^T&amp;R\end{array}\right)\)</span>
by deleting the first row and the first column.</p>
<p>Then <span
class="math inline">\(L_0(G-e)=\begin{pmatrix}d_2-1&amp;P\\P^T&amp;R\end{pmatrix}\)</span>
and <span class="math inline">\(L_0(G\cdot e)=R\)</span></p>
<p>Note that <span
class="math inline">\(L_0(G)=L_0(G-e)+\begin{pmatrix}1&amp;\vec{0}\\\vec{0}^T&amp;R\end{pmatrix}\)</span></p>
<p>Using the Laplace expansion along the first row, <span
class="math display">\[
det(L_0(G))=det(L_0(G-e))+det(L_0(G\cdot e))=\tau(G-e)+\tau(G\cdot
e)=\tau(G)
\]</span></p>
<hr />
<p><strong>Thm Let G be a connected graph with n vertices. Suppose that
the eigenvalues of L(G) are <span
class="math inline">\(\mu_1\geq\mu_2\geq\cdots\geq\mu_{n-1}\geq\mu_n=0\)</span>.
Then</strong> <span class="math display">\[
\tau(G)=\frac{1}{n}\mu_1\mu_2\cdots\mu_{n-1}
\]</span></p>
<hr />
<p><strong>Proof</strong></p>
<p>Let <span class="math inline">\(L(G)\)</span> be the Laplacian matrix
and let <span class="math display">\[
det(L(G)-\lambda
I)=(\mu_1-\lambda)(\mu_2-\lambda)\cdots(\mu_n-\lambda)=-\lambda(\mu_1-\lambda)(\mu_2-\lambda)\cdots(\mu_{n-1}-\lambda)
\]</span> So the cofficient of <span
class="math inline">\(\lambda\)</span> term is <span
class="math inline">\(-\mu_1\mu_2\cdots\mu_{n-1}\)</span>. Note that,
consider <span class="math inline">\(L(G)-\lambda I\)</span>.</p>
<p>Add all rows of <span class="math inline">\(L(G)-\lambda I\)</span>
except the first row to the first row, and let <span
class="math inline">\(M(\lambda)\)</span> be the new resulting
matrix.</p>
<p>Then <span class="math inline">\(det(M(\lambda))=det(L(G)-\lambda
I)\)</span> and the first row of <span
class="math inline">\(M(\lambda)=[-\lambda,-\lambda,\cdots,-\lambda]\)</span>.</p>
<p>Let <span class="math inline">\(N(\lambda)\)</span> be the resulting
matrix obtained from <span class="math inline">\(M(\lambda)\)</span> by
factoring out <span class="math inline">\(-\lambda\)</span>.</p>
<p>Then <span class="math inline">\(M(\lambda)=-\lambda
N(\lambda)\)</span> and <span
class="math inline">\(det(M(\lambda))=-\lambda det(N(\lambda))\)</span>,
So <span class="math display">\[
det(L(G)-\lambda I)=-\lambda det(N(\lambda))
\]</span> Therefore, the cofficient of <span
class="math inline">\(\lambda\)</span> term in <span
class="math inline">\(det(L(G)-\lambda I)\)</span>is equal to <span
class="math inline">\(-det(N(0))\)</span>.</p>
<p>Add all columns of <span class="math inline">\(N(0)\)</span> except
the first column to the first column.</p>
<p><font color='red'>(Note that <span
class="math inline">\(i^{th}\)</span>-row <span
class="math inline">\((i&gt;1)\)</span> of <span
class="math inline">\(N(0)\)</span> is the same as the  <span
class="math inline">\(i^{th}\)</span>-row <span
class="math inline">\((i&gt;1)\)</span> of <span
class="math inline">\(L(G)\)</span></font></p>
<p>Then the first column of the new matrix is <span
class="math inline">\(\left[\begin{matrix}n&amp;0&amp;0&amp;\cdots&amp;0\end{matrix}\right]^T\)</span>.</p>
<p>Use Laplace expansion along the <span
class="math inline">\(1^{st}\)</span> column, <span
class="math inline">\(det(N(0))=n\cdot det(L_0(G))\)</span> <span
class="math display">\[
n\cdot det(L_0(G))=(-1)\cdot(-\mu_1\mu_2\cdots\mu_{n-1})\Rightarrow
det(L_0(G))=\frac{1}{n}\mu_1\mu_2\cdots\mu_{n-1}
\]</span> By previous theorem, <span class="math display">\[
\tau(G)=\frac{1}{n}\mu_1\mu_2\cdots\mu_{n-1}
\]</span></p>
<hr />
]]></content>
      <categories>
        <category>Graph Theory</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Operation Research</tag>
      </tags>
  </entry>
  <entry>
    <title>Lecture series on graph theory 5</title>
    <url>/2022/05/22/Graph5/</url>
    <content><![CDATA[<p>Let G be a finite graph. We consider a random walk on the vertices of
G of the following type. Start at a vertex <span
class="math inline">\(v\)</span> .<font color='red'>(v could be chosen
randomly according to some probably distribution or could be specified
in advance).</font> Among all edges incident to v, choose one uniformly
at random<font color='red'>( i.e. if <span
class="math inline">\(d_G(v)=d\)</span>, each of these edges is chosen
with probability 1/d)</font></p>
<p><strong>Problem: determine the probability of being at a given vertex
after a given number steps.</strong></p>
<span id="more"></span>
<p>Let M(G) be the matrix whose rows and columns are indexed by vertices
<span class="math inline">\(v_1,\dots,v_n\)</span>, we assume that <span
class="math inline">\(m_{ij}\)</span> is the <span
class="math inline">\((i,j)\)</span>-entry of M(G), which satisfies the
following formula <span class="math display">\[
m_{ij}=\frac{a_{ij}}{d_i}
\]</span> where <span class="math inline">\(a_{ij}\)</span> is the
number of edges between <span class="math inline">\(v_i\)</span> and
<span class="math inline">\(v_j\)</span>. The <span
class="math inline">\(m_{ij}\)</span> is probability that if one starts
at <span class="math inline">\(v_i\)</span> and then the next step will
be at <span class="math inline">\(v_j\)</span>.</p>
<p><font color='red'>Recall: the number of k-walks from <span
class="math inline">\(v_i\)</span> to <span
class="math inline">\(v_j\)</span>= the <span
class="math inline">\((i,j)\)</span>-entry of <span
class="math inline">\(A(G)^k\)</span></font></p>
<p><span class="math inline">\(\exists v_ie_1v_{i_1}e_2v_{i_2}\cdots
e_kv_j,\ P(v_ie_1v_{i_1}e_2v_{i_2}\cdots
e_kv_j)=\frac{a_{ii_1}}{d_i}\frac{a_{i_1i_2}}{d_{i_1}}\cdots\frac{a_{i_{k-1}i_j}}{d_{i_{k-1}}}=m_{ii_1}m_{i_1i_2}\cdots
m_{i_{k-1}j}\)</span> <span class="math display">\[
\begin{aligned}
P(v_i\to v_j\ in\ k\ steps)&amp;=\sum_{k-walk\ from\ v_i\to v_j}
P(v_ie_1v_{i_1}e_2v_{i_2}\cdots e_kv_j)\\
&amp;=\sum m_{ii_1}m_{i_1i_2}\cdots m_{i_{k-1}j}=(i,j)-entry\ of\ M(G)^k
\end{aligned}
\]</span> Assume the probability to pick <span
class="math inline">\(v_i\)</span> is <span
class="math inline">\(p(v_i)\)</span> for <span
class="math inline">\(i\in\{1,\dots,n\}\)</span> s.t. <span
class="math inline">\(\sum_{i=1}^n p(v_i)=1\)</span></p>
<p>Let <span
class="math inline">\(P=[\begin{matrix}p(v_1)&amp;p(v_2)&amp;\cdots&amp;p(v_n)\end{matrix}]\)</span>.
Then the probability of a walk ending up at <span
class="math inline">\(v_i\)</span> in k steps is <span
class="math display">\[
P(there\ is\ a\ walk\ ending\ up\ at\ v_i\ in\ k\ steps)=[PM(G)^k]_i
\]</span> If G is k regular <font color='red'>( every vertex has degree
k)</font> then <span
class="math inline">\(M(G)=\frac{1}{d}A(G)\)</span></p>
<p>Then the eigenvalue <span class="math inline">\(\beta_i\)</span> of
<span class="math inline">\(M(G)\)</span> satisfies <span
class="math inline">\(\beta_1=\frac{1}{d}\lambda_i\)</span> where <span
class="math inline">\(\lambda_i\)</span> is an eigenvalue of G. <span
class="math display">\[
P(\exists\ a\ closed\ k-walk\ starting\
v)=\beta_1^k+\cdots+\beta_n^k=\frac{1}{d^k}(\lambda_1^k+\cdots+\lambda_n^k)
\]</span> <strong>Weighted graphs and digraphs</strong></p>
<p>Let G be a graph. A weighted graph is a graph G associated with a
weight function: <span
class="math inline">\(w:E(G)\to\mathbb{F}\)</span> where <span
class="math inline">\(\mathbb{F}\)</span> is a field, denote by <span
class="math inline">\((G,w)\)</span>. Most of the time, we consider the
case that <span
class="math inline">\(\mathbb{F}=\mathbb{R}\)</span>.</p>
<p>The adjacency matrix of a weighted graph is a real symmetric matrix
<span class="math inline">\(A(G,w)=(a_{ij})_{n\times n}\)</span> with
<span class="math inline">\(a_{ij}=w(v_iv_j)\)</span>, the weight of the
edge of <span class="math inline">\(v_iv_j\)</span>.</p>
<p>Let H be a subgraph of <span class="math inline">\((G,w)\)</span>.
The weight of H is defined as <span
class="math inline">\(w(H)=\sum_{e\in E(H)}w(e)\)</span></p>
<p>For example, how to find a minimum weight path between two given
vertices? How to find a minimum spanning tree or how to find a cycle or
walk with large weight<font color='red'>( so-called heavy cycles or
walks)</font></p>
<p>A digraph is a graph with an orientation which assigns an orientation
to each edge.</p>
<p><img
src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220226/2022-05-23_002508.6gvjbxprb7g0.jpg" /></p>
<p><font color='red'>An orientation edge (or arc) from <span
class="math inline">\(v_i\)</span> to <span
class="math inline">\(v_j\)</span> is an ordered pair of vertices ,
denoted by <span class="math inline">\((v_i,v_j)\)</span> where <span
class="math inline">\(v_i\)</span> is called the tail and <span
class="math inline">\(v_j\)</span> is called the head of arc.</font>
<span class="math display">\[
A(D,w)=[a_{ij}]_{n\times n}\  where\ a_{ij}=\left\{\begin{aligned}&amp;
w(v_iv_j),\quad v_i\to v_j\\
&amp;-w(v_iv_j),\quad v_j\to v_i\\
&amp;0,\quad otherwise\end{aligned}\right.
\]</span> Then <span class="math inline">\(A(D,w)\)</span> is no longer
symmetric <font color='red'>but skew-symmetric:<span
class="math inline">\(A+A^T=O\)</span></font></p>
<p>For a given graph G, let D be an orientation of G, <span
class="math inline">\(\vec{B}\)</span> is an oriented incidence matrix
<span class="math display">\[
\vec{B}\cdot \vec{f}=\vec{b}\ where\ \vec{b}\in\mathbb{R}^{|V(G)|},\
\vec{f}\in\mathbb{R}^{|E(G)|}
\]</span> A solution to <span class="math inline">\(\vec{B}\cdot
\vec{f}=\vec{b}\)</span> is called a network flow. <span
class="math inline">\(\vec{b}\)</span> is called a boundary
condition.</p>
<p>If <span class="math inline">\(\vec{b}=\vec{0},\ \vec{B}\cdot
\vec{f}=\vec{0}.\qquad(*)\)</span></p>
<p>A vector <span class="math inline">\(\vec{f}\)</span> satisfies <span
class="math inline">\((*)\)</span> is called a circulation or real flow
if <span
class="math inline">\(\vec{f}\in\mathbb{R}^{|E(G)|}\)</span>.</p>
<p>If a solution to <span class="math inline">\((*)\)</span> satisfies
<span class="math inline">\(\vec{f}\in\mathbb{Z}^{|E(G)|}\)</span>, then
<span class="math inline">\(\vec{f}\)</span> is called an integer
flow.</p>
<p><font color='red'>Tutte's five-flow conjecture: For a graph without
bridge, it has a nowhere zero 5-flow i.e. <span
class="math inline">\(\exists \vec{f}\in\mathbb{Z}^{|E(G)|}\)</span> and
every component of f is not zero and absolute value of every component
is at most 4. <span class="math inline">\(\vec{f}=[f_1,
f_2,\cdots,f_m]\)</span> where <span class="math inline">\(m=|E(G)|,\
f_i\in\{-4,-3,-2,-1,0,1,2,3,4\}\)</span></font></p>
<p><strong>Eigenvalues and subgraphs </strong></p>
<p>Let G be a graph with n vertices, <span
class="math inline">\(A(G)\)</span> be the adjacency matrix.</p>
<p>All n eigenvalues of <span class="math inline">\(A(G)\)</span> are
real because <span class="math inline">\(A(G)\)</span> is real and
symmertic <span class="math display">\[
\lambda_1(G)\geq\lambda_2(G)\geq\cdots\geq\lambda_{\lceil
\frac{n+1}{2}\rceil}\geq\lambda_{\lfloor
\frac{n+1}{2}\rfloor}\geq\lambda_n(G)
\]</span> where <span class="math inline">\(\lambda_{\lceil
\frac{n+1}{2}\rceil},\lambda_{\lfloor \frac{n+1}{2}\rfloor}\)</span> are
median eigenvalues.</p>
<p>The largest eigenvalues <span
class="math inline">\(\lambda_1(G)\)</span> is usually called the
spectral radius of G.</p>
<p><strong>Proposition. Let G be an n-vertex graph and A be its
adjacency matrix.Let <span
class="math inline">\(\lambda_1\geq\cdots\geq\lambda_n\)</span> be the
eigenvalues of A<br>Then 1. <span class="math inline">\(\lambda_1
=\max_{\vec{x}\not=\vec{0}}\frac{\vec{x}^TA\vec{x}}{\vec{x}^T\vec{x}}\)</span>,
2. <span
class="math inline">\(\lambda_1\geq|\lambda_n|\)</span></strong></p>
<hr />
<p><strong>Proof</strong></p>
<p>1.The eigenvalues of A (say <span
class="math inline">\(\vec{u}_1,\vec{u}_2,\dots,\vec{u}_n\)</span>) can
be chosen as a standard orthogonal basis of <span
class="math inline">\(\mathbb{R}^n\)</span>.</p>
<p>Assume that array (<span
class="math inline">\(x_1,x_2,\dots,x_n\)</span>) is the coordinate of
<span class="math inline">\(\vec{x}\)</span> under this basis <span
class="math display">\[
\frac{\vec{x}^TA\vec{x}}{\vec{x}^T\vec{x}}=\frac{\lambda_1x_1^2+\cdots+\lambda_nx_n^2}{x_1^2+\cdots+x_n^2}\leq\lambda_1
\]</span> with equality holds if and only if <span
class="math inline">\(x_1\not= 0\)</span> and <span
class="math inline">\(x_i=0\)</span> for <span
class="math inline">\(i=\{2,\cdots,n\}\)</span>, i.e. <span
class="math inline">\(\vec{x}\)</span> is exactly an eigenvector of
<span class="math inline">\(\lambda_1\)</span>.</p>
<ol start="2" type="1">
<li><p>Let <span class="math inline">\(\vec{v}\)</span> be get from
<span class="math inline">\(\vec{u}_n\)</span> by convert each component
into its absolute value (i.e. <span
class="math inline">\(\vec{v}=(|\vec{u}_n(1)|,|\vec{u}_n(2)|,\cdots,|\vec{u}_n(n)|)\)</span>)</p>
<p>From proof of 1. we can write <span
class="math inline">\(\lambda_n\)</span> as <span
class="math display">\[
|\lambda_n|=|\frac{\vec{u}^T_nA\vec{u}_n}{\vec{u}_n^T\vec{u}_n}|=|\vec{u}^T_nA\vec{u}_n|\leq\sum_{i,j\in[n]}A(i,j)|\vec{u}_n(i)\vec{u}_n(j)|=|\frac{\vec{v}^TA\vec{v}}{\vec{v}^T\vec{v}}|\leq\lambda_1
\]</span> We have used triangle inequality at the first inequality and
the result of 1. at the second inequality.</p></li>
</ol>
<hr />
<p><strong>Propsition. Let G be a graph, and <span
class="math inline">\(\Delta (G)\)</span> be the maximum degree and
<span class="math inline">\(d(G)\)</span> be the average degree. Then we
have </strong> <span class="math display">\[
d(G)\leq\lambda_1\leq\Delta (G)
\]</span></p>
<hr />
<p><strong>Proof</strong></p>
<p>Note that, there exist <span
class="math inline">\(\vec{x}\not=\vec{0}\)</span>, s.t. <span
class="math inline">\(A\vec{x}=\lambda\vec{x}\)</span> where A is the
adjacency matrix. <span class="math display">\[
\lambda_1=\sup\{\vec{x}^TA\vec{x}\Big|||\vec{x}||=1\ and\
\vec{x}\in\mathbb{R}^n\}
\]</span> Let <span
class="math inline">\(\vec{x}_1=\frac{1}{\sqrt{n}}[\begin{matrix}1&amp;1&amp;\dots&amp;1\end{matrix}]^T\)</span>,
then <span class="math display">\[
\begin{aligned}\lambda_1&amp;\geq
\vec{x}_1^TA\vec{x}_1=\frac{1}{\sqrt{n}}[\begin{matrix}1&amp;1&amp;\dots&amp;1\end{matrix}]A\frac{1}{\sqrt{n}}[\begin{matrix}1&amp;1&amp;\dots&amp;1\end{matrix}]^T\\
&amp;=\frac{1}{n}[\begin{matrix}1&amp;1&amp;\dots&amp;1\end{matrix}][\begin{matrix}d(v_1)&amp;d(v_2)&amp;\cdots&amp;d(v_n)\end{matrix}]^T\\
&amp;=\frac{1}{n}\sum_{i=1}^nd(v_i)=d(G)\end{aligned}
\]</span> For the upper bound, let <span
class="math inline">\(\vec{x}\)</span> s.t. <span
class="math inline">\(A\vec{x}=\lambda_1\vec{x}\)</span> where <span
class="math inline">\(\vec{x}=[\begin{matrix}x_1&amp;x_2&amp;\cdots&amp;x_n\end{matrix}]^T\)</span></p>
<p>Let <span class="math inline">\(x_i\)</span> be the largest value
among all components of <span class="math inline">\(\vec{x}\)</span>.
Then, <span class="math display">\[
\lambda_1 x_i=\sum_{v_iv_j\in E(G)}x_j\leq\Delta(G)x_j
\]</span> So <span class="math inline">\(\lambda_1\leq\Delta
(G)\)</span> follows.</p>
<hr />
<p><strong>Corollary Let G be a k-regular graph. Then <span
class="math inline">\(\lambda_1(G)=k\)</span></strong></p>
<p>A signed graph <span class="math inline">\((G,\sigma)\)</span> is a
weighted graph s.t. <span class="math inline">\(\sigma:\
E(G)\to\{-1,1\}\)</span> <span class="math display">\[
A(G,\sigma)=[a_{ij}]_{n\times n}\ where\
a_{ij}=\left\{\begin{aligned}&amp;\sigma(v_iv_j),\quad v_iv_j\in
E(G)\\&amp;0,\quad otherwise\end{aligned}\right.
\]</span> So <span class="math inline">\(A(G,\sigma)\)</span> is a
symmetric real matrix.</p>
<p>We can assume that <span
class="math inline">\(\lambda_1(G,\sigma)\geq\lambda_2(G,\sigma)\geq\cdots\geq\lambda_n(G,\sigma)\)</span>,
<font color='red'>but <span
class="math inline">\(\lambda_1(G,\sigma)\geq|\lambda_n(G,\sigma)|\)</span> may
not hold.</font></p>
<p><strong>Prop. Let <span class="math inline">\((G,\sigma)\)</span> be
a signed graph with maximum degree <span class="math inline">\(\Delta
(G)\)</span>. Then</strong> <span class="math display">\[
|\lambda(G,\sigma)|\leq\Delta(G)\ where\ \lambda(G,\sigma)\ is\ an\
eigenvalue\ of\ G
\]</span></p>
<hr />
<p><strong>Proof</strong></p>
<p>Let <span class="math inline">\(\vec{x}\)</span> be an eigenvector of
<span class="math inline">\(\lambda\)</span> s.t. <span
class="math inline">\(\lambda\vec{x}=A\vec{x}\)</span>.</p>
<p>Let <span
class="math inline">\(\vec{x}=[\begin{matrix}x_1&amp;x_2&amp;\cdots&amp;x_n\end{matrix}]^T\)</span>
and <span class="math inline">\(x_i\)</span> has the largest absolute
value among all <span class="math inline">\(x_j\)</span>'s.</p>
<p>Then <span class="math display">\[
|\lambda x_i|=|(A\vec{x})_i|=|\sum_{v_iv_j\in
E(G)}\sigma(v_iv_j)x_j|\leq\sum_{v_iv_j\in E(G)}|x_j|\leq\Delta(G)|x_i|
\]</span> So <span
class="math inline">\(|\lambda|\leq\Delta(G)\)</span></p>
<hr />
<p><strong>Thm A graph G is bipartite <span
class="math inline">\(\Leftrightarrow\)</span> its spectrum is symmetric
about the origin.</strong></p>
<p><font color='red'>(i.e. <span
class="math inline">\(\lambda_i\)</span> is an eigenvalue of G <span
class="math inline">\(\Leftrightarrow\)</span> <span
class="math inline">\(-\lambda_i\)</span> is an eigenvalue of
G)</font></p>
<hr />
<p><strong>Proof</strong></p>
<p><span class="math inline">\(\Rightarrow\)</span> Assume that G is
bipartite.Let A be The adjacency matrix of G. <span
class="math display">\[
A=\left[\begin{matrix}O&amp;B\\B^T&amp;O\end{matrix}\right]\ where\ B\
is\ the\ bipartite\ adjacency\ matrix.
\]</span> Let <span class="math inline">\(\lambda\)</span> be an
eigenvalue of G with <span
class="math inline">\(\vec{x}=(\begin{matrix}\vec{x}_1^T&amp;\vec{x}_2^T\end{matrix})^T\)</span></p>
<p>Then <span class="math display">\[
A\vec{x}=\left(\begin{matrix}O&amp;B\\B^T&amp;O\end{matrix}\right)\left(\begin{matrix}\vec{x}_1\\\vec{x}_2\end{matrix}\right)=\left(\begin{matrix}B\vec{x}_2\\B^T\vec{x}_1\end{matrix}\right)=\lambda\left(\begin{matrix}\vec{x}_1\\\vec{x}_2\end{matrix}\right)
\]</span> Then <span class="math display">\[
A\left(\begin{matrix}\vec{x}_1\\-\vec{x}_2\end{matrix}\right)=\left(\begin{matrix}O&amp;B\\B^T&amp;O\end{matrix}\right)\left(\begin{matrix}\vec{x}_1\\-\vec{x}_2\end{matrix}\right)=\left(\begin{matrix}-B\vec{x}_2\\B^T\vec{x}_1\end{matrix}\right)=-\lambda\left(\begin{matrix}\vec{x}_1\\-\vec{x}_2\end{matrix}\right)
\]</span> So <span class="math inline">\(-\lambda\)</span> is also an
eigenvalue of A.</p>
<p><span class="math inline">\(\Leftarrow\)</span> Let <span
class="math inline">\(\lambda_1\geq\cdots\geq\lambda_n\)</span> be all
eigenvalues of G.<font color='red'>(i.e. <span
class="math inline">\(\lambda_i=-\lambda_{n-i+1}\)</span>)</font></p>
<p>For any positive integer k, the matrix <span
class="math inline">\(A^k\)</span> has eigenvalues <span
class="math inline">\(\lambda_1^k,\lambda_2^k,\cdots,\lambda_n^k\)</span></p>
<p>Because G has symmetric specturm, it follows that <span
class="math inline">\(\lambda_1^k+\cdots+\lambda_n^k=0\)</span> if k is
an odd integer. <span class="math display">\[
0=\lambda_1^k+\cdots+\lambda_n^k=w_k(G)
\]</span> <font color='red'><span
class="math inline">\(w_k(G)\)</span> is the total number of close
k-walks.</font></p>
<p>So every closed walk have an even length. Therefore G is
bipartite.</p>
<hr />
<p><font color='red'>Problem: characterize graphs which satisfy #
positive eigenvalues=# negative eigenvalues</font></p>
]]></content>
      <categories>
        <category>Graph Theory</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Operation Research</tag>
      </tags>
  </entry>
  <entry>
    <title>Lecture series on graph theory 7</title>
    <url>/2022/05/26/Graph7/</url>
    <content><![CDATA[<p><strong>Thm(Wilf,1967) Let G be a graph. Then <span
class="math inline">\(\chi(G)\leq\lambda_1(G)+1\)</span>, where <span
class="math inline">\(\chi(G)\)</span> is the chromatic
number</strong></p>
<p>A proper vertex coloring is a map <span
class="math inline">\(c:V(G)\to\mathbb{N}\)</span> s.t. <span
class="math inline">\(c(v_i)\not=c(v_j)\)</span> if <span
class="math inline">\(v_iv_j\in E(G)\)</span>.</p>
<p>A graph is a k-colorable if there exists a proper vertex coloring
<span class="math display">\[
c:V(G)\to\{1,2,\cdots,k\}=[k].
\]</span> <span id="more"></span></p>
<p>The chromatic number of a graph is the smallest integer k s.t. G is
k-colorable, denoted by <span
class="math inline">\(\chi(G)\)</span>.</p>
<p><strong>(Four color Theorem) Every planar graph is
4-colorable</strong></p>
<p><img
src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220226/2022-05-26_011010.4crr6n46e6o.jpg" /></p>
<p><strong>Lemma Let G be a graph. Then</strong> <span
class="math display">\[
\chi(G)\leq1+p
\]</span> <strong>where <span
class="math inline">\(p=\max\{\delta(H)|\text{H is an induced subgraph
of G}\}\)</span>, <font color='red'><span
class="math inline">\(\delta(G)\)</span> is minimum degree of
H.</font></strong></p>
<hr />
<p><strong>Proof of Lemma</strong></p>
<p>Use greedy algorithm:</p>
<p>Consider that <span
class="math inline">\(c:V(G)\to\mathbb{N}\)</span> such that color the
first vertex by the smallest value and color the k-th vertex by using
the smallest value that has not been used to color any of the first k-1
vertices that are adjacent to the k-th vertex. So it suffices to show
that there is an ordering of the vertices of G for which the greedy
algorithm gives an (1+p)-coloring of G.</p>
<p>Let <span class="math inline">\(x_n\)</span> be a vertex of <span
class="math inline">\(G=H_n\)</span> having degree at most
p.<font color='red'>（<span class="math inline">\(x_n\)</span> could be
the vertex of G with the degree <span
class="math inline">\(\delta(G)\)</span></font></p>
<p>By the definition of the value of p, the subgraph <span
class="math inline">\(H_{n-1}=G-x_n\)</span> has a vertex <span
class="math inline">\(x_{n-1}\)</span> of degree at most p. Continue
this process, let <span
class="math inline">\(H_{n-1}=G-\{x_n,x_{n-1},\cdots,x_{n-i+1}\}\)</span>
which again has a vertex of degree at most p, denoted by <span
class="math inline">\(x_{n-i}\)</span> for <span
class="math inline">\(i\in[n]\)</span></p>
<p>Then <span
class="math inline">\(H_{1}=G-\{x_n,x_{n-1},\cdots,x_{2}\}\)</span> is
an isolated vertex of degree 0.</p>
<p>Then the ordering <span
class="math inline">\(x_1,x_2,\cdots,x_n\)</span> is a desired one.</p>
<hr />
<p><strong>Proof of Wilf's Theorem</strong></p>
<p>Let G be a graph. For any induced subgraph H of G, <span
class="math inline">\(\delta(G)\leq
d(G)\leq\lambda_1(H)\leq\lambda_1(G)\)</span></p>
<p>Therefore, <span class="math inline">\(p=\max\{\delta(H)|\text{H is
an induced subgraph of G}\}\leq\lambda_1(G)\)</span></p>
<p>It follows from the above Lemma <span class="math display">\[
\chi(G)\leq 1+p\leq1+\lambda_1(G)
\]</span></p>
<hr />
<p>If G is k-colorable, let <span
class="math inline">\(c:V(G)\to[k]\)</span> be a k-colorable. <span
class="math inline">\(c^{-1}(i)\)</span>, the preimage of color i, is an
independent set. Independent number of G: <span
class="math inline">\(\alpha(G)\geq\max\left\{|c^{-1}(i)|\big|i\in[k]\right\}\geq
n/k\)</span>.</p>
<p>So <span class="math inline">\(\alpha(G)\geq n/\chi(G)\geq
n/(1+\lambda_1(G))\)</span>.</p>
<p><strong>Coloring, Integer flow</strong></p>
<p>Let G be a graph. An integer flow of G is an ordered pair <span
class="math inline">\((D,f)\)</span> where <span
class="math inline">\(D\)</span> is an orientation of <span
class="math inline">\(G\)</span> and <span
class="math inline">\(f\)</span> is an integer function <span
class="math inline">\(f:E(G)\to\mathbb{Z}\)</span> s.t. for every vertex
v of G <span class="math inline">\(\sum_{e\in E^{+}(v)}f(e)=\sum_{e\in
E^{-}(v)}f(e)\)</span> where <span
class="math inline">\(E^{+}(v)\)</span> is the set of all arcs with
<span class="math inline">\(v\)</span> as tail and <span
class="math inline">\(E^{-}(v)\)</span> is the set of all arcs with v as
head.</p>
<p><font color='red'>Recall: this incidence matrix of D is matrix is
<span class="math inline">\(\vec{B}\)</span> and <span
class="math inline">\(\vec{f}=&lt;f(e_1),\cdots,f(e_m)&gt;\in\mathbb{Z}^m\)</span> where
<span class="math inline">\(m=|E(G)|\)</span> , then <span
class="math inline">\(\vec{B}\cdot\vec{f}=0\)</span>. This vector <span
class="math inline">\(\vec{f}\)</span> is called an integer flow of
G.</font></p>
<p>An integer flow <span class="math inline">\((D,f)\)</span> is
nowhere-zero if <span class="math inline">\(f(e)\not=0\)</span> for all
edges of <span class="math inline">\(G\)</span> <font color='red'>i.e.
<span class="math inline">\(\vec{f}\)</span> has no zero
component.</font></p>
<p>An integer flow <span class="math inline">\((D,f)\)</span> is a
k-flow if <span class="math inline">\(|f(e)|&lt;k\)</span>
<font color='red'>i.e. every component of <span
class="math inline">\(\vec{f}\)</span> has absolute value less than
k.</font></p>
<p>If G has a k-flow, the orientation in the k-flow does not matter.</p>
<p><strong>Proposition Every Eulerian graph has nowhere 2-flow. A
connected graph with a nowhere-zero 2-flow is Eulerian.</strong></p>
<p><strong>Lemma Let <span class="math inline">\((D,f)\)</span> be a
flow of G, then for each <span class="math inline">\(X\subset
V(G)\)</span>, it holds that</strong><br />
<span class="math display">\[
\sum_{e\in E^{+}X}f(e)=\sum_{e\in E^{-}(X)}f(e)
\]</span></p>
<hr />
<p><strong>Proof</strong></p>
<p>Since <span class="math inline">\((D,f)\)</span> is a flow, it
follows that, for every vertex v, <span class="math display">\[
\sum_{e\in E^{+}(v)}f(e)=\sum_{e\in E^{-}(v)}f(e)
\]</span> So <span class="math inline">\(\sum_{e\in
E^{+}(v)}f(e)-\sum_{e\in E^{-}(v)}f(e)=0\)</span></p>
<p>Note that <span class="math display">\[
0=\sum_{v\in X}(\sum_{e\in E^{+}(v)}f(e)-\sum_{e\in
E^{-}(v)}f(e))=\sum_{e\in E^{+}(X)}f(e)-\sum_{e\in E^{-}(X)}f(e)
\]</span></p>
<hr />
<p><strong>Corollary A graph has a nowhere-zero integer flow <span
class="math inline">\(\Leftrightarrow\)</span> it has no
cut-edge.</strong></p>
<hr />
<p><strong>Proof</strong></p>
<p><span class="math inline">\(\Rightarrow\)</span> It follows directly
from the above lemma.</p>
<p><span class="math inline">\(\Leftarrow\)</span> Assume that G has no
cut-edge. Then every edge of G belongs to a cycle.</p>
<p>Let <span class="math inline">\(C=\{C_1,C_2,\cdots,C_k\}\)</span> be
a set of cycles covering all edges of G.</p>
<p>Every <span class="math inline">\(C_1\)</span> has nowhere-zero
2-flow <span class="math inline">\((D,f_1)\)</span> <span
class="math display">\[
f:E(G)\to\mathbb{N}\quad s.t.\ f(e)=\sum_{i=1}^k 2^if_i(e)
\]</span> Then <span class="math inline">\((D,f)\)</span> is a
nowhere-zero integer flow.</p>
<hr />
<p><strong>The Coloring-Flow Duality Theorem (Tutte)<br>Let G be a
2-connected planar graph. Then G is proper face k-colorable if and only
if G has a nowhere-zero k-flow. In other words, let <span
class="math inline">\(G^{\star}\)</span> be its planar dual. Then <span
class="math inline">\(G^{\star}\)</span> is proper k-colorable <span
class="math inline">\(\Leftrightarrow\)</span> G has a nowhere-zero
k-flow.</strong></p>
]]></content>
      <categories>
        <category>Graph Theory</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Operation Research</tag>
      </tags>
  </entry>
  <entry>
    <title>Lecture series on graph theory 6</title>
    <url>/2022/05/24/Graph6/</url>
    <content><![CDATA[<p><strong>Interlacing Theorem</strong></p>
<p><strong>Thm(Eigenvalue Interlacing Theorem)<br>Let A be a symmetric
real <span class="math inline">\(n\times n\)</span> and let B be an m-th
principal submatrix<font color='red'>(obtained by deleting both i-th row
and i-th column for some n-m values of i)</font>. Suppose A has
eigenvalues <span
class="math inline">\(\lambda_1\geq\cdots\geq\lambda_n\)</span>, and B
has eigenvalues <span
class="math inline">\(\beta_1\geq\cdots\geq\beta_m\)</span>.Then</strong>
<span class="math display">\[
\lambda_k\geq\beta_k\geq\lambda_{k+(n-m)},\qquad k=1,2,\dots,m
\]</span> <span id="more"></span></p>
<p><img
src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220226/2022-05-24_122238.626hmwj3vik0.jpg" /></p>
<p>Further,if <span class="math inline">\(m=n-1\)</span>, then <span
class="math display">\[
\lambda_1\geq\beta_1\geq\lambda_2\geq\beta_2\geq\cdots\geq\lambda_i\geq\beta_i\geq\lambda_{i+1}\geq\cdots\geq\beta_{n-1}\geq\lambda_{n}
\]</span></p>
<hr />
<p><strong>Proof</strong></p>
<p>Without loss of generality, assume that <span
class="math inline">\(A=\left[\begin{matrix}B&amp;X\\X^T&amp;C\end{matrix}\right]\)</span>
and <span class="math inline">\(\lambda_i\vec{x}_i=A\vec{x}_i\)</span>
for <span class="math inline">\(i\in[n]\)</span> such that all <span
class="math inline">\(\vec{x}_i\)</span> are linearly independent and
normalized, and <span
class="math inline">\(\beta_j\vec{y}_j=B\vec{y}_j\)</span> for <span
class="math inline">\(j\in[m]\)</span> s.t. all <span
class="math inline">\(\vec{y}_j\)</span> are linearly independent and
normalized.</p>
<p>Let <span
class="math inline">\(V=span\{\vec{x}_k,\cdots,\vec{x}_n\}\)</span> and
<span
class="math inline">\(W=span\{\vec{y}_1,\cdots,\vec{y}_k\}\)</span>.
Extend <span class="math inline">\(W\)</span> to a subspace of <span
class="math inline">\(\mathbb{R}^n\)</span> s.t. <span
class="math display">\[
\widetilde{W}=\left\{\left.\left[\begin{matrix}\vec{w}\\0\end{matrix}\right]\right|\vec{w}\in
W\right\}\subset\mathbb{R}^n
\]</span> Then <span class="math inline">\(\dim(V)=n-k+1\)</span> and
<span class="math inline">\(\dim(\widetilde{W})=\dim(W)=k\)</span></p>
<p>Note that both <span class="math inline">\(V\subset
\mathbb{R}^n\)</span> and <span
class="math inline">\(\widetilde{W}\subset \mathbb{R}^n\)</span>, and
<span class="math display">\[
\dim(V)+\dim(\widetilde{W})=n-k+1+k=n+1&gt;\dim(\mathbb{R}^n)
\]</span> It follows that there exists a vector <span
class="math inline">\(\tilde{w}\)</span> which satisfies <span
class="math inline">\(\tilde{w}\in V\cap\widetilde{W}\)</span>.</p>
<p><font color='red'><span class="math inline">\(\lambda_k\)</span> is
the largest eigenvalue with an eigenvector in V; <span
class="math inline">\(\beta_k\)</span> is the smallest eigenvalue with
an eigenvector in W.</font></p>
<p>Therefore, <span class="math display">\[
\begin{aligned}
\lambda_k&amp;=\max\{\vec{x}^TA\vec{x}|\vec{x}\in V,||\vec{x}||=1\}\\
&amp;\geq\frac{\tilde{w}^TA\tilde{w}}{\tilde{w}^T\tilde{w}}=\left.\left[\begin{matrix}\vec{w}^T&amp;0\end{matrix}\right]\left[\begin{matrix}B&amp;X\\X^T&amp;C\end{matrix}\right]\left[\begin{matrix}\vec{w}\\0\end{matrix}\right]\right/\left[\begin{matrix}\vec{w}^T&amp;0\end{matrix}\right]\left[\begin{matrix}\vec{w}\\0\end{matrix}\right]\\
&amp;=\frac{\tilde{w}^TB\tilde{w}}{\tilde{w}^T\tilde{w}}\geq\min\{\vec{y}^TA\vec{y}|\vec{y}\in
W,||\vec{y}||=1\}=\beta_k
\end{aligned}
\]</span> So we have <span
class="math inline">\(\lambda_k\geq\beta_k\)</span>.</p>
<p>On the other hand, let <span
class="math inline">\(V=span\{\vec{x}_1,\cdots,\vec{x}_{k+n-m}\}\)</span>
<font color='red'>(i.e. <span
class="math inline">\(\lambda_{k+n-m}\)</span> is the smallest
eigenvalue with an eigenvector in V)</font> and <span
class="math inline">\(W=span\{\vec{y}_1,\cdots,\vec{y}_{k+n-m}\}\)</span>
<font color='red'>(i.e. <span class="math inline">\(\beta_k\)</span> is
the largest eigenvalue with an eigenvector in W)</font>.</p>
<p>Let <span
class="math inline">\(\widetilde{W}=\left\{\left.\left[\begin{matrix}\vec{w}\\0\end{matrix}\right]\right|\vec{w}\in
W\right\}\subset\mathbb{R}^n\)</span>. Then <span
class="math inline">\(\dim(V)=k+n-m\)</span> and <span
class="math inline">\(\dim(\widetilde{W})=m-k+1\)</span>.</p>
<p>Therefore, <span
class="math inline">\(\dim(V)+\dim(\widetilde{W})=n-k+1+k=n+1&gt;\dim(\mathbb{R}^n)\)</span></p>
<p>It follows that there exists a vector <span
class="math inline">\(\tilde{w}\)</span> which satisfies <span
class="math inline">\(\tilde{w}\in V\cap\widetilde{W}\)</span>. <span
class="math display">\[
\begin{aligned}
\lambda_{k+n-m}&amp;=\min\{\vec{x}^TA\vec{x}|\vec{x}\in
V,||\vec{x}||=1\}\\
&amp;\leq\frac{\tilde{w}^TA\tilde{w}}{\tilde{w}^T\tilde{w}}=\left.\left[\begin{matrix}\vec{w}^T&amp;0\end{matrix}\right]\left[\begin{matrix}B&amp;X\\X^T&amp;C\end{matrix}\right]\left[\begin{matrix}\vec{w}\\0\end{matrix}\right]\right/\left[\begin{matrix}\vec{w}^T&amp;0\end{matrix}\right]\left[\begin{matrix}\vec{w}\\0\end{matrix}\right]\\
&amp;=\frac{\tilde{w}^TB\tilde{w}}{\tilde{w}^T\tilde{w}}\leq\max\{\vec{y}^TA\vec{y}|\vec{y}\in
W,||\vec{y}||=1\}=\beta_k
\end{aligned}
\]</span> So <span
class="math inline">\(\lambda_{k+n-m}\leq\beta_k\)</span>.</p>
<p><strong>Bounding degree of induced subgraph</strong></p>
<p><img
src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220226/2022-05-24_162631.52l2utvvt9c0.jpg" /></p>
<p><strong>Thm(Huang,2019) Let H be an induced subgraph of the
n-dimensional hypercube <span class="math inline">\(Q_n\)</span>. If
<span
class="math inline">\(|V(H)|&gt;2^{n-1}=\frac{|V(Q)|}{2}\)</span>,then
<span class="math inline">\(\Delta (H)\geq\sqrt{n}\)</span></strong></p>
<p><font color='red'><strong>n-dimensional hypercube <span
class="math inline">\(Q_n\)</span></strong></font></p>
<p><img
src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220226/2022-05-24_163151.69hvpww08lw0.jpg" /></p>
<p><font color='red'>An n-dimensional hypercube <span
class="math inline">\(Q_n\)</span> is a graph with vertex set consisting
of all <span class="math inline">\(\{0,1\}\)</span>-sequences of length
n and two vertices are adjacent to each other if and only if the
two <span class="math inline">\(\{0,1\}\)</span>-sequences has exactly
one position different</font></p>
<p>The adjacency matrix of n-dimensional hypercube <span
class="math inline">\(Q_n\)</span> satisfies the following</p>
<p><img
src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220226/2022-05-24_163613.2kylzo171uo0.jpg" /></p>
<p>If we give every edge in n-dimensional hypercube <span
class="math inline">\(Q_n\)</span> a sign, we can get a signed adjacency
matrix.</p>
<p><img
src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220226/2022-05-24_163633.44mufz49sju0.jpg" /></p>
<p><strong>Lemma The signed n-dimensional hypercube with adjacency
matrix <span class="math inline">\(S_n\)</span> has an eigenvalue <span
class="math inline">\(\sqrt{n}\)</span> of multiplicity <span
class="math inline">\(2^{n-1}\)</span> and eigenvalue <span
class="math inline">\(-\sqrt{n}\)</span> with multiplicity <span
class="math inline">\(2^{n-1}\)</span></strong></p>
<hr />
<p><strong>Proof</strong></p>
<p><strong>claim: <span
class="math inline">\(S_n^2=nI\)</span></strong></p>
<p>If <span class="math inline">\(n=1\)</span>, <span
class="math inline">\(S_1=\left[\begin{matrix}0&amp;1\\1&amp;0\end{matrix}\right],S_1^2=I\)</span>.
Assume that <span class="math inline">\(S_{n-1}^2=(n-1)I\)</span></p>
<p>Then <span class="math display">\[
S_n^2=\left[\begin{matrix}S_{n-1}&amp;I\\I&amp;-S_{n-1}\end{matrix}\right]\left[\begin{matrix}S_{n-1}&amp;I\\I&amp;-S_{n-1}\end{matrix}\right]=\left[\begin{matrix}S_{n-1}^2+I&amp;O\\O&amp;S_{n-1}^2+I\end{matrix}\right]=nI
\]</span> So claim holds.</p>
<p>Note that <span class="math inline">\(nI\)</span> has eigenvalues n.
Therefore, <span class="math inline">\(S_n\)</span> has eigenvalues
either <span class="math inline">\(\sqrt{n}\)</span> or <span
class="math inline">\(-\sqrt{n}\)</span>.</p>
<p>Since the trace of <span class="math inline">\(S_n\)</span> is 0,
<span class="math inline">\(S_n\)</span> has eigenvalues <span
class="math inline">\(\sqrt{n}\)</span> of multiplicity <span
class="math inline">\(2^{n-1}\)</span> and <span
class="math inline">\(-\sqrt{n}\)</span> with multiplicity <span
class="math inline">\(2^{n-1}\)</span>.</p>
<hr />
<p><strong>Proof of Huang's Theorem</strong></p>
<p>Let H be a induced subgraph of <span
class="math inline">\(Q_n\)</span> with more than <span
class="math inline">\(2^{n-1}\)</span> vertices. It suffices to show
that every subgraph H with exactly <span
class="math inline">\(2^{n-1}+1\)</span> vertices has maximum degree at
least <span class="math inline">\(\sqrt{n}\)</span>.</p>
<p>Let <span class="math inline">\((Q_n,\sigma)\)</span> be the signed
graph with adjacency matrix <span class="math inline">\(S_n\)</span> as
defined above. Then <span class="math inline">\((H,\sigma)\)</span> is a
signed induced subgraph of <span
class="math inline">\((Q_n,\sigma)\)</span>, whose adjacency matrix
<span class="math inline">\(A\)</span> is a <span
class="math inline">\((2^{n-1}+1)\)</span>-principle submatrix of <span
class="math inline">\(S_n\)</span>.</p>
<p>By the proposition <font color='red'>(i.e. <span
class="math inline">\(|\lambda(H,\sigma)|\leq\Delta (H)\)</span></font>
and the interlacing theorem <span class="math display">\[
\Delta
(H)\geq\lambda_1(A)\geq\lambda_{1+2^n-(2^{n-1}+1)}(S_n)=\lambda_{2^{n-1}}(S_n)=\sqrt{n}
\]</span> <span class="math inline">\(\lambda_1(A)\)</span> means the
largest eigenvalue of A.</p>
<hr />
<p><strong>Unfriendly partitions of subcubic graphs</strong></p>
<p>A graph G is subcubic if the maximum degree of G is at most 3.
<font color='red'>(<span
class="math inline">\(\Delta(G)\leq3\)</span>)</font></p>
<p><font color='red'>Conjecture (Pisanski and Fowler,2012)  <br>All
subcubic graphs except finitely many have median eigenvalues in the
interval<span class="math inline">\([-1,1]\)</span>. There exists a
constant c such that if <span
class="math inline">\(|V(G)|\geq|c|\)</span>, then <span
class="math inline">\(\lambda_{\lfloor\frac{\lambda+1}{2}\rfloor},\lambda_{\lceil\frac{\lambda+1}{2}\rceil}\in[-1,1]\)</span></font></p>
<p>Let G be a graph. A partition <span
class="math inline">\((X,Y)\)</span> of <span
class="math inline">\(V(G)\)</span> is unfriendly if every vertex has at
least the same number of neighbors in the other subset as in it
owns.</p>
<p><font color='red'>In other words, for every vertex v of G, <span
class="math inline">\(d_{G[x]}(v)\leq\frac{1}{2}d_G(v)\)</span>
and <span
class="math inline">\(d_{G[Y]}(v)\leq\frac{1}{2}d_G(v)\)</span></font></p>
<p>If <span class="math inline">\((X,Y)\)</span> is an unfriendly
partition of a subcubic graph <span class="math inline">\(G\)</span>,
then the maximum degree of the induced subgraph <span
class="math inline">\(G[X]\)</span> and <span
class="math inline">\(G[Y]\)</span> is at most 1.</p>
<p>An unfriendly partition <span class="math inline">\((X,Y)\)</span> is
unbalanced if <span class="math inline">\(|X|\not=|Y|\)</span></p>
<p>A partition is a bisection if <span
class="math inline">\(\Big||X|-|Y|\Big|\leq1\)</span></p>
<p><strong>Proposition Let G be a subcubic graph with n vertices. If G
has an unbalanced unfriendly partition, then</strong> <span
class="math display">\[
\lambda_{\lfloor\frac{n+1}{2}\rfloor}\in[-1,1]\qquad\lambda_{\lceil\frac{n+1}{2}\rceil}\in[-1,1]
\]</span></p>
<hr />
<p><strong>Proof</strong></p>
<p>Let G be a subcubic graph with n vertices and <span
class="math inline">\((X,Y)\)</span> be an unbalanced unfriendly
partition.</p>
<p>Without loss of generality, assume that <span
class="math inline">\(|X|&gt;|Y|\)</span></p>
<p>Then <span
class="math inline">\(\lambda_1(X)\leq\Delta(X)\leq1\)</span> and <span
class="math inline">\(\lambda_1(Y)\leq\Delta(Y)\leq1\)</span>. So both X
and Y are bipartite.</p>
<p>All eigenvalues of <span class="math inline">\(X\)</span> and <span
class="math inline">\(Y\)</span> belong to <span
class="math inline">\([-1,1]\)</span>. Since <span
class="math inline">\(|X|&gt;|Y|\)</span>, it holds that <span
class="math display">\[
|X|\geq\left\lceil
\frac{n}{2}\right\rceil+1&gt;\frac{n}{2}&gt;\left\lceil
\frac{n}{2}\right\rceil-1\geq|Y|
\]</span> It follows that the interlacing theorem that <span
class="math display">\[
1\geq\lambda_1(X)\geq\lambda_{1+n-|X|}(G)\geq\lambda_{1+n-(\lceil\frac{n}{2}\rceil+1)}(G)\geq\lambda_{\left\lfloor
\frac{n+1}{2}\right\rfloor}(G)\geq\lambda_{\left\lceil
\frac{n+1}{2}\right\rceil}(G)\geq\lambda_{\left\lceil
\frac{n+1}{2}\right\rceil}(X)\geq-1
\]</span> The completes the proof.</p>
<hr />
<p><font color='red'>Q: Does every subcubic graph have an unbalanced
unfriendly partition?</font></p>
<p><font color='red'>A: No</font></p>
<p><img
src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220226/2022-05-26_005635.7fv36qke8og0.jpg" /></p>
<p><font color='red'>Conjecture(Ban&amp;Linal,2016) Every cubic graph
has an unfriendly almost balanced partition <span
class="math inline">\((X,Y)\)</span> s.t. <span
class="math inline">\(\Big||X|-|Y|\Big|\leq2\)</span></font></p>
]]></content>
      <categories>
        <category>Graph Theory</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Operation Research</tag>
      </tags>
  </entry>
  <entry>
    <title>Lecture series on graph theory 8</title>
    <url>/2022/05/27/Graph8/</url>
    <content><![CDATA[<p><strong>Proof of the coloring-flow duality theorem</strong></p>
<span id="more"></span>
<p><span class="math inline">\(\Rightarrow\)</span> Assume that G is
face k-colorable (proper coloring)</p>
<p>We need to show that G has a nowhere-zero k-flow <span
class="math inline">\((D,f)\)</span> <span class="math display">\[
\begin{aligned}
(i.e.
&amp;f:E(G)\to\{-(k-1),-(k-2),\cdots,-1,1,\cdots,k-2,k-1\}\\&amp; s,t,\forall
v\in V(G),\sum_{e\in E^{+}(v)}f(e)=\sum_{e\in E^{-}(v)}f(e))
\end{aligned}
\]</span> Let <span class="math inline">\(F(G)\)</span> be the set of
all faces of G and let <span class="math inline">\(c:F(G)\to[k]\)</span>
be a face coloring.</p>
<p>Assign an orientation <span class="math inline">\(D\)</span> to <span
class="math inline">\(E(G)\)</span>: each edge <span
class="math inline">\(e\in E(G)\)</span> is oriented such that the face
with a smaller color index is on the right side of the arc.</p>
<p><img
src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220226/2022-05-27_121553.4l885wgltpq0.jpg" /></p>
<p>Define a function <span class="math inline">\(f:E(G)\to[k-1]\)</span>
such that <span class="math inline">\(f(e)\)</span> is the absolute
value of the difference of the colors of two faces incident with e.</p>
<p><font color='blue'><strong>claim: <span
class="math inline">\((D,f)\)</span> is a nowhere-zero
k-flow</strong></font></p>
<hr />
<p><strong><font color='blue'>Proof of claim:</font></strong></p>
<p><font color='blue'>Clearly, <span
class="math inline">\(0&lt;f(e)&lt;k\)</span>, because the smallest
color index is 1 and the largest color index is k;and two faces share
edges have different color indices.So f is nowhere-zero.</font></p>
<p><font color='blue'>Let v be vertex of G and <span
class="math inline">\(v_1,v_2,\cdots,v_d\)</span> be all neighbors of v
appearing around v in a clockwise order.Let <span
class="math inline">\(f_i\)</span> be the face containing edges <span
class="math inline">\(vv_1\)</span> and <span
class="math inline">\(vv_{i+1}\)</span> . Note that, for any <span
class="math inline">\(i\not=j,f_i\not=f_j\)</span> because G is
2-connected.</font></p>
<p><font color='blue'>Define</font> <span class="math display">\[
\textcolor{blue}{\epsilon_i=\left\{\begin{aligned}&amp;-1,\quad if\ v\to
v_i\ in\ D\\&amp;1,\quad if\ v_i\to v\ in\ D
\end{aligned}\right.}
\]</span> <font color='blue'>Then, for each <span
class="math inline">\(i\in[d]\)</span></font> <span
class="math display">\[
\textcolor{blue}{c(f_i)=c(f_d)+\sum_{j=1}^i\epsilon_if(vv_j) \tag{*}}
\]</span> <img
src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220226/2022-05-27_124414.4gsbkbgif9u0.jpg" />
<span class="math display">\[
\begin{aligned}&amp;\textcolor{blue}{c(f_1)=c(f_d)}+\textcolor{red}{f(vv_1)}\\&amp;\textcolor{blue}{c(f_2)=c(f_1)-f(vv_2)=c(f_d)+f(vv_1)-f(vv_2)=c(f_d)+\sum_{j=1}^2\epsilon_jf(vv_j)}\end{aligned}
\]</span> <font color='blue'>From (*), <span
class="math inline">\(c(f_i)=c(f_d)+\sum_{j=1}^i\epsilon_if(vv_j)\)</span>.
It follows that</font> <span class="math display">\[
\textcolor{blue}{\sum_{j=1}^d\epsilon_jf(vv_j)=0\Rightarrow\sum_{e\in
E^{+}(v)}f(e)=\sum_{e\in E^{-}(v)}f(e)}
\]</span></p>
<hr />
<p><span class="math inline">\(\Leftarrow\)</span> Assume that G has a
nowhere-zero k-flow <span class="math inline">\((D,f)\)</span>.</p>
<p>Define a map <span
class="math inline">\(c:F(G)\to\{1,2,\cdots,k-1\}\)</span></p>
<p>Choose an arbitrary face <span class="math inline">\(f_0\)</span> and
let <span class="math inline">\(c(f_0)=1\)</span>. For each arc <span
class="math inline">\(e_i\)</span> in D, let <span
class="math inline">\(f_i&#39;\)</span> and <span
class="math inline">\(f_i&#39;&#39;\)</span> be two faces incident with
<span class="math inline">\(e_i\)</span>. If one of <span
class="math inline">\(f_i&#39;\)</span> and <span
class="math inline">\(f_i&#39;&#39;\)</span> is colored, then the color
of another face is given by the following equality <span
class="math display">\[
c(f_i&#39;&#39;)=c(f_i&#39;)+f(e_i)(mod\ k)
\]</span> It suffices to show that the vertex coloring is
well-defined.<font color ='red'>In other words, the process does not
color one face by two or more different colors.</font></p>
<p>Let <span class="math inline">\(f_1\)</span> be uncolored face
incident with two colored faces <span class="math inline">\(f_2\)</span>
and <span class="math inline">\(f_3\)</span>.Let <span
class="math inline">\(e_i\)</span> be the edge on the boundary of <span
class="math inline">\(f_1\)</span> and <span
class="math inline">\(f_i\)</span> for <span
class="math inline">\(i=2,3\)</span>. Without loss of generality, let
<span class="math inline">\(f_i\)</span> be on the left side of the arcs
<span class="math inline">\(e_2\)</span> and <span
class="math inline">\(e_3\)</span>.</p>
<p><font color='blue'><strong>claim: <span
class="math inline">\(c(f_2)+f(e_2)\equiv c(f_3)+f(e_3)(mod\
k)\)</span></strong></font></p>
<hr />
<p><font color='blue'><strong>Proof of claim:</strong></font></p>
<p><img
src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220226/2022-05-27_164800.1de6ecdbpaps.jpg" /></p>
<p><font color='blue'>Consider the dual graph <span
class="math inline">\(G^\star\)</span> of G.</font></p>
<p><font color='blue'>The vertex subset <span
class="math inline">\(X^\star=\{f\in V(G^\star)\big|f\in F(G)\ is\
colored\ already\}\)</span> induces a connected subgraph of <span
class="math inline">\(G^\star\)</span>. Thus, there is a cycle <span
class="math inline">\(C^\star\)</span> of <span
class="math inline">\(G^\star\)</span> containing <span
class="math inline">\(f_1,f_2\)</span> and <span
class="math inline">\(f_3\)</span>.The cycles <span
class="math inline">\(C^\star\)</span> also contains the edge <span
class="math inline">\(f_1f_2\)</span> and<span
class="math inline">\(f_1f_3\)</span>, <span
class="math inline">\(V(C^\star)\backslash \{f_1\}\subset
X^\star\)</span>.</font></p>
<p><font color='blue'>Since all edges of G corresponding to the edge of
<span class="math inline">\(C^\star\)</span>​ separate G into two
parts</font> <font color='red'>(i.e. these edges form an
edge-cut)</font><font color='blue'>, Let X be the set of vertices in one
part. It follows from a lemma that </font> <span class="math display">\[
\textcolor{blue}{\sum_{e\in E^{+}(v)}f(e)-\sum_{e\in E^{-}(v)}f(e)=0}
\]</span> <font color='blue'>So the clain follows.</font></p>
<hr />
<p>This completes the whole proof.</p>
<p><font color='red'>Recall: Every Eulerian graph G has a cycle
decomposition: edges of G can be decomposed into edge-disjoint
cycles.</font></p>
<p>A cycle cover of a graph is a family of cycles which cover all edges
of G.</p>
<p>A graph has a cycle cover <span
class="math inline">\(\Leftrightarrow\)</span> it has even-subgraph
cover.</p>
<p><strong>Thm If a graph G has k-even-subgraph cover, then G has a
nowhere-zero <span class="math inline">\(2^k\)</span>-flow</strong></p>
<hr />
<p><strong>Proof</strong></p>
<p>For each even-subgraph <span class="math inline">\(H_i\)</span>, it
has a 2-flow <span class="math inline">\((D,f_i)\)</span>.</p>
<p>So <span class="math inline">\((D,f)\)</span> is a nowhere-zero <span
class="math inline">\(2^k\)</span>-flow where <span
class="math inline">\(f=\sum_{e\in E(G)}2^{i-1}f_i(e)\)</span></p>
<hr />
<p><strong>(8-flow theorem,Jaeger) Every bridgeless graph has
nowhere-zero 8-flow</strong></p>
<p><strong>(Splitting Lemma) Let G be a connected graph without
cut-edge.If G has a vertex v of degree at least four. Then there are two
edges <span class="math inline">\(e_1\)</span> and <span
class="math inline">\(e_2\)</span> incident with v s.t. the resulting
graph after splitting <span class="math inline">\(e_1\)</span> and <span
class="math inline">\(e_2\)</span> from v remains to be connected and
without cut-edge.</strong></p>
<p><font color='red'>(Cycle double cover conjecture,1970s) Every
connected cubic graph without cut-edge has a family of cycles covering
every edge exactly twice.</font></p>
<p>A proper k-edge-coloring of a graph G is a map <span
class="math inline">\(c:E(G)\to[k]\)</span> s.t. <span
class="math inline">\(c(e)\not=c(e&#39;)\)</span> if <span
class="math inline">\(e\)</span> and <span
class="math inline">\(e&#39;\)</span> have a common end vertex.</p>
<p><strong>Thm Every 3-edge-colorable cubic graph has a family of cycles
which cover every edge exactly twice</strong></p>
<hr />
<p><strong>Proof</strong></p>
<p>Let <span class="math inline">\(c:E(G)\to[3]\)</span>. Then <span
class="math inline">\(c^{-1}(1)\cup c^{-1}(2)\)</span> is a family of
cycles, <span class="math inline">\(c^{-1}(1)\cup c^{-1}(3)\)</span> is
a family of cycles, <span class="math inline">\(c^{-1}(2)\cup
c^{-1}(3)\)</span> is a family of cycles. <span class="math display">\[
l_{e_1}=c^{-1}(1)\cup c^{-1}(2),l_{e_2}=c^{-1}(1)\cup
c^{-1}(3),l_{e_3}=c^{-1}(2)\cup c^{-1}(3)
\]</span> So <span class="math inline">\(l_{e_1}\cup l_{e_2}\cup
l_{e_3}\)</span> is a family of cycles which cover every edge exactly
twice.</p>
<hr />
<p><font color='blue'>(3-flow conjecture) Every 5-edge connected graph
has a nowhere-zero 3-flow.</font></p>
<p><font color='red'>A graph is a k-edge-connected if for any two
vertices x ang y, the graph has k edge-disjoint paths joining x and
y.</font></p>
<p><font color='blue'>(Tutte-Nashwillam Theorem) Every 2k-edge-connected
graph has a k edge-disjoint spanning trees.</font></p>
<p><font color='blue'>(Lovasz,Wu,Thomassen,Zhang,2012) Every
6-edge-connected graph has a nowhere-zero 3-flow.</font></p>
<p><font color='blue'>(5-flow conjecture.1950s) Every bridgeless graph
has a nowhere-zero 5-flow</font></p>
<p><font color='blue'>(Seymour,1980) Every bridgeless graph has a
nowhere-zero 6-flow.</font></p>
<p><font color='blue'>For cubic graph,cycle double cover conjecture<span
class="math inline">\(\approx\)</span> the strong embedding
conjecture</font></p>
<p><font color='blue'>(Strong Embedding Conjecture,1980s) Every
2-connected graph can be embedded on a closed surface such that every
face is bounded by a cycle.</font></p>
]]></content>
      <categories>
        <category>Graph Theory</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Operation Research</tag>
      </tags>
  </entry>
  <entry>
    <title>SVD-Dominnant Correlation</title>
    <url>/2024/06/05/SVD-Dominnant%20Correlation/</url>
    <content><![CDATA[<h2 id="dominant-correlation">Dominant Correlation</h2>
<p>Here we introduce one of the most useful interpretation of the SVD.
It is in terms of correlations among the columns of <span
class="math inline">\(X\)</span> and correlations among the rows of
<span class="math inline">\(X\)</span>. We claim that the matrix <span
class="math inline">\(U\)</span> and <span
class="math inline">\(V\)</span> given by the SVD can be seen as the
eigenvectors of a correlation matrix given by <span
class="math inline">\(XX^T\)</span> or <span
class="math inline">\(X^TX\)</span>. Now we try to explain this
claim.</p>
<span id="more"></span>
<p>We consider the structure of the correlation matrix <span
class="math inline">\(X^TX\)</span> firstly. Since the size of the data
matrix <span class="math inline">\(X\)</span> is <span
class="math inline">\(n\times m\)</span>, the size of the correlation
matrix <span class="math inline">\(X^TX\)</span> is <span
class="math inline">\(m\times m\)</span>. <span class="math display">\[
X^TX=\begin{bmatrix}\cdots&amp;x_1^T&amp;\cdots\\\cdots&amp;x_2^T&amp;\cdots\\\
&amp;\vdots&amp;\
\\\cdots&amp;x_m^T&amp;\cdots\end{bmatrix}\begin{bmatrix}\vdots&amp;\vdots&amp;\
&amp;\vdots\\x_1&amp;x_2&amp;\cdots&amp;x_m\\\vdots&amp;\vdots&amp;\
&amp;\vdots\end{bmatrix}=\begin{bmatrix}x_1^Tx_1&amp;x_1^Tx_2&amp;\cdots&amp;x_1^Tx_m\\x_2^Tx_1&amp;x_2^Tx_2&amp;\cdots&amp;x_2^Tx_m\\\vdots&amp;\vdots&amp;\
&amp;\vdots\\x_m^Tx_1&amp;x_m^Tx_2&amp;\cdots&amp;x_m^Tx_m\end{bmatrix}
\]</span> Based on the definition of <span
class="math inline">\(X^TX\)</span>, we realize that <span
class="math inline">\(X^TX\)</span> is a correlation matrix among the
columns of <span class="math inline">\(X\)</span>. All entries of <span
class="math inline">\(X^TX\)</span> are essentially an inner product
between two columns of the data matrix <span
class="math inline">\(X\)</span>. Interestingly, if the entry <span
class="math inline">\(x_i^Tx_j\)</span> is a large number, it means that
the columns <span class="math inline">\(x_i\)</span> and <span
class="math inline">\(x_j\)</span> are highly correlated. However, if
this number is very small, it means that the columns <span
class="math inline">\(x_i\)</span> and <span
class="math inline">\(x_j\)</span> are nearly orthogonal, which means
that the columns <span class="math inline">\(x_i\)</span> and <span
class="math inline">\(x_j\)</span> are almost different. Therefore, the
correlation matrix <span class="math inline">\(X^TX\)</span> can be seen
as a matrix that measures the correlation among the columns of <span
class="math inline">\(X\)</span>.</p>
<p>Based on the structure of the correlation matrix <span
class="math inline">\(X^TX\)</span>, <span
class="math inline">\(X^TX\)</span> is a symmetric and positive
semi-definite matrix. It guarantees that we have non negative real
eigenvalues, which have a direct correspondence on the singular values
of the data matrix <span class="math inline">\(X\)</span>. Now we assume
that the matrix <span class="math inline">\(X\)</span> have the singular
value decomposition <span class="math inline">\(X=U\Sigma V^T\)</span>.
We can derive that <span class="math display">\[
X^TX=V\Sigma^TU^TU\Sigma V^T=V\Sigma^2 V^T\Rightarrow X^TXV=V\Sigma^2
\]</span> which means that the columns of <span
class="math inline">\(V\)</span> are the eigenvectors of the correlation
matrix <span class="math inline">\(X^TX\)</span>. The eigenvalues of the
correlation matrix <span class="math inline">\(X^TX\)</span> are the
squares of the singular values of the data matrix <span
class="math inline">\(X\)</span>. The same is true for the correlation
matrix <span class="math inline">\(XX^T\)</span>. We can derive that
<span class="math display">\[
XX^T=U\Sigma V^TV\Sigma U^{T}=U\Sigma^2 U^T\Rightarrow XX^TU=U\Sigma^2
\]</span> which means that the columns of <span
class="math inline">\(U\)</span> are the eigenvectors of the correlation
matrix <span class="math inline">\(XX^T\)</span>. The eigenvalues of the
correlation matrix <span class="math inline">\(XX^T\)</span> are the
squares of the singular values of the data matrix <span
class="math inline">\(X\)</span>. Therefore, we can conclude that the
singular matrix <span class="math inline">\(U\)</span> and <span
class="math inline">\(V\)</span> given by the SVD of the data matrix
<span class="math inline">\(X\)</span> can be seen as the eigenvectors
of the correlation matrix <span class="math inline">\(X^TX\)</span> or
<span class="math inline">\(XX^T\)</span>. The importance of this
columns of <span class="math inline">\(U\)</span> and <span
class="math inline">\(V\)</span> is quantified by eigenvalues of <span
class="math inline">\(X^TX\)</span> or <span
class="math inline">\(XX^T\)</span>, which are the squares of the
singular values of the data matrix <span
class="math inline">\(X\)</span>.</p>
<p>Here we introduce the method of snapshots to compute the singular
value decomposition of the data matrix. If the data matrix <span
class="math inline">\(X\)</span> is so large that you cannot actually
compute it or store it all in memory, you can use the method of
snapshots. However, in the vast majority of cases, we don't recommend
that you compute the SVD using correlation matrices.</p>
<p>Although you cannot load all columns of <span
class="math inline">\(X\)</span> into memory, what you can do is calling
two columns at a time. For example, you can call the first column <span
class="math inline">\(x_1\)</span> and itself, then you will get the
inner product <span class="math inline">\(x_1^Tx_1\)</span>. After, you
can call the first column <span class="math inline">\(x_1\)</span> and
the second column <span class="math inline">\(x_2\)</span>, then you
will get the inner product <span class="math inline">\(x_1^Tx_2\)</span>
and so on. You can compute the inner product by calling two columns of
data matrix each time to get the correlation matrix <span
class="math inline">\(X^TX\)</span>. Here the resulting matrix is a
<span class="math inline">\(m\times m\)</span> matrix. It is small
enough that you can put it into memory and compute its
eigendecomposition. Based the above discussion, we know that the righ
singular vector <span class="math inline">\(V\)</span> and the singular
value <span class="math inline">\(\Sigma\)</span> can be goten by this
eigendecomposition. Then you can use this matrix to solve the left
singular vector <span class="math inline">\(U\)</span>.</p>
]]></content>
      <categories>
        <category>Reduced Order Model</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>SVD-Linear Regression</title>
    <url>/2024/06/21/SVD-Linear%20Regression/</url>
    <content><![CDATA[<p>Now we are ready to talk about building linear regression models from
data. When we have gotten measurement data in experiments, it is
important to construct a linear regression model as a predictive model.
The basic structure of the linear regression is defined as follows,
<span class="math display">\[
Ax=b
\]</span> where <span class="math inline">\(A\in\mathbb{R}^{n\times
m}\)</span> and <span class="math inline">\(b\in\mathbb{R}^{n}\)</span>
are given by the measurement. Therefore, building a linear regression is
equal to solve the linear system <span
class="math inline">\(Ax=b\)</span>. Here we just consider the over
determined system <span class="math inline">\(n&gt;m\)</span> since it
is often what we have in modern data. We will use the least square
estimate to solve the vector <span class="math inline">\(x\)</span>.</p>
<span id="more"></span>
<p>To explain this linear regression more clearly, let's say that every
rows of equation is based on data from an individual medical history. So
the equation <span
class="math inline">\(a_{i1}x_1+\cdots+a_{im}x_{m}=b_{i}\)</span> means
the medical case of the <span class="math inline">\(i-th\)</span>
person. Every columns of matrix <span class="math inline">\(A\)</span>
represent different kinds of risk factors and the vector <span
class="math inline">\(b\)</span> means the risk of heart disease.
Therefore, we can give a interpretation about linear regression. Linear
regression is a best fit model <span class="math inline">\(x\)</span>
for what combination of those factors describe best or predict best the
future risk of heart disease. Actually it may be driven by the nonlinear
system in real world, here we oversimplify this system by using linear
regression to approximate it.</p>
<p>Since we consider the overdetermined system, it is hard to find a
vector <span class="math inline">\(x\)</span> that exactly solves this
linear model. We want to find the best fit vector <span
class="math inline">\(x\)</span> that minimizes the error norm between
<span class="math inline">\(Ax\)</span> and <span
class="math inline">\(b\)</span>. In other words, the best fit vector
<span class="math inline">\(x\)</span> gives us the best prediction of
<span class="math inline">\(b\)</span> given information in <span
class="math inline">\(A\)</span>. Here we consider a one-dimensional
linear regression model since it can be easily plotted in the following
figure and gives a geometric interpretation of linear regression. Of
course, the conclusion derived in this way is very simple and can be
generalized to much higher-dimensional situations.</p>
<p><img
src="https://cdn.jsdelivr.net/gh/LYD122504/picx-images-hosting@master/2024-06-20_20-56-36_screenshot.7i08u20nua.png" /></p>
<p>As seen in figure, we will solve the <span
class="math inline">\(x\)</span> here that we want is the slope of this
fit line. We generalize this interpretation to much higher dimensional
case instead of having just one factor that I use to predict <span
class="math inline">\(b\)</span>. In general, I will find a best fit
plane instead of best fit line to approximate the high dimensional data.
In one dimensional, <span class="math inline">\(A=\begin{bmatrix} a_1\
a_2\ \cdots\ a_n\end{bmatrix}^{T}\)</span> and <span
class="math inline">\(b=\begin{bmatrix}b_1\ b_2\ \cdots\
b_n\end{bmatrix}^{T}\)</span> will be considered. Based on the SVD, we
can give the decompostion matrices <span
class="math inline">\(U=\frac{A}{\Vert A\Vert_2}\)</span>, <span
class="math inline">\(\Sigma=\Vert A\Vert_2\)</span> and <span
class="math inline">\(V^T=1\)</span> easily. Using Moore-Penrose pseudo
inverse of <span class="math inline">\(A\)</span>, we can solve the best
fit slope <span class="math inline">\(x\)</span> as follows, <span
class="math display">\[
x=A^{\dagger}b=\frac{A^T}{\Vert A\Vert_2^2}b
\]</span> Due to the value of the best fit slope, we find that the
linear regression can be written as <span
class="math inline">\(Ax=AA^{\dagger}b=\frac{AA^T}{\Vert
A\Vert_2^2}b\)</span>. It means that we project <span
class="math inline">\(b\)</span> into the direction of <span
class="math inline">\(A\)</span>. When we think about the projection, we
realize that the normalized matrix <span
class="math inline">\(\tilde{A}=\frac{A}{\Vert A\Vert_2}\)</span>
satisfies <span
class="math inline">\(\tilde{A}^T\tilde{A}=\frac{A^TA}{\Vert
A\Vert_2}=1\)</span>. From this, we can use this normalized matrix <span
class="math inline">\(\tilde{A}\)</span> to derive the projection
operator <span
class="math inline">\(\tilde{A}(\tilde{A}^T\tilde{A})\tilde{A}^T=\tilde{A}\tilde{A}^{T}=\frac{AA^T}{\Vert
A\Vert_2^2}\)</span>. This formula can be generalized into higher
dimensional case easily.</p>
<p>At last, we consider a very common problem that our data has some
outliers in data analysis. As seen in the above figure, these data do
not fully mathch our best fitting model. Since the normal data can have
some variablity, like Gaussian noisy, our linear regression just is a
approximation model to real world. Here we assume that our data has a
outlier which is completely different with others. It will bias my
distrubution and effect the best fit slope, since the purpose of our
derivation is minimizing the sum of the squares of the errors of all of
those points to the line. Therefore, it is a big risk we have when we
have outliers. Regularly square based on the SVD can handle white noise
very well. However, the matrix <span class="math inline">\(A\)</span>
will be sensitive to outliers, we will consider in robust
statistics.</p>
]]></content>
      <categories>
        <category>Reduced Order Model</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>SVD-Eckart-Young-Mirsky theorem</title>
    <url>/2024/05/28/SVD-Eckart_Young_Mirsky/</url>
    <content><![CDATA[<p>Firstly, we introduce three different kinds of matrix norms and based
on singular value decomposition, verify that these norms are only
related to singular values.</p>
<ol type="1">
<li>2-norm (Spectral norm)</li>
</ol>
<p><span class="math display">\[
\left\Vert
A\right\Vert_2=\sqrt{\lambda_{max}(A^TA)}=\sqrt{\lambda_{max}(U\Sigma
V^TV\Sigma U^T)}=\sqrt{\lambda_{max}(\Sigma^2)}=\sigma_1
\]</span></p>
<ol type="1">
<li>Frobenius norm</li>
</ol>
<p><span class="math display">\[
\left\Vert A\right\Vert_F=\sqrt{tr(A^TA)}=\sqrt{tr(U\Sigma V^TV\Sigma
U^T)}=\sqrt{tr(\Sigma^2)}=\sqrt{\sum_{i=1}^m\sigma_i^2}
\]</span></p>
<ol type="1">
<li>Nuclear norm</li>
</ol>
<p><span class="math display">\[
\left\Vert
A\right\Vert_N=\sigma_1+\sigma_2+\dots+\sigma_m=\sum_{i=1}^m\sigma_i
\]</span></p>
<span id="more"></span>
<p>Based on the results of matrix norms, we realize that the above three
matrix norms only depend on the singular values of the matrix <span
class="math inline">\(A\)</span>. Now we claim that the product with
orthogonal matrices will not change the singular values of the original
matrix. For simplicity, we call the left orthogonal matrix and right
orthogonal matrix as <span class="math inline">\(P\)</span> and <span
class="math inline">\(Q\)</span>, respectively. Based on the singular
value decomposition of <span class="math inline">\(A\)</span>, we can
derive the following results about the product of matrix <span
class="math inline">\(A\)</span> and orthogonal matrices <span
class="math inline">\(P,\ Q\)</span>, <span class="math display">\[
PAQ=PU\Sigma V^TQ=U_1\Sigma V_1^T,\ U_1=PU,\ V_1=Q^TV
\]</span> where <span
class="math inline">\(U_1U_1^T=PUU^TP^T=I=U_1^TU_1\)</span> means <span
class="math inline">\(U_1\)</span> is an orthogonal matrix. The same is
true for <span class="math inline">\(V_1\)</span>. We claim that the
singular values of <span class="math inline">\(PAQ\)</span> is the same
as the singular values of <span class="math inline">\(A\)</span>. So we
realize that the product with orthogonal matrices does not affect matrix
norm.</p>
<p><strong>Thm(Eckart-Young-Mirsky Theorem)</strong> The optimal rank-r
approximation to <span class="math inline">\(A\)</span>, under the
spectral norm and the Frobenius norm, respectively, is given by the
rank-r SVD truncation <span class="math inline">\(\tilde{A}\)</span>,
<span class="math display">\[
argmin_{\hat{A},\ s.t.\ rank(\hat{A})=r}\left\Vert
A-\hat{A}\right\Vert_F=\tilde{A}\quad argmin_{\hat{A},\ s.t.\
rank(\hat{A})=r}\left\Vert A-\hat{A}\right\Vert_2=\tilde{A}
\]</span> where <span
class="math inline">\(\tilde{A}=\tilde{U}\tilde{\Sigma}\tilde{V}^T\)</span>
is the rank-r SVD truncation of <span class="math inline">\(A\)</span>.
Again, <span class="math inline">\(\tilde{U}\)</span> and <span
class="math inline">\(\tilde{V}\)</span> denote the first <span
class="math inline">\(r\)</span> leading columns of <span
class="math inline">\(U\)</span> and <span
class="math inline">\(V\)</span>, respectively, and <span
class="math inline">\(\tilde{\Sigma}\)</span> is the <span
class="math inline">\(r\times r\)</span> leading submatrix of <span
class="math inline">\(\Sigma\)</span>.</p>
<p>Proof.</p>
<ol type="1">
<li><p>One needs to show that if we have a matrix approximation <span
class="math inline">\(B\)</span> whose rank is <span
class="math inline">\(r\)</span> and size is <span
class="math inline">\(n\times m\)</span>, then <span
class="math inline">\(\left\Vert A-B\right\Vert_2\geq \left\Vert
A-\tilde{A}\right\Vert_2\)</span> holds. This can be done as
follows.</p>
<p>Here we introduce the concept of matrix kernel before the discussion.
The kernel of matrix <span class="math inline">\(A\)</span> is defined
as <span class="math display">\[
   \mathcal{N}(A)=\{x\in \mathbb{R}^n:Ax=0\}
\]</span> Therefore, we realize that the kernel of matrix <span
class="math inline">\(\mathcal{N}(A)\)</span> actually means the
solution space of the linear equation <span
class="math inline">\(Ax=0\)</span>. Based on the linear equation
theory, we know that when the rank of matrix <span
class="math inline">\(B\)</span> is <span
class="math inline">\(r\)</span>, the dimension of <span
class="math inline">\(\mathcal{N}(B)\)</span> is <span
class="math inline">\(n-r\)</span>. Here we consider the linear space
<span class="math inline">\(V_{r+1}\)</span> spanned by the first <span
class="math inline">\(r+1\)</span> leading right singular vectors <span
class="math inline">\(v_1,\ v_2,\dots,v_{r+1}\)</span>, whose dimension
is <span class="math inline">\(r+1\)</span>. Based on the dimensional
formula, we derive that <span class="math display">\[
   dim(\mathcal{N}(B)\cap
V_{r+1})=dim(\mathcal{N}(B))+dim(V_{r+1})-dim(\mathcal{N}(B)+V_{r+1})=n+1-dim(\mathcal{N}(B)+V_{r+1})\geq1
\]</span> which means that <span
class="math inline">\(\mathcal{N}(B)\cap V_{r+1}\not=\empty\)</span>.
Therefore, we have that there exists an vector <span
class="math inline">\(x=\gamma_1v_1+\cdots+\gamma_{r+1}v_{r+1}\)</span>
such that <span class="math display">\[
   x\in \mathcal{N}(B)\cap V_{r+1},\ \left\Vert x\right\Vert_2=1
\]</span> Based on the definition of 2-norm, we can derive that <span
class="math display">\[
   \left\Vert A-B\right\Vert_2\geq \left\Vert
(A-B)x\right\Vert_2=\left\Vert
Ax\right\Vert_2=\gamma_1^2\sigma_1^2+\cdots+\gamma_{r+1}^2\sigma_{r+1}^2\geq
\sigma_{r+1}^2=\left\Vert A-\tilde{A}\right\Vert_2
\]</span> which means that the optimal rank-r approximation to <span
class="math inline">\(A\)</span> under the 2-norm is given by the rank-r
SVD truncation <span class="math inline">\(\tilde{A}\)</span>.</p></li>
<li><p>Now we claim that the best rank <span
class="math inline">\(r\)</span> approximation to <span
class="math inline">\(A\)</span> in the Frobenius norm, denoted by <span
class="math inline">\(\Vert\cdot\Vert_F\)</span>, is given by <span
class="math display">\[
A_r=U_r\Sigma_rV_r^T=\sum_{i=1}^r\sigma_iu_iv_i^T
\]</span> First, note that we have <span class="math display">\[
\left\Vert A-A_k\right\Vert_F^2=\left\Vert
\sum_{i=r+1}^m\sigma_iu_iv_i^T\right\Vert_F^2=\sum_{i=r+1}^m\sigma_i^2
\]</span> Hence, we need to show that if <span
class="math inline">\(B_r\)</span> is any rank-<span
class="math inline">\(r\)</span> matrix, then, <span
class="math display">\[
\left\Vert A-B_r\right\Vert_F^2\geq \sum_{i=r+1}^m\sigma_i^2
\]</span> Based on the triangle inequality with the spectral norm, if
<span class="math inline">\(A=A&#39;+A&#39;&#39;\)</span>, then <span
class="math inline">\(\sigma_1(A)\leq\sigma_1(A&#39;)+\sigma_1(A&#39;&#39;)\)</span>.
Suppose <span class="math inline">\(A_r&#39;\)</span> and <span
class="math inline">\(A_r&#39;&#39;\)</span> denote the rank <span
class="math inline">\(r\)</span> approximation to <span
class="math inline">\(A&#39;\)</span> and <span
class="math inline">\(A&#39;&#39;\)</span> by SVD method described
above, respectively. Then, for any <span
class="math inline">\(i,j\geq1\)</span> <span class="math display">\[
\begin{aligned}
\sigma_i(A&#39;)+\sigma_j(A&#39;&#39;)&amp;=\sigma_1(A&#39;-A_{i-1}&#39;)+\sigma_1(A&#39;&#39;-A_{j-1}&#39;&#39;)\\
&amp;\geq\sigma_1(A&#39;-A_{i-1}&#39;+A&#39;&#39;-A_{j-1}&#39;&#39;)\\
&amp;\geq\sigma_1(A-A_{i-1}&#39;-A_{j-1}&#39;&#39;)\\
\end{aligned}
\]</span> Here we know that <span
class="math inline">\(rank(A_{i-1}&#39;+A_{j-1}&#39;&#39;)\leq
i+j-2\)</span>, we can derive that</p></li>
</ol>
<p><span class="math display">\[
\begin{aligned}
\sigma_i(A&#39;)+\sigma_j(A&#39;&#39;)&amp;\geq\sigma_1(A-A_{i+j-2})\\
&amp;=\sigma_{i+j-1}(A)
\end{aligned}
\]</span> Since <span
class="math inline">\(\sigma_{r+1}(B_r)=0\)</span>, when <span
class="math inline">\(A&#39;=A-B_r\)</span> and <span
class="math inline">\(A&#39;&#39;=B_r\)</span>, we conclude that for
<span class="math inline">\(i\geq1,\ j=r+1\)</span> <span
class="math display">\[
\sigma_i(A-B_r)= \sigma_i(A-B_r)+\sigma_{r+1}(B_r)\geq\sigma_{i+r}(A)
\]</span> Therefore, we have <span class="math display">\[
\left\Vert
A-B_r\right\Vert_F^2=\sum_{i=1}^m\sigma_i(A-B_r)^2\geq\sum_{i=r+1}^m\sigma_i(A)^2=\left\Vert
A-A_r\right\Vert_F^2
\]</span></p>
]]></content>
      <categories>
        <category>Reduced Order Model</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>SVD-Mathematical Overview</title>
    <url>/2024/04/18/SVD-Mathematical%20Overview/</url>
    <content><![CDATA[<p>​ Firstly, we consider a large data matrix <span
class="math inline">\(X\in \mathbb{C}^{n\times m}\)</span>:</p>
<p><span class="math display">\[
X=\begin{bmatrix}\vdots&amp;\vdots&amp;\
&amp;\vdots\\x_1&amp;x_2&amp;\cdots&amp;x_m\\\vdots&amp;\vdots&amp;\
&amp;\vdots\end{bmatrix}
\]</span> The column <span class="math inline">\(x_k\in
\mathbb{C}^n\)</span> is obtained from simulations or experiments.
Here,we always consider the column vectors may also represent the state
of a physical system that is evolving in time.The column are often
called snapshots and <span class="math inline">\(m\)</span> is the
number of snapshots in <span class="math inline">\(X\)</span>.</p>
<p>The Singular Value Decomposition allows us to decompose any
complex-valued matrix as the product of three other matrices,</p>
<span id="more"></span>
<p><span class="math display">\[
X=U\Sigma V^T=\begin{bmatrix}\vdots&amp;\vdots&amp;\
&amp;\vdots\\u_1&amp;u_2&amp;\cdots&amp;u_n\\\vdots&amp;\vdots&amp;\
&amp;\vdots\end{bmatrix}\begin{bmatrix}\sigma_1&amp;\ &amp;\ &amp;\ \\\
&amp;\sigma_2&amp;\ &amp;\ \\\ &amp;\ &amp;\ddots&amp;\ \\
\ &amp;\ &amp;\ &amp;\sigma_m\\\ &amp;\ &amp;\ &amp;\ \\\ &amp;\ &amp;\
&amp;\ \\\ &amp;\ &amp;\ &amp;\
\end{bmatrix}\begin{bmatrix}\vdots&amp;\vdots&amp;\
&amp;\vdots\\v_1&amp;v_2&amp;\cdots&amp;v_m\\\vdots&amp;\vdots&amp;\
&amp;\vdots\end{bmatrix}^T
\]</span> where <span class="math inline">\(U\in \mathbb{C}^{n\times
n}\)</span> and <span class="math inline">\(V\in\mathbb{C}^{m\times
m}\)</span> are unitary matrices. If a square matrix <span
class="math inline">\(U\)</span> satisfies <span
class="math inline">\(U^{\star}U=UU^{\star}=I\)</span>, we call it
unitary matrix. Here * denotes the complex conjugate transpose. For
real-valued matrices, it is the same as the regular transpose, <span
class="math inline">\(X^{\star}=X^T\)</span>. So if <span
class="math inline">\(U\)</span> and <span
class="math inline">\(V\)</span> are real-valued matrices, we call them
orthogonal matrices. Since the conclusions of real-valued and
complex-valued <span class="math inline">\(U\)</span> and <span
class="math inline">\(V\)</span> are parallel, we will only discuss the
real-valued case in the following. <span class="math inline">\(\Sigma\in
\mathbb{R}^{n\times m}\)</span> is a diagonal matrix, which means
real,non-zero entries on thediagonal and zeros off the diagonal.</p>
<p>​ These column of <span class="math inline">\(U\)</span> have the same
shape as a column of <span class="math inline">\(X\)</span>. The columns
of <span class="math inline">\(U\)</span> describe the eigen of the data
in <span class="math inline">\(X\)</span>. So in the case of faces,
these mean eigenfaces and in the case of flow fields, these mean
eigenflow fields. Furthermore, the columns of <span
class="math inline">\(U\)</span> are hierarchically arranged in terms of
their ability to describe the variance in the column of <span
class="math inline">\(X\)</span>. In other words, <span
class="math inline">\(u_1\)</span> is somehow more important than <span
class="math inline">\(u_2\)</span> and so on and so forth.</p>
<p>​ <span class="math inline">\(U\)</span> gives me a basis, based on
which we can represent each column of original data in <span
class="math inline">\(X\)</span>.Actually, these basis have great
properties. Since <span class="math inline">\(U\)</span> is an unitary
matrix, it means the column of <span class="math inline">\(U\)</span>
are orthonormal. So these column are all orthogonal , have unit length
and provide a complete basis for n-dimensional subspace where the column
of data matrix lives.</p>
<p>​ <span class="math inline">\(\Sigma\)</span> is not only a diagnol
matrix, but also non-negative and hierarchically ordered matrix. So we
have <span
class="math inline">\(\sigma_1\geq\sigma_2\geq\sigma_3\geq\cdots\geq\sigma_m\geq0\)</span>.
They are all non-negative, although some of them could be zero.
According to the matrix multiplication, we can find that <span
class="math inline">\(\sigma_1\)</span> correspond to the first columns
of <span class="math inline">\(U\)</span> and <span
class="math inline">\(V\)</span>.Since <span
class="math inline">\(\sigma_1\geq\sigma_2\)</span>, it means that the
first columns are somehow important than the second ones when we
describe the information of <span class="math inline">\(X\)</span>. In
other words, the sigular value provides the relative imporatance of
these corresponding columns of <span class="math inline">\(U\)</span>
and <span class="math inline">\(V\)</span>. Finally, we say that the
sigular values are ordered by importance.</p>
<p>​ Here we will start in the case of flow fields. The columns of <span
class="math inline">\(U\)</span> will be eigen flows hierarchically
organized. We call the first column of <span
class="math inline">\(V\)</span> as <span
class="math inline">\(v_1\)</span>. So <span
class="math inline">\(v_1\)</span> would be the time series for how this
first eigen mode <span class="math inline">\(u_1\)</span> evolves in
this flow.</p>
<p>The matrix <span class="math inline">\(U\)</span> is called left
sigular column and the columns are called left singular vectors. <span
class="math inline">\(V\)</span> is similar to <span
class="math inline">\(U\)</span>. The diagonal elements of <span
class="math inline">\(\Sigma\)</span> are called sigular values.The rank
of X is equal to the number of non-zero sigular value.</p>
]]></content>
      <categories>
        <category>Reduced Order Model</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>SVD-Linear System and Pseudo Inverse</title>
    <url>/2024/06/18/SVD-Linear%20System%20and%20Pseudo%20Inverse/</url>
    <content><![CDATA[<p>In many physics problem, we always encounter the solution of the
linear equation <span class="math inline">\(Ax=b\)</span>. Classically,
we solve this linear equation in the case that <span
class="math inline">\(A\)</span> is a square and invertible matrix. In
fact, this case is too special to better model the real world. Based on
the singular value decomposition which we have introduced, we can
generalize this linear equation to the case that <span
class="math inline">\(A\)</span> is a non-square matrix. Actually, when
we consider the data analysis and data modeling, the matrix <span
class="math inline">\(A\)</span> is always a non-square matrix.</p>
<span id="more"></span>
<p>Here we introduce few different things happened due to the non-square
matrix <span class="math inline">\(A\in\mathbb{R}^{n\times m}\)</span>.
Since A is a non-square matrix, there are two canonical non-square
matrix <span class="math inline">\(A\)</span>, corresponding to the two
different canonical non-square linear equations.</p>
<ol type="1">
<li>Underdetermined System <span class="math inline">\((n&lt;m)\)</span>
Since <span class="math inline">\(n&lt;m\)</span>, the shape of the
matrix <span class="math inline">\(A\)</span> is short and fat. In this
case, the number of equations is less than the number of unknowns. There
is not enough measurements in vector <span
class="math inline">\(b\)</span> to determine a single unique vector
<span class="math inline">\(x\)</span>. In other words, there is more
degrees of freedom in the unknown vector <span
class="math inline">\(x\)</span> and there is not enough values in the
vector <span class="math inline">\(b\)</span> to determine the unknown
vector <span class="math inline">\(x\)</span>. In general, there are
infinitely many solutions <span class="math inline">\(x\)</span> given
by the underdetermined system. In fact, you can try to construct a very
special underdetermined system such that there is only one solution. But
it is too special that we can ignore it.</li>
<li>Overdetermined System <span class="math inline">\((n&gt;m)\)</span>
Since <span class="math inline">\(n&gt;m\)</span>, the shape of the
matrix <span class="math inline">\(A\)</span> is tall and skinny. In
this case, the number of equations is more than the number of unknowns.
Unfortunately, since there is not enough degrees of freedom in unknown
vector <span class="math inline">\(x\)</span> to fit these equation,
there is no solution <span class="math inline">\(x\)</span> given by the
overdetermined system generally. In fact, you can try to construct a
very special underdetermined system such that there is only one
solution. But it is too special that we can ignore it.</li>
</ol>
<p>The singular value decomposition allows us to approximately invert
this matrix <span class="math inline">\(A\)</span> to compute what is
known as the pseudo inverse and find a best fit solution <span
class="math inline">\(x\)</span> that either comes as close to solving
this equation as possible or solves this equation with the minimum <span
class="math inline">\(L^2\)</span> norm of <span
class="math inline">\(x\)</span>. Here we introduce the Moore-Penrose
pseudo inverse of the matrix <span class="math inline">\(A\)</span>.
Based on the economy singular value decomposition of the matrix <span
class="math inline">\(A\)</span>, we can decompose the matrix <span
class="math inline">\(A\)</span> as <span
class="math inline">\(A=U\Sigma V^T\)</span>, where <span
class="math inline">\(U\)</span> and <span
class="math inline">\(V\)</span> satisfy <span
class="math inline">\(U^TU=I\)</span> and <span
class="math inline">\(V^TV=VV^T=I\)</span>. The Moore-Penrose pseudo
inverse of the matrix <span class="math inline">\(A\)</span> is defined
as <span class="math display">\[
A^{\dagger}=V\Sigma^{-1}U^T
\]</span> Based on the properties of <span
class="math inline">\(U\)</span> and <span
class="math inline">\(V\)</span>, we realize that the Moore-Penrose
pseudo inverse is a left pseudo inverse of the matrix <span
class="math inline">\(A\)</span>. Now we can give a approximate solution
of the linear equation <span class="math inline">\(Ax=b\)</span> by
using the Moore-Penrose pseudo inverse of the matrix <span
class="math inline">\(A\)</span>. <span class="math display">\[
Ax=b\Rightarrow U\Sigma V^Tx=b\Rightarrow
\tilde{x}=V\Sigma^{-1}U^Tb=A^{\dagger}b
\]</span> Here we have given a best fit solution <span
class="math inline">\(x\)</span> which comes as close to solving this
equation as possible. Now we will give out this solution which satisfies
the optimization problems. Now we give the optimization problems that
the best fit solution <span class="math inline">\(x\)</span> satisfies
for underdetermined system and overdetermined system.</p>
<ol type="1">
<li><p>Underdetermined System <span
class="math inline">\((n&lt;m)\)</span> In this case, the best fit
solution <span class="math inline">\(x\)</span> satisfies the
optimization problem <span class="math display">\[
   \min_x\|x\|_2\quad\text{subject to}\quad Ax=b
\]</span> The solution of this optimization problem is the solution of
the linear equation <span class="math inline">\(Ax=b\)</span> with the
minimum <span class="math inline">\(L^2\)</span> norm of <span
class="math inline">\(x\)</span>.</p></li>
<li><p>Overdetermined System In this case, the best fit solution <span
class="math inline">\(x\)</span> satisfies the optimization problem
<span class="math display">\[
   \min_x\|Ax-b\|_2
\]</span> The solution of this optimization problem is the solution of
the linear equation <span class="math inline">\(Ax=b\)</span> that comes
as close to solving this equation as possible.</p>
<p>Finally, we will clarify something that is highly confusing: the
method of obtaining the optimal approximation solution is same as the
normal process,but it is just an approximate solution. Here we
substitute the approximate solution <span
class="math inline">\(\tilde{x}=A^{\dagger}b\)</span> into the linear
equation <span class="math inline">\(Ax=b\)</span>. <span
class="math display">\[
   A\tilde{x}=AA^{\dagger}b=U\Sigma V^TV\Sigma^{-1}U^Tb=UU^Tb
\]</span> where the matrix <span class="math inline">\(UU^T\)</span> is
not a identity matrix and it might not even be close to the identity
matrix. Before we explain the vector <span
class="math inline">\(UU^Tb\)</span>, we should discuss the project
operator. Here we assume that we have a vector <span
class="math inline">\(v\)</span> and a matrix <span
class="math inline">\(P\)</span>. Now we try to project the vector <span
class="math inline">\(v\)</span> onto the column space of the matrix
<span class="math inline">\(P\)</span>. We assume the projection of the
vector <span class="math inline">\(v\)</span> onto the column space of
the matrix <span class="math inline">\(P\)</span> is <span
class="math inline">\(Px\)</span>, where <span
class="math inline">\(x\)</span> is an unknown vector. Based on the
definition of the projection, the vector <span
class="math inline">\(e=v-Px\)</span> and all column vectors of <span
class="math inline">\(P\)</span> are orthogonal. Therefore, we can
derive the following linear equaiton, <span class="math display">\[
   P^Te=P^T(v-Px)=P^Tv-P^TPx=0\Rightarrow x=(P^TP)^{-1}P^Tv
\]</span> From the above result, we can derive the projection vector
<span class="math inline">\(Px=P(P^TP)^{-1}P^Tv\)</span>. Here we call
<span class="math inline">\(P(P^TP)^{-1}P^T\)</span> as the projection
operator. Now we consider the matrix <span
class="math inline">\(U\)</span> which satisfies <span
class="math inline">\(U^TU=I\)</span>, so the projection operator <span
class="math inline">\(U(U^TU)^{-1}U^T=UU^T\)</span>. Above all, the
meaning of <span class="math inline">\(UU^Tb\)</span> is the projection
of the vector <span class="math inline">\(b\)</span> onto the column
space of the matrix <span class="math inline">\(U\)</span>. Furthermore,
the column space of the matrix <span class="math inline">\(U\)</span> is
equal to the column space of the matrix <span
class="math inline">\(A\)</span>. Therefore, the vector <span
class="math inline">\(UU^Tb\)</span> is the projection of the vector
<span class="math inline">\(b\)</span> onto the column space of the
matrix <span class="math inline">\(A\)</span>. The errors crops up since
<span class="math inline">\(UU^Tb\)</span> is an orthogonal projection
of <span class="math inline">\(B\)</span> onto the column space of <span
class="math inline">\(A\)</span>.</p></li>
</ol>
]]></content>
      <categories>
        <category>Reduced Order Model</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>SVD-Matrix Approximation</title>
    <url>/2024/04/19/SVD-Matrix%20Approximation/</url>
    <content><![CDATA[<p>The SVD allows us to decompose data matrix <span
class="math inline">\(X\)</span> as the product of three matrices, <span
class="math inline">\(U,\ V^T,\ \Sigma\)</span>, where essentially <span
class="math inline">\(U\)</span> contains information about the column
space of <span class="math inline">\(X\)</span>, <span
class="math inline">\(V\)</span> contains information about the row
space of <span class="math inline">\(X\)</span> and <span
class="math inline">\(\Sigma\)</span> is a hierarchically ordered
diagonal matrix, which tells you how important the various columns of
<span class="math inline">\(U\)</span> and <span
class="math inline">\(V\)</span> are.</p>
<span id="more"></span>
<p>In fact, the data matrix <span class="math inline">\(X\)</span> has
only <span class="math inline">\(m\)</span> columns, it means there are
at most <span class="math inline">\(m\)</span> linearly independence
columns in this <span class="math inline">\(n\)</span>-dimensional
vector space.So the first <span class="math inline">\(m\)</span> columns
of <span class="math inline">\(U\)</span> are important in representing
this data matrix. To explain this fact more deeply, we try to represent
expansion as a sum of rank-1 matrices.</p>
<p>Based on the Singular Value Decomposition,we can get the following
equation, <span class="math display">\[
X=U\Sigma V^T=\begin{bmatrix}\vdots&amp;\vdots&amp;\
&amp;\vdots\\u_1&amp;u_2&amp;\cdots&amp;u_m\\\vdots&amp;\vdots&amp;\
&amp;\vdots\end{bmatrix}\begin{bmatrix}\sigma_1&amp;\ &amp;\ &amp;\ \\\
&amp;\sigma_2&amp;\ &amp;\ \\\ &amp;\ &amp;\ddots&amp;\ \\
\ &amp;\ &amp;\ &amp;\sigma_m\\\ &amp;\ &amp;\ &amp;\ \\\ &amp;\ &amp;\
&amp;\ \\\ &amp;\ &amp;\ &amp;\
\end{bmatrix}\begin{bmatrix}\cdots&amp;v_1^{T}&amp;\cdots\\\cdots&amp;v_2^T&amp;\cdots\\\
&amp;\vdots&amp;\ \\\cdots&amp;v_m^T&amp;\cdots\end{bmatrix}^T
\]</span> Since <span class="math inline">\(\Sigma\)</span> is a
diagnoal matrix, we can expand the above equation as follow, <span
class="math display">\[
X=U\Sigma
V^T=\sigma_1u_1v_1^T+\sigma_2u_2v_2^T+\cdots+\sigma_mu_mv_m^T=\begin{bmatrix}\vdots&amp;\vdots&amp;\
&amp;\vdots\\u_1&amp;u_2&amp;\cdots&amp;u_m\\\vdots&amp;\vdots&amp;\
&amp;\vdots\end{bmatrix}\begin{bmatrix}\sigma_1&amp;\ &amp;\ &amp;\ \\\
&amp;\sigma_2&amp;\ &amp;\ \\\ &amp;\ &amp;\ddots&amp;\ \\
\ &amp;\ &amp;\
&amp;\sigma_m\end{bmatrix}\begin{bmatrix}\cdots&amp;v_1^{T}&amp;\cdots\\\cdots&amp;v_2^T&amp;\cdots\\\
&amp;\vdots&amp;\
\\\cdots&amp;v_m^T&amp;\cdots\end{bmatrix}^T=\hat{U}\hat{\Sigma}V^T
\]</span> Even though <span class="math inline">\(U\)</span> is a
massive <span class="math inline">\(n\times n\)</span> matrix, there are
only at most <span class="math inline">\(m\)</span> non-zeros singular
values in <span class="math inline">\(\Sigma\)</span> that means the
rank of data matrix <span class="math inline">\(X\)</span> satisfies
<span class="math inline">\(rank(X)\leq m\)</span>. Actually,I can
selcet the first <span class="math inline">\(m\)</span> columns of <span
class="math inline">\(U\)</span>, the first <span
class="math inline">\(m\times m\)</span> block of <span
class="math inline">\(\Sigma\)</span> and the original <span
class="math inline">\(V\)</span> to represent the data matrix <span
class="math inline">\(X\)</span>. We always call <span
class="math inline">\(X=\hat{U}\hat{\Sigma}V^T\)</span> as the economy
SVD and <span class="math inline">\(X=U\Sigma V^T\)</span> as the full
SVD. Since we consider the case of <span class="math inline">\(n\gg
m\)</span>, <span class="math inline">\(\hat{U}\in \mathbb{R}^{n\times
m}\)</span> and <span class="math inline">\(\hat{\Sigma}\in
\mathbb{R}^{m\times m}\)</span> need lower storage.</p>
<p>Therefore, we can give another explanation about SVD: we can
decompose the data matrix X into the orthogonal basis <span
class="math inline">\(U\)</span> and <span
class="math inline">\(V\)</span>, where essentially you can rewrite this
as a sum of rank-1 matrices, which increasingly improve the
approximation of <span class="math inline">\(X\)</span>. According to
this explanation, we can give out some interesting results like, the
best rank-1 matrix that we can make to approximate <span
class="math inline">\(X\)</span> is <span
class="math inline">\(\sigma_1u_1v_1^T\)</span>; the best rank-2 matrix
that we can make to approximate <span class="math inline">\(X\)</span>
is <span
class="math inline">\(\sigma_1u_1v_1^T+\sigma_2u_2v_2^T\)</span> and so
on and so forth.</p>
<p>Since we hope to use less data storage to approximate the real data
as much as possible in practice, we often truncate at rank r. Oftentimes
we have a lot of negligibly small singular values like <span
class="math inline">\(\sigma_{r+1},\
\sigma_{r+2},\cdots,\sigma_m\)</span>, it means that most of the
information of <span class="math inline">\(X\)</span> is captured in the
first <span class="math inline">\(r\)</span> singular values and the
first <span class="math inline">\(r\)</span> singular vectors. So we can
throw away all of low singular values and singular vectors and only keep
the first <span class="math inline">\(r\)</span> columns of <span
class="math inline">\(U\)</span> and <span
class="math inline">\(V\)</span> and the first <span
class="math inline">\(r\times r\)</span> submatrix in <span
class="math inline">\(\Sigma\)</span>. Then we are going to define this
truncated SVD as follows, <span class="math display">\[
X\approx\begin{bmatrix}\vdots&amp;\vdots&amp;\
&amp;\vdots\\u_1&amp;u_2&amp;\cdots&amp;u_r\\\vdots&amp;\vdots&amp;\
&amp;\vdots\end{bmatrix}\begin{bmatrix}\sigma_1&amp;\ &amp;\ &amp;\ \\\
&amp;\sigma_2&amp;\ &amp;\ \\\ &amp;\ &amp;\ddots&amp;\ \\
\ &amp;\ &amp;\
&amp;\sigma_r\end{bmatrix}\begin{bmatrix}\cdots&amp;v_1^{T}&amp;\cdots\\\cdots&amp;v_2^T&amp;\cdots\\\
&amp;\vdots&amp;\
\\\cdots&amp;v_r^T&amp;\cdots\end{bmatrix}^T=\tilde{U}\tilde{\Sigma}\tilde{V}^T
\]</span> Here we find that the truncated SVD <span
class="math inline">\(\tilde{U}\tilde{\Sigma}\tilde{V}^T\)</span> is the
best rank-<span class="math inline">\(r\)</span> matrix approximating
the data matrix <span class="math inline">\(X\)</span>.Thus,
high-dimensional data may be well described by a few dominant patterns
given by the columns of <span class="math inline">\(\tilde{U}\)</span>
and <span class="math inline">\(\tilde{V}\)</span>.Like the mentioned in
the first section,we realize that the truncated singular vectors <span
class="math inline">\(\tilde{U}\)</span> provides a coordinate
transformation from the high-dimensional measurement space into a
low-dimensional pattern space.</p>
<p>The Eckart-Young theorem states that the absolute best approximation
to the matrix <span class="math inline">\(X\)</span> of rank r,
Theorem(Eckart-Young) The optimal rank-r approximation to <span
class="math inline">\(X\)</span>, in a least-squares sense, is given by
the rank-r SVD truncation <span
class="math inline">\(\tilde{X}\)</span>, <span class="math display">\[
argmin_{\tilde{X},\ s.t.\ rank(\tilde{X})=r}\left\Vert
X-\tilde{X}\right\Vert_F=\tilde{U}\tilde{\Sigma}\tilde{V}^T
\]</span> The Ecakrt-Young theorem guarantees that the best possible
matrix approximation to <span class="math inline">\(X\)</span> of rank
<span class="math inline">\(r\)</span> is given by the firsr <span
class="math inline">\(r\)</span> truncated SVD.</p>
<p>Finally,we should mention an important point. At beginning of
discussing the SVD, we define the matrices <span
class="math inline">\(U\)</span> and <span
class="math inline">\(V\)</span> are unitary. However,if we truncated at
rank r,the truncated matrices <span
class="math inline">\(\tilde{U}\)</span> and <span
class="math inline">\(\tilde{V}\)</span> are no longer square matrices,
so they are not unitary matrix again. They satisfy that <span
class="math inline">\(\tilde{U}^T\tilde{U}=\tilde{V}^TV=I,\
\tilde{U}\tilde{U}^T\not=I\)</span></p>
]]></content>
      <categories>
        <category>Reduced Order Model</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux-Shell常用指令</title>
    <url>/2024/03/30/linux-1/</url>
    <content><![CDATA[<h1 id="shell-基本命令">Shell 基本命令</h1>
<p>Bash提供了命令行补全的特性.我们可以利用Tab键来完成命令以及文件名的自动补全.如果以已输入的字符开头的文件不止一个,那么连续输入两次Tab键,shell将会以列表的形式给出所有以输入字符开头的文件名.</p>
<p>同样我们可以补全Linux命令,这是因为Linux的命令本质上是一些可执行文件,所以可以认为命令补全和文件名补全其实是同一件事.</p>
<p>此外,Shell在查找文件中存在通配符的专用符号,其为*,?,[].这些通配符可以搜索并匹配文件名的一部分,从而可以做到批量检索文件.</p>
<span id="more"></span>
<ol type="1">
<li><p>*用于匹配文件名中任意长度的字符串.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> *.cpp <span class="comment">## 检索以.cpp结尾的文件</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>?和*类似,但是与*匹配任意长度的字符串不同,?只能匹配一个字符串</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> text? <span class="comment">## 检索文件名中以text开头并且后面接一个字符的文件.</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>[]用于匹配所有出现在方括号内的字符.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> text[1A]  <span class="comment">## 用于列出以text开头而仅以1或者A结束的文件</span></span></span><br></pre></td></tr></table></figure>
<p>如果需要查找多个连续字符范围的,可以利用短线-来指定一个字符集范围.所有包含在上下界之间的字符都会被匹配.同样可对字母操作,如在ASC码中,A-Z可以包含所有的大写字母.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> text[1-3] <span class="comment">## 用于列出以text开头而仅以1-3中字符结束的文件</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> text[A-Z] <span class="comment">## 用于列出以text开头而仅以大写字母结束的文件</span></span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>虽然我们上面的演示都以通配符位于文件末,但实际上通配符的位置是任意的.并且可以随意搭配使用.</p>
<p><a id="org48c8384"></a></p>
<h2 id="pwd-显示当前目录">pwd: 显示当前目录</h2>
<p>pwd命令会显示当前所在的位置,也就是工作目录.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> /usr/local/bin  <span class="comment">## 进入/usr/local/bin目录</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">pwd</span>                <span class="comment">## 显示当前所在位置</span></span></span><br><span class="line">/user/local/bin</span><br></pre></td></tr></table></figure>
<p><a id="org0a74477"></a></p>
<h2 id="cd-改变目录">cd: 改变目录</h2>
<p>cd是Linux文件系统在不同文件夹之间转移的常用指令.其后一般都加上路径名作为参数表示跳转到相应的位置,但其有一些特殊的路径符号来简化跳转特定文件夹的指令.</p>
<ol type="1">
<li><p>/表示根目录,不管在什么目录下,命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> / <span class="comment">## 跳转到根目录</span></span></span><br></pre></td></tr></table></figure>
<p>都会快速跳转到根目录下.</p></li>
<li><p>..表示当前目录的上一级目录,例如如果现在工作目录都是/usr/bin</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> .. <span class="comment">## 跳转到上一级目录</span></span></span><br></pre></td></tr></table></figure>
<p>其会跳转到上一级目录即/usr中.</p></li>
<li><p>.表示当前目录,我们如果需要跳转到当前目录的某个文件夹中可以用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> ./xxx  <span class="comment">## 跳转到同级目录中的下级目录</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>~表示用户主目录,其一般是/home/下名称为用户名的文件夹,在其中存储对应用户的数据和设置.同样我们可以用cd命令不加任何参数来跳转到用户主目录.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> ~  <span class="comment">## 跳转到用户主目录</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span>    <span class="comment">## 跳转到用户主目录</span></span></span><br></pre></td></tr></table></figure></li>
</ol>
<p><a id="orge55b477"></a></p>
<h2 id="ls-列出目录内容">ls: 列出目录内容</h2>
<p>ls命令实际上是list的简化形式.list的用法十分多,但其基本语法是</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls [OPTION]... [FILE]... ## ls命令的基本形式</span><br></pre></td></tr></table></figure>
<p>最简单的情况,我们直接在任意工作目录下输入ls命令,用于列出当前目录下所有文件和子目录.为了区分文件目录和文件,linux系统会用不同颜色来标注不同的类型.由于不同的系统对于颜色渲染不太一样,甚至可能没有颜色,我们可以用-F参数的ls命令,-F会在每个目录后面加上/,在可执行文件后加*,在链接文件后加@.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -F <span class="comment">##列出文件并且在列出的文件名称后加一符号</span></span></span><br></pre></td></tr></table></figure>
<p>虽然我们可以用ls列出当前目录下的所有内容,但实际上有很多的名称以.开头的文件并未展示,我们称这类文件为隐含文件,在默认情况下是不会展示的.我们可以用参数-a来显示所有的文件.对于命令的参数是可以组合使用的,并且制定多个选项只需要用一个短线即可.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -a  <span class="comment">## 列出所有文件及目录(以.开头的隐含文件也会被列出)</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -aF <span class="comment">## 列出所有文件和目录的同时加上一个后缀符号</span></span></span><br></pre></td></tr></table></figure>
<p>ls另外一个比较常见的参数是-l,这个选项可以用来查看文件的各种属性,</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l  <span class="comment">## 列出所有文件和目录以及其对应的属性</span></span></span><br><span class="line">  总计 152</span><br><span class="line">  drwxr-xr-x  2 lyd  lyd   4096  2月  5 09:49  公共</span><br><span class="line">  drwxr-xr-x  2 lyd  lyd   4096  2月  5 09:49  模板</span><br><span class="line">  drwxr-xr-x  2 lyd  lyd   4096  2月  5 09:49  视频</span><br><span class="line">  drwxr-xr-x  3 lyd  lyd   4096  2月 25 20:55  图片</span><br><span class="line">  drwxr-xr-x  2 lyd  lyd   4096  2月  5 09:49  文档</span><br><span class="line">  drwxr-xr-x  2 lyd  lyd   4096  3月 14 15:39  下载</span><br><span class="line">  drwxr-xr-x  2 lyd  lyd   4096  2月  5 09:49  音乐</span><br><span class="line">  drwxr-xr-x  2 lyd  lyd   4096  2月  5 09:49  桌面</span><br></pre></td></tr></table></figure>
<p>这一共有九个不同的信息栏,从左到右依次表示,</p>
<ol type="1">
<li>文件的权限标志(后续会进一步讨论其含义)</li>
<li>文件连接个数(同上)</li>
<li>文件所有者的用户名</li>
<li>该用户所在的用户组祖名(后续会讨论)</li>
<li>文件的大小</li>
<li>最后一次修改时的月份</li>
<li>最后一次修改的日期</li>
<li>最后一次修改的时间</li>
<li>文件名</li>
</ol>
<p>ls命令后接路径名,可以直接查看子目录的内容,</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> /etc/init.d/ <span class="comment">## 用来查看/etc/init.d/的内容</span></span></span><br></pre></td></tr></table></figure>
<p>除了ls命令可以列出目录,我们也可以用windows系统常用的dir命令来列出,但其功能比ls要少.我们也可以用vdir来代替ls
-l来列出目录和文件的完整信息.但由于ls的功能明显更为强大,我们就不再多介绍dir和vdir的用法.</p>
<p><a id="org824b1c7"></a></p>
<h2 id="cat-和-more-查看文本文件">cat 和 more: 查看文本文件</h2>
<p>cat命令用于查看文件内容(一般是文本文件,如果打开的是PDF或者其他形式的文件会以文本文件的形式打开),后跟文件名作为参数.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> xxx <span class="comment">## 查看文件内容</span></span></span><br></pre></td></tr></table></figure>
<p>cat后面的文件名参数可以添加多个文件名,同样也可以用通配符来批量查看文件.</p>
<p>为了调试方便,我们可以用-n参数来在展示的文本文件形式的每行前面显示行号</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> -n xxxx <span class="comment">## 查看文件内容的同时显示行号</span></span></span><br></pre></td></tr></table></figure>
<p>但是当我们打开多个文件的时候,用-n参数并不会智能地区分每个文件的终止,而是连续的对行号进行递增编号.</p>
<p>但由于cat命令会将文件的内容全部展示在shell命令行之上,对于内容较多的文件,这样的打开方式并不合适.因此我们可以用more命令来一页页的显示文章内容,</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">more XXX <span class="comment">## 以分页的形式展示文件内容</span></span></span><br><span class="line">....</span><br><span class="line">--More-- (75%) </span><br></pre></td></tr></table></figure>
<p>more命令会在最后显示一个百分比,其表示已显示内容占整个文件的比例.我们可以用空格键向下翻一页,用Enter则可以向下滚动一行,用Q退出文本文件展示.</p>
<p>more命令和cat一样可以添加多个文件名,也可以通配符来批量查看文件.</p>
<p><a id="orge830626"></a></p>
<h2 id="head-和-tail-查看文件的开头和结尾">head 和 tail:
查看文件的开头和结尾</h2>
<p>head和tail用于展示文件的开头和结尾.我们可以用-n参数来修改展示的行数,如果我们不加-n命令手动修改展示行数,那么会默认展示10行的内容.head命令的默认输出是包括输出文件名,但不会计入展示文件开头的行数,我们可以用-q参数来取消输出文件名.不仅如此,head后面还可以接多个文件名,用于批量展示多个文件的开头和结尾.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">head</span> -n k xxx <span class="comment">## 展示文件前k行,如果没有-n参数,默认展示文件的前10行</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">head</span> -q xxx <span class="comment">## 不展示文件名</span></span></span><br></pre></td></tr></table></figure>
<p>tail和head的用法完全一致.</p>
<p><a id="org41780dc"></a></p>
<h2 id="less-更好的文本阅读工具">less: 更好的文本阅读工具</h2>
<p>less和前面提到的more十分类似,都不能对文本文件进行修改,也支持打开多个文本文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">less ~/.bashrc <span class="comment">## 用less查看文件</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">~/.bashrc: executed by bash(1) <span class="keyword">for</span> non-login shells.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">see /usr/share/doc/bash/examples/startup-files (<span class="keyword">in</span> the package bash-doc)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="keyword">for</span> examples</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">If not running interactively, don<span class="string">&#x27;t do anything</span></span></span><br><span class="line">case $ - in</span><br><span class="line">    *i*) ;;</span><br><span class="line">      *) return;;</span><br><span class="line">esac</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">don&#x27;</span>t put duplicate lines or lines starting with space <span class="keyword">in</span> the <span class="built_in">history</span>.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">See bash(1) <span class="keyword">for</span> more options</span></span><br><span class="line">HISTCONTROL=ignoreboth</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">append to the <span class="built_in">history</span> file, don<span class="string">&#x27;t overwrite it</span></span></span><br><span class="line">shopt -s histappend</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">for setting history length see HISTSIZE and HISTFILESIZE in bash(1)</span></span></span><br><span class="line">HISTSIZE=1000</span><br><span class="line">HISTFILESIZE=2000</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">check the window size after each command and, if necessary,</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">update the values of LINES and COLUMNS.</span></span></span><br><span class="line">:</span><br></pre></td></tr></table></figure>
<p>在屏幕的末尾会有一个冒号,其表示等待用户输入命令.在此我们罗列常用的移动命令,</p>
<ul>
<li><SPC> 向下滚动一页</li>
<li><Enter> 向下滚动一行</li>
<li>b 向上翻一页</li>
<li>y 向上滚动一行</li>
<li>d 向下翻半页</li>
<li>u 向上翻半页</li>
</ul>
<p>在less查看的文本文件中,我们还可以用/跟上想要查找的内容,来实现对文本内容的检索,less会把第一个搜索目标高亮显示,如果我们还需要查找相同内容,我们只需要用n来跳转到下一个搜索目标,同样如果我们需要跳转到前一次的搜索结果我们可以用N来跳转.</p>
<p>实际上/并不是全文检索,而是以光标为基准向后搜索字符串,相反我们可以用?来以光标为基准向前搜索字符串.</p>
<p>由于less的用法较多,可以在冒号后接h来打开less自带的帮助文档查看指令及其作用.</p>
<p>为了展示更多的文件信息,我们可以用-M来展示更多的文件信息,</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">  $ </span><span class="language-bash">less -m ~/.bashrc</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">~/.bashrc: executed by bash(1) <span class="keyword">for</span> non-login shells.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">see /usr/share/doc/bash/examples/startup-files (<span class="keyword">in</span> the package bash-doc)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="keyword">for</span> examples</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">If not running interactively, don<span class="string">&#x27;t do anything</span></span></span><br><span class="line">case $ - in</span><br><span class="line">    *i*) ;;</span><br><span class="line">      *) return;;</span><br><span class="line">esac</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">don&#x27;</span>t put duplicate lines or lines starting with space <span class="keyword">in</span> the <span class="built_in">history</span>.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">See bash(1) <span class="keyword">for</span> more options</span></span><br><span class="line">HISTCONTROL=ignoreboth</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">append to the <span class="built_in">history</span> file, don<span class="string">&#x27;t overwrite it</span></span></span><br><span class="line">shopt -s histappend</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">for setting history length see HISTSIZE and HISTFILESIZE in bash(1)</span></span></span><br><span class="line">HISTSIZE=1000</span><br><span class="line">/home/lyd/.bashrc lines 1-19/114 15%</span><br></pre></td></tr></table></figure>
<p>less在输出的底部显示了文件名,当前行数,总行数以及所占百分比.最后可以用Q推出less程序.</p>
<p><a id="org6891801"></a></p>
<h2 id="grep-查找文件内容">grep: 查找文件内容</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep [OPTIONS] PATTERN [FILE...]  ## grep一般形式</span><br></pre></td></tr></table></figure>
<p>如果我们想在文件A中查找包含test的行,可以用如下命令,</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">grep <span class="built_in">test</span> A</span></span><br></pre></td></tr></table></figure>
<p>从上面的命令我们可以看出grep后面接两个不同类型的参数,第一个是被搜索的关键词,也称之为模式,第二个则是所搜索的文件.grep会将文件中出现关键词的行输出,并且grep可指定多个文件来搜索.另外我们用grep查找的是关键词,对于查找如Debian
Ubunut这样的关键词,我们需要用单引号来将空格包含在关键词中,不然grep会认为关键词为Debian,在文件名为Ubuntu的文件中查找.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">grep <span class="string">&#x27;Debian Ubuntu&#x27;</span> linux  <span class="comment">##在linux文件中查找关键词 Debian Ubuntu</span></span></span><br></pre></td></tr></table></figure>
<p>我们列出一些常用的grep命令选项,</p>
<ul>
<li>-i 忽略大小写进行匹配</li>
<li>-r 进行递归查找子目录中的文件</li>
<li>-l 仅输出存在匹配的文件名</li>
<li>-c 输出匹配的行数</li>
<li>-v 反向查找,只打印不匹配的行</li>
</ul>
<p>grep实际上是以正则表达式的形式对文件进行查找,针对扩展的正则表达式,我们可以用egrep来查找.</p>
<p><a id="org676ae04"></a></p>
<h2 id="find-文件查找">find: 文件查找</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find [OPTION] [path...] [expression] ## find命令的基本语法</span><br></pre></td></tr></table></figure>
<p>find命令需要一个路径名作为查找范围,find会深入该路径中的每个子目录中寻找,如果我们指定的路径名为/,那么就会在整个文件系统中搜索.下给出一个find命令的实例,</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">find /usr/bin -name zip -<span class="built_in">print</span> <span class="comment">##在/usr/bin的目录下查找zip</span></span></span><br><span class="line">/usr/bin/zip</span><br></pre></td></tr></table></figure>
<p>这里的/usr/bin就是find的查找范围,-name指定了查找条件以文件名为基准,此处支持用通配符*和?.-print表示将结果输出到屏幕,实际上可以不需要加这个动作指令,find会默认将其输出.值得注意的是find输出的结果是文件的绝对路径.</p>
<p>我们在此罗列find常用的查找条件的参数,</p>
<ul>
<li>-name pattern: 按照文件名查找,支持使用通配符</li>
<li>-size [+-]size[cwbkMG]:
按文件大小查找,支持使用+或-来表示大于或小于指定大小,单位可以是c(字节),w(字数),b(块数),k(KB),M(MB)或G(GB).</li>
<li>-mtime days:
按修改时间查找,支持使用+或-表示在指定天数前或后,days是一个整数表示天数</li>
<li>-user username: 按照文件所有者查找</li>
<li>-group groupname: 按文件所属组查找</li>
<li>-type type: 按照文件类型查找,type的参数含义如下表所示</li>
</ul>
<div data-align="center">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<colgroup>
<col  class="org-left" />
</colgroup>
<colgroup>
<col  class="org-left" />
</colgroup>
<colgroup>
<col  class="org-left" />
</colgroup>
<colgroup>
<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">
参数
</th>
<th scope="col" class="org-left">
含义
</th>
<th scope="col" class="org-left">
参数
</th>
<th scope="col" class="org-left">
含义
</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">
b
</td>
<td class="org-left">
块设备文件
</td>
<td class="org-left">
f
</td>
<td class="org-left">
普通文件
</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">
c
</td>
<td class="org-left">
字符设备文件
</td>
<td class="org-left">
p
</td>
<td class="org-left">
命名管道
</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">
d
</td>
<td class="org-left">
目录文件
</td>
<td class="org-left">
l
</td>
<td class="org-left">
符号链接
</td>
</tr>
</tbody>
</table>
</div>
<p>我们介绍find对匹配到的文件执行的操作,</p>
<ul>
<li>-amin n: 查找在n分钟被访问过的文件</li>
<li>-atime n: 查找在n*24小时内被访问的文件</li>
<li>-cmin n: 查找在n分钟内状态发生变化的文件(例如权限)</li>
<li>-ctime n: 查找在n*24小时内状态发生过变化的文件(例如权限)</li>
<li>-mmin n: 查找在n分钟内被修改过的文件</li>
<li>-mtime n: 查找在n*24小时内被修改过的文件</li>
</ul>
<p>上面的参数n可以是正数,负数亦或是0.正数+n表示查找比指定时间更早的文件或目录,负数-n表示查找在指定时间内的文件或目录,0表示当天的文件或目录</p>
<p><a id="org3ded0d1"></a></p>
<h2 id="locate-快速定位文件">locate: 快速定位文件</h2>
<p>由于find在查找大批量文件中将花费大量的文件,因此我们可以用locate来代替find,在Ubuntu系统中locate并没有内置安装,因此我们先用apt包管理器下载locate,</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt-get install mlocate <span class="comment">## 下载locate命令及相关依赖</span></span></span><br></pre></td></tr></table></figure>
<p>locate的底层逻辑是并不去查找每个子目录,而是在/var/lib/slocate资料库里查找,因此locate的查找并不是及时的,需要对数据库进行更新,一般来说系统每天会自动更新一次,当然也可以用命令自己手动的更新,</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo updatedb <span class="comment">## 手动更新locate的文件名数据库</span></span></span><br></pre></td></tr></table></figure>
<p>locate查找也可以使用通配符,一些常用的locate命令参数为</p>
<ul>
<li>-c: 只输出找到的数量</li>
<li>-i: 忽略大小写进行查找</li>
<li>-n n: 至多显示n个输出</li>
<li>-h: 显示帮助</li>
</ul>
<p><a id="orgcffd121"></a></p>
<h2 id="whereis-查找特定程序">whereis: 查找特定程序</h2>
<p>whereis命令主要用于查找程序文件并提供该程序的二进制可执行文件,源代码文件和使用手册页存放的位置.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">whereis find <span class="comment">## 寻找find程序文件以及相关的配套文件</span></span></span><br><span class="line">find: /usr/bin/find /usr/share/man/man1/find.1.gz /usr/share/info/find.info-1.gz /usr/share/info/find.info.gz /usr/share/info/find.info-2.gz</span><br></pre></td></tr></table></figure>
<p>我们可以用-b选项来让whereis只返回该程序的二进制可执行文件,</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">whereis -b find <span class="comment">## 寻找find命令的二进制可执行文件</span></span></span><br><span class="line">find: /usr/bin/find</span><br></pre></td></tr></table></figure>
<p>同样,可以用-m选项来让whereis只返回该程序的帮助文件,</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">whereis -m find <span class="comment">## 寻找find命令的帮助文件</span></span></span><br><span class="line">find: /usr/share/man/man1/find.1.gz /usr/share/info/find.info-1.gz /usr/share/info/find.info.gz /usr/share/info/find.info-2.gz</span><br></pre></td></tr></table></figure>
<p>如果查找的文件不存在,那会返回一个空字符串,</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">find xxx</span></span><br><span class="line">xxx:</span><br></pre></td></tr></table></figure>
<p>事实上,whereis命令查找不到文件,不一定是文件不存在,而是有可能不是在whereis的查找目录中,其实whereis并没有查找全文件系统,仅查找了内置的子目录路径,这在查找精度上是一个缺陷,但对于查找的速度来说是一个显著提升.</p>
<p><a id="org99ede03"></a></p>
<h2 id="用户版本信息查看">用户版本信息查看</h2>
<p>who可以查看当前系统有哪些人登陆使用,以及他们使用的工作台,</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"> <span class="built_in">who</span> <span class="comment">## 查看当前使用系统的用户</span></span></span><br></pre></td></tr></table></figure>
<p>whoami用来查看自己是以什么身份进入系统的</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">whoami</span> <span class="comment">## 查看自己进入系统的身份</span></span></span><br></pre></td></tr></table></figure>
<p>上面这两个命令对于PC系统的应用不大,主要是对于服务器系统的查看,因为不同的用户会有不同的权限,因此需要用这个来查看用户身份.</p>
<p>uname是用来显示当前系统的版本信息.-a选项会显示当前的操作系统的所有有用的信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">uname</span> -a <span class="comment">## 显示当前的操作系统的所有有用的信息</span></span></span><br><span class="line">Linux lyd-Lenovo-330S-14IKB 6.5.0-25-generic #25~22.04.1-Ubuntu SMP PREEMPT_DYNAMIC Tue Feb 20 16:09:15 UTC 2 x86_64 x86_64 x86_64 GNU/Linux</span><br></pre></td></tr></table></figure>
<p>如果只需要查看处理器类型,-m选项可以只输出这个结果,</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">uname</span> -m</span></span><br><span class="line">x86_64</span><br></pre></td></tr></table></figure>
<h2 id="man-寻求帮助">man: 寻求帮助</h2>
<p>linux可以用man命令接某个命令的名称来获取该命令的帮助文档,</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">man find <span class="comment">## 查看find的帮助文档</span></span></span><br></pre></td></tr></table></figure>
<p>man命令显示手册页用的是less程序.对于其上下移动和vim的操作一样,不再赘述.</p>
<h2 id="whatis-和-apropos-获取命令简介">whatis 和 apropos:
获取命令简介</h2>
<p>由于man查找的是帮助文档,因此太过冗长.我们可以用whatis命令快速得到命令的简要介绍,</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">whatis find  <span class="comment">## 获取命令的简要介绍</span></span></span><br><span class="line">find (1)             - search for files in a directory hierarchy</span><br></pre></td></tr></table></figure>
<p>但如果我们想要实现某个功能但不知道用什么命令时,我们可以选用apropos来反向查找,如</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">apropos search  <span class="comment">##反向搜索使用的命令</span></span></span><br><span class="line">apropos (1)          - search the manual page names and descriptions</span><br><span class="line">apt-patterns (7)     - Syntax and semantics of apt search patterns</span><br><span class="line">badblocks (8)        - search a device for bad blocks</span><br><span class="line">bsearch (3)          - binary search of a sorted array</span><br><span class="line">bzegrep (1)          - search possibly bzip2 compressed files for a regular e...</span><br><span class="line">bzfgrep (1)          - search possibly bzip2 compressed files for a regular e...</span><br><span class="line">bzgrep (1)           - search possibly bzip2 compressed files for a regular e...</span><br><span class="line">Data::DPath::Context (3pm) - Abstraction for a current context that enables i...</span><br><span class="line">find (1)             - search for files in a directory hierarchy</span><br><span class="line">git-bisect (1)       - Use binary search to find the commit that introduced a...</span><br><span class="line">hsearch (3)          - hash table management</span><br><span class="line">hsearch_r (3)        - hash table management</span><br><span class="line">lfind (3)            - linear search of an array</span><br></pre></td></tr></table></figure>
<p>可以发现apropos实际上是检索命令简介中包含关键词的条目罗列出,让用户选择.</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Computer Science</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>SVD-Unitary Transformation and Geometry</title>
    <url>/2024/06/16/SVD-Unitary%20Transformation/</url>
    <content><![CDATA[<p>In the singular value decomposition of the data matrix <span
class="math inline">\(X\)</span>, we have the two unitary matrices <span
class="math inline">\(U\)</span> and <span
class="math inline">\(V\)</span>. We have introduced that the unitary
matrices satisfy <span class="math inline">\(U^TU=UU^T=I\)</span> and
<span class="math inline">\(VV^T=V^TV=I\)</span>. Here these identity
matrices have different size.</p>
<span id="more"></span>
<p>Actually, unitary matrices preserve the angle between any two vectors
in the vector space. Since the inverse of the unitary matrix is its own
transpose, it can not only preserve the angles between vectors, but also
preserve the length of the vectors. Essentially, unitary transformation
is a coordinate transformation into a new representation. It just takes
all of those vectors and rotates them into a new representation. It will
not change the length of any vector and angles between any two
vectors.</p>
<p>Here you will find that we just consider the real-valued case.
However, when we consider the data matrix <span
class="math inline">\(X\)</span> is a complex-valued matrix, the
singular vectors <span class="math inline">\(U\)</span> and <span
class="math inline">\(V\)</span> are complex-valued matrices. Compared
with the real-valued matrix, the most important difference is that the
transpose of a complex-valued matrix is actually a conjugate
transpose.</p>
<p>To sum up, we give the mathematical form of unitary transformation
here. For any two vectors <span class="math inline">\(x\)</span> and
<span class="math inline">\(y\)</span> in vector space, then we have
<span class="math display">\[
(x,y)=(Ux,Uy)
\]</span> where <span class="math inline">\((\cdot,\cdot)\)</span> is
the inner product of two vectors and the operator <span
class="math inline">\(U\)</span> means the unitary transformation, which
in a unitary matrix in discrete case. Based on this mathematical form,
we realize that the inner product of <span
class="math inline">\(x\)</span> and <span
class="math inline">\(y\)</span> is unchanged when we transform <span
class="math inline">\(x\)</span> and <span
class="math inline">\(y\)</span> by unitary transformation.</p>
<p>Since we have introduced the unitary transform in the vector space,
we interpret singular vector decomposition geometrically. Here we
consider the size of data matrix is <span class="math inline">\(n\times
m\)</span>. Now we consider any vector <span
class="math inline">\(\vec{v}\)</span> in space <span
class="math inline">\(\mathbb{R}^m\)</span> and vector <span
class="math inline">\(\vec{v}\)</span> is palced on the unit sphere. As
we all know, the matrix is a linear transformation about the vector.
Therefore, we consider the transformed vector <span
class="math inline">\(X\vec{v}\)</span>, which is placed on the
ellipsoid in the vector space <span
class="math inline">\(\mathbb{R}^n\)</span>. Here the gemoetric
interpretation of the singular value decomposition can be given. The
length of these principal axes are specially given by the singular
values of the data matrix <span class="math inline">\(X\)</span>. The
orientation of this ellipsoid is somehow given by these left singular
vectors in <span class="math inline">\(U\)</span>. Like the
interpretation of linear transformation, <span
class="math inline">\(X\)</span> multiplies the vector on the left side
or on the right side, which corresponds to a change to a rotation of
space. Finally, <span class="math inline">\(X\)</span> is not a square
matrix, so the rotation of the corresponding space is actually a change
in dimensionality.</p>
]]></content>
      <categories>
        <category>Reduced Order Model</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux-文件目录管理</title>
    <url>/2024/04/16/linux-2/</url>
    <content><![CDATA[<h1 id="文件目录管理">文件目录管理</h1>
<p>下表罗列了Linux文件系统中主要目录的内容</p>
<div data-align="center">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<colgroup>
<col  class="org-center" />
</colgroup>
<colgroup>
<col  class="org-center" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-center">
目 录
</th>
<th scope="col" class="org-center">
内 容
</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-center">
/bin
</td>
<td class="org-center">
构建最小系统所需要的命令(最常用的命令)
</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-center">
/boot
</td>
<td class="org-center">
内核和启动文件
</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-center">
/dev
</td>
<td class="org-center">
各种设备文件
</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-center">
/etc
</td>
<td ·class="org-center">系统软件的启动和配置文件</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-center">
/home
</td>
<td class="org-center">
用户的主目录(用户所有数据,极其重要)
</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-center">
/lib
</td>
<td class="org-center">
C编译器的库
</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-center">
/media
</td>
<td class="org-center">
可移动介质的安装点
</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-center">
/opt
</td>
<td class="org-center">
可选的应用软件包(用deb包安装的部分软件在这)
</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-center">
/proc
</td>
<td class="org-center">
进程的映像
</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-center">
/root
</td>
<td class="org-center">
根用户root的主目录
</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-center">
/sbin
</td>
<td class="org-center">
和系统操作有关的命令
</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-center">
/tmp
</td>
<td class="org-center">
临时文件存放点
</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-center">
/usr
</td>
<td class="org-center">
非系统的程序和命令(apt安装的位置)
</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-center">
/var
</td>
<td class="org-center">
系统专用的数据和配置文件
</td>
</tr>
</tbody>
</table>
</div>
<p><a id="org8d61c7d"></a></p>
<span id="more"></span>
<h2 id="mkdir-建立目录">mkdir: 建立目录</h2>
<p>mkdir命令可以一次建立一个或几个目录.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> document picture <span class="comment">## 新建两个目录</span></span></span><br></pre></td></tr></table></figure>
<p>这样的创建是先利用cd到你想创建的位置,再创建目录.用户也可以用绝对路径来新建目录,这样的话不需要用cd来跳转到创建的位置,在任意位置用mkdir加绝对路径即可创建目录,</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> ~/picture/temp <span class="comment">## 在主目录的picture目录下创建temp子目录</span></span></span><br></pre></td></tr></table></figure>
<p>这个命令合法是因为picture目录存在主目录下,如果用户试图在一个不存在的目录下创建新子目录,那命令会报错.为了避免这个报错,我们可以用-p选项来创建目录.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> -p /home/username <span class="comment">## 在home目录下创建username目录,如果他存在那就不去创建</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> -p ~/test1/test2 <span class="comment">## 如果主目录下没有test1,那么不会报错,而是先创建test1再在其中创建test2</span></span></span><br></pre></td></tr></table></figure>
<p><a id="orgfef9599"></a></p>
<h2 id="touch-建立一个空文件">touch: 建立一个空文件</h2>
<p>touch后面接文件名作为参数,可以在当前目录创建一个或多个新文件,</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">touch</span> hello <span class="comment">## 在当前目录创建文件名为hello的文件</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">touch</span> <span class="string">&#x27;hello world&#x27;</span> <span class="comment">## 在当前目录创建文件名为 &#x27;hello world&#x27; 的文件</span></span></span><br></pre></td></tr></table></figure>
<p>如果我们在上面的'hello
world'中不加引号,那touch会认为创建hello和world两个文件.用touch命令创建的文件是空文件,其内不包含任何内容.</p>
<p>touch除了创建空文件的作用,其更重要的用途是更新一个文件的建立日期和时间.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l init.el~ <span class="comment">## 查看文件的时间属性</span></span></span><br><span class="line">-rw-r--r-- 1 lyd lyd 997  2月  5 21:54 init.el~ ## 原来文件时间属性是2024/2/5-21:54</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">touch</span> init.el~ <span class="comment">## 修改文件的时间属性</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l init.el~ <span class="comment">## 查看改过的文件时间属性</span></span></span><br><span class="line">-rw-r--r-- 1 lyd lyd 997  3月 20 20:52 init.el~ ## 改过以后文件时间变成了2024/3/20-20:52</span><br></pre></td></tr></table></figure>
<p>touch命令在自动备份和整理文件文件时非常有用.</p>
<p><a id="org0ba94bd"></a></p>
<h2 id="mv-移动和重命名">mv: 移动和重命名</h2>
<p>mv其实是move的缩写形式.这个命令可以用来移动文件或目录到另一个路径.这里移动到的文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mv</span> hello bin/ <span class="comment">## 把hello文件移动到bin目录下</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mv</span> Photos/ 桌面/ <span class="comment">## 把Photos目录移动到桌面目录下</span></span></span><br></pre></td></tr></table></figure>
<p>由于执行mv命令的时候并不会有任何信息显示,那么如果目标目录中有一个同名文件,不加任何选项的mv命令会强制替换文件.这一行为极其危险,容易强制替换掉一些关键文件.为了避免这种情况出现,我们可以用-i选项来控制覆盖文件与否,</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mv</span> -i hello <span class="built_in">test</span>/ <span class="comment">## 出现同名文件询问是否覆盖</span></span></span><br></pre></td></tr></table></figure>
<p>其会先询问用户是否覆盖旧文件,输入y表示直接覆盖,输入n表示取消移动操作.</p>
<p>另外一个避免强制覆盖的选项是-b,其与-i的询问不同,如果出现同名文件,那么他会在转移之前将目标目录中的同名文件的文件名后面加一个~,形成一个备份,从而避免文件覆盖情况的发生.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mv</span> -b hello <span class="built_in">test</span>/ <span class="comment">## 出现同名文件则对其备份</span></span></span><br></pre></td></tr></table></figure>
<p>Linux中不存在重命名的操作,我们可以认为重命名只不过是在同一级目录下的移动而已.因此我们可以用mv命令来实现对文件或目录的重命名.
如</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mv</span> hello world <span class="comment">## 在同级目录下进行重命名</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mv</span> /home/lyd/hello /home/lyd/learning/world <span class="comment">## 移动到其他目录并且重命名</span></span></span><br></pre></td></tr></table></figure>
<p>使用mv命令可能出现的一些简单情况,</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mv</span> file1 file2 <span class="comment">## 移动file1到file2</span></span></span><br></pre></td></tr></table></figure>
<p>如果file2存在,他的内容会被file1的内容覆盖.如果file2不存在,那就会创建file2.但这两种情况下,file1都不会存在.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mv</span> file1 file2 dir1/ <span class="comment">## 移动file1和file2到目录dir1中</span></span></span><br></pre></td></tr></table></figure>
<p>这个命令的前提是目录dir1必须已经存在.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mv</span> dir1/ dir2/ <span class="comment">## 移动目录dir1到目录dir2</span></span></span><br></pre></td></tr></table></figure>
<p>如果目录dir2不存在,创建目录dir2,并且移动目录dir1的内容到目录dir2中,同时删除目录dir1.如果dir2存在,移动目录dir1及他的内容到目录dir2.</p>
<p><a id="org8b9b032"></a></p>
<h2 id="cp-复制文件和目录">cp: 复制文件和目录</h2>
<p>cp命令用来复制文件和目录.下面的指令用来将test.php复制到test目录下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cp</span> test.php <span class="built_in">test</span>/ <span class="comment">## 复制文件到指定路径</span></span></span><br></pre></td></tr></table></figure>
<p>和mv命令一样,cp在默认情况下也会强制覆盖目标目录中的同名文件.同样我们可以用-i选项来对这种覆盖文件的情况进行提示,我们也可以用-b选项来避免询问,通过对同名文件进行一个修改命名再进行复制.这两个选项的使用和mv命令的一样,因此不再赘述.</p>
<p>如果我们希望复制一个目录到另一个目录下,而直接用cp命令进行复制,则会有如下结果</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cp</span> learning/ Downloads/ <span class="comment">## 报错的复制目录</span></span></span><br><span class="line">cp: 未指定 -r；略过目录 &#x27;learning/&#x27;</span><br></pre></td></tr></table></figure>
<p>这是因为cp命令在执行复制任务的时候会自动跳过目录.如果我们一定要连同目录及其内部的文件一块复制到另一个目录,我们需要用-r选项来实现这一操作.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cp</span> -r learning/ Downloads/ <span class="comment">##  复制目录到指定目录</span></span></span><br></pre></td></tr></table></figure>
<p>使用cp可能出现的一些简单情况,</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cp</span> file1 file2 <span class="comment">## 复制文件file1内容到文件file2</span></span></span><br></pre></td></tr></table></figure>
<p>如果file2存在,那么file2的内容会被file1的内容覆盖.如果file2不存在,那就会创建一个file2.但和mv删除file1不同,cp命令会保留file1.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cp</span> file1 file2 dir1/ <span class="comment">## 复制文件file1和file2到目录dir1</span></span></span><br></pre></td></tr></table></figure>
<p>但这里必须要求目录dir1存在.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cp</span> dir1/* dir2/ <span class="comment">## 用通配符移动文件</span></span></span><br></pre></td></tr></table></figure>
<p>与-r选项不同,用通配符来批量移动dir1中的文件,要求dir2存在并且移动只会复制dir1中的文件和子目录,不会在dir2中复制dir1这个目录.</p>
<p><a id="org9b7d339"></a></p>
<h2 id="rmdir-和-rm-删除目录和文件">rmdir 和 rm: 删除目录和文件</h2>
<p>rmdir命令可以用来删除目录.其只需要在rmdir命令后面接要删除的文件名即可.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> remove <span class="comment">##创建一个空目录</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">rmdir</span> remove <span class="comment">##删除指定的空目录</span></span></span><br></pre></td></tr></table></figure>
<p>但rmdir只能用于删除空目录,一旦试图用其删除非空目录,那么会有如下报错</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">rmdir</span> learning</span></span><br><span class="line">rmdir: 删除 &#x27;learning&#x27; 失败: 目录非空</span><br></pre></td></tr></table></figure>
<p>因此,如果我们想要用rmdir删除非空目录,我们需要先删除该目录下的所有子目录及文件.</p>
<p>对于文件的删除可以用rm命令,其实rm命令也可以针对目录,此处rm命令删除的目录是允许出现非空目录,因此rm的应用远比rmdir更为广泛.rm命令可以一次性删除单个或多个文件,</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">rm</span> <span class="built_in">test</span>/* <span class="comment">## 删除test目录下的所有文件</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">rm</span> halo <span class="comment">## 删除halo文件</span></span></span><br></pre></td></tr></table></figure>
<p>和前面的mv和cp命令一样,rm不会在运行过程中出现任何提示,利用rm命令删除的文件并不会被移入回收站,而是直接从系统中删除.因此为了安全的使用rm,我们一般用-i选项来在删除过程之前给出提示等待用户确认,与前面的mv和cp一样.但有个例外,如果我们删除只读文件,那么即便我们不使用-i选项,rm命令也会对这一操作进行询问</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">rm</span> <span class="built_in">test</span> <span class="comment">## 删除test只读文件</span></span></span><br><span class="line">rm: 是否删除有写保护的普通空文件 &#x27;test&#x27;？ </span><br></pre></td></tr></table></figure>
<p>如果对这个交互操作默认是y,且不想多次交互,我们可以用-f选项来跳过这些交互操作,rm会自动对这些交互操作回答y.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">rm</span> -f <span class="built_in">test</span> <span class="comment">## -f选项跳过交互操作</span></span> </span><br></pre></td></tr></table></figure>
<p>我们可以用带-r选项的rm命令会递归的删除指定目录下所有文件和子目录.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">rm</span> -r Photos/ <span class="comment">## 递归删除Photos目录</span></span></span><br></pre></td></tr></table></figure>
<p>关键在于使用rm
-rf命令一定要注意评估删除的后果,不然可能会破坏系统的稳定性,故慎用rm
-r命令.</p>
<p><a id="org1f6941e"></a></p>
<h2 id="linux文件目录权限">Linux文件目录权限</h2>
<p>Linux的文件目录权限针对三类人群:文件所有者(属主),文件属组用户,其他人.关键在于其他人的多样性,可能会对文件目录内容进行修改,从而有机会造成不可预料的信息损坏.root用户虽然应该归属于上面的其他人,但root用户显然具有对系统任意文件的查看,修改,执行权利,因为root用户拥有控制一台计算机的所有权限.</p>
<p>文件所有者一般是文件的创建者.但这并不是绝对的,root用户可以修改一个文件的属主用户.换言之,在某个用户在linux系统创建了某个文件,此时文件所有者(属主)自动是文件创建者,但后续过程中root用户可以将文件所有者进行转让,这个转让过程也仅能用root用户进行.</p>
<p>当然文件的权限也会被给予一个用户组,我们称这个用户组为文件的属组.组是一群用户组成的一个集合.文件属组中的用户按照设置对文件享有特定的权限.通常而言,当一个用户创建了一个文件,那么该文件的属主就是这个用户,而文件的属组则是有且仅有该用户的用户组.当然我们也可以设置这个文件属组是一个不包括文件属主的用户组.如果文件属主执行文件操作的时候,系统只会关注于文件属主的权限,而文件属组的权限并不会对文件属主的权限造成影响.</p>
<p>其他人则是不包括文件所有者,文件属组用户和root用户以外的其他用户.通常其他人的权限十分低,甚至于无法对文件有任何权限.</p>
<p>可以用来赋予用户的文件和目录的权限为读取(r),写入(w)和执行(x).对于文件而言,读取权限意味着可以打开并查看文件的内容,写入权限控制着对文件的修改权限,至于是否能呢更狗删除和重命名一个文件则是由其父目录的权限设置所控制.要让一个文件可执行,必须设置其执行权限.可执行文件有两类,一类是可以直接由CPU执行的二进制代码,另一类则是Shell脚本程序.</p>
<p>对目录而言,目录的执行权限其实是控制用户是否能够进入该目录,因此目录的执行权限其实上是目录的最基本的权限.而读取权限负责确定能否列出该目录的内容,写入权限则控制在目录中创建,删除和重命名文件.</p>
<p><a id="org3d640d7"></a></p>
<h2 id="ls--l-查看文件类型">ls -l: 查看文件类型</h2>
<p>前面介绍ls命令时,提到了ls
-l来查看文件的属性,此处进一步解释展示的文件属性的参数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l  <span class="comment">## 列出所有文件和目录以及其对应的属性</span></span></span><br><span class="line">  总计 152</span><br><span class="line">  drwxr-xr-x  2 lyd  lyd   4096  2月  5 09:49  公共</span><br></pre></td></tr></table></figure>
<ul>
<li>第一个字段中的第一个字符表示文件类型,这个例子是d,其表示这是一个目录,具体的字符和文件类型的对应下表所示,</li>
</ul>
<div data-align="center">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<colgroup>
<col  class="org-left" />
</colgroup>
<colgroup>
<col  class="org-left" />
</colgroup>
<colgroup>
<col  class="org-left" />
</colgroup>
<colgroup>
<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">
文件类型
</th>
<th scope="col" class="org-left">
符号
</th>
<th scope="col" class="org-left">
文件类型
</th>
<th scope="col" class="org-left">
符号
</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">
普通文件
</td>
<td class="org-left">
-
</td>
<td class="org-left">
本地域套接口
</td>
<td class="org-left">
s
</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">
目录
</td>
<td class="org-left">
d
</td>
<td class="org-left">
有名管道
</td>
<td class="org-left">
p
</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">
字符设备文件
</td>
<td class="org-left">
c
</td>
<td class="org-left">
符号链接
</td>
<td class="org-left">
l
</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">
块设备文件
</td>
<td class="org-left">
b
</td>
<td class="org-left">
 
</td>
<td class="org-left">
 
</td>
</tr>
</tbody>
</table>
</div>
<p>其中具体的含义大概解释如下,Linux一般用设备文件来表示一个特定的硬件设备.Linux中有两类设备文件:字符设备文件和块设备文件.其中字符设备指的是能从他那读取成字符序列的设备,如磁带和串行设备;块设备则是指用来存储数据并对其各部分内容提供同等访问权的设备,如磁盘.一般我们可以称字符设备为顺序访问设备,块设备则为随机访问设备.这是因为块设备可以从硬盘的任何随机位置获取数据,而字符设备则必须按照数据发送的顺序从串行线路上获得.但是系统中存在设备文件,并不代表着他一定链接着相应的硬件设备,而是表示其具有处理对应硬件设备的能力.</p>
<p>关于本地域套接口和有名管道这两个文件涉及到了进程间通信,日常使用并不常见.</p>
<p>符号链接会在后续的ln里介绍,类似于windows系统的快捷方式.</p>
<ul>
<li>接下来的rwxr-xr-x则是三组权限位,断句如下rwx,r-x,r-x,分别代表着属主,属组,其他用户的权限.r表示可读取,w表示可写入,x表示可执行,如果某个权限被禁用,那么其会用短横线-取代.</li>
<li>紧跟着三组权限位的数字表示文件的链接树木.此处是2.表示该目录存在两个链接,关于链接后续会给出介绍.</li>
<li>后面第三个字段和第四个字段表示文件的属主和属组.</li>
</ul>
<p>ls
-l可以用来查看某个特定文件的属性,但是如果我们需要查看目录的属性则需要用ls
-ld命令来查看.</p>
<p><a id="orgaef0396"></a></p>
<h2 id="chown-和-chgrp-改变文件所有权">chown 和 chgrp:
改变文件所有权</h2>
<p>chown命令用于改变文件的所有权.chown命令的基本语法为:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chown [OPTION] ... [OWNER][:[GROUP]] FILE... ## chown语法基本结构</span><br></pre></td></tr></table></figure>
<p>这条命令可以将文件FILE的属主更改为OWNER,属组更改为GROUP.
下面命令给出了一个示例,其将文件的属主更改为LYD,同时将文件属组更改为root组,</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo <span class="built_in">chown</span> LYD:root file <span class="comment">## 修改文件file的属主为LYD,同时修改属组为root组</span></span></span><br></pre></td></tr></table></figure>
<p>如果我们只需要修改文件的属主,那么我们只需要输入OWNER,不需要输入:GROUP.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo <span class="built_in">chown</span> LYD file <span class="comment">## 修改文件file的属主为LYD,但不对属组进行修改</span></span></span><br></pre></td></tr></table></figure>
<p>同样,我们只修改文件属组的话,只需要输入:GROUP,但这里要注意的是冒号:并不是可省略的,省略参数OWNER即可,</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo <span class="built_in">chown</span> :root file <span class="comment">## 修改文件file的属组为root,但不对属主进行操作</span></span></span><br></pre></td></tr></table></figure>
<p>我们在前面用chown修改单个文件的属组和属组.实际上我们可以用chown来修改目录文件的属主和属组,但是显然如果我们只修改目录文件的属主和属组的话,并没有什么意义.因此我们可以利用chown命令的-R选项,用于改变一个目录及其下所有文件(包括子目录)的所有权设置.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo <span class="built_in">chown</span> -R LYD:root iso/ <span class="comment">## 递归修改iso文件及其下的所有文件(包括子目录)的所有权</span></span></span><br></pre></td></tr></table></figure>
<p>由于chown可以更改文件的属主和属组属性,但实际上Linux系统提供了另一个命令chgrp,其专门用来修改文件的属组.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">chgrp</span> nogroup days <span class="comment">## 更改文件属组</span></span></span><br></pre></td></tr></table></figure>
<p>同样和chown一样,我们也可以用-R选项来递归的更改目录及其下所有文件和子目录的属组.但是这里chgrp和chown有一个关键区别在于,chown修改文件属组需要用root用户权限,然而对于chgrp,其只需要修改的用户在文件的属组就可以修改文件的属组.</p>
<p><a id="orgad5e953"></a></p>
<h2 id="chmod-改变文件权限">chmod: 改变文件权限</h2>
<p>chmod用来改变一个文件的权限.其修改删除权限的模式是用户组+/-权限的表达式.具体而言,用户组分为文件属主(u),文件属组(g),其他人(o),以及所有人(a).权限则表示读取(r),写入(w)和执行(x).</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">chmod</span> u+x days <span class="comment">## 为days文件属主提供文件执行权限</span></span></span><br></pre></td></tr></table></figure>
<p>chmod可以用a来同时指定包括文件属主,文件属组和其他人的三类人,我们可以利用以此同时给全部人员增加或删除权限.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">chmod</span> a+w days <span class="comment">## 为days文件的所有人同时提供文件的写入权限</span></span></span><br></pre></td></tr></table></figure>
<p>如果我们需要同时给三类人增删权限,除了用a来表示所有人以外,实际上我们可以不加任何用户组标记,直接用+/-权限的形式,同样可以给全部人员增加或删除权限</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">chmod</span> +rw file <span class="comment">## 为文件file的所有用户增加读取权限和写入权限</span></span></span><br></pre></td></tr></table></figure>
<p>这个命令中我们通过+rw同时给所有用户添加了读取权限和写入权限,这也就是说我们可以在一个命令中同时给用户添加或删除一个或多个权限.进一步我们可以利用逗号来分隔不同的两个修改权限操作</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">chmod</span> u+r,go-w file <span class="comment">## 为文件file的属主添加读取权限,属组和其他人则删除写入权限</span></span></span><br></pre></td></tr></table></figure>
<p>在这里,我们用了一个go来同时对属组和其他人进行修改权限操作,因此实际上我们可以看出来前面用的所有人标识符a和ugo等价.上面我们用逗号分隔符来分隔对不同用户的修改权限操作,实际上我们也可以用逗号分隔符来分隔对同一用户做的不同修改操作.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">chmod</span> u+r,u-w file <span class="comment">## 为文件file的属主添加读取权限的同时,删除文件属主的写入权限</span></span></span><br></pre></td></tr></table></figure>
<p>如果用上面的添加或删除操作修改用户的权限来达到预期会极其复杂,中间也可能需要多次用ls
-l查看文件属性.因此chmod还存在一个规则:用户组=权限来直接设置文件权限.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">chmod</span> ug=rw,o=r file <span class="comment">## 文件的属主和属组权限更改为读取权限和写入权限,而其他人的权限更改为读取权限</span></span></span><br></pre></td></tr></table></figure>
<p>如果文件本身就有一个默认设定的权限,=这种规则会先重置需要修改的用户组的默认规则,然后按照=设定的权限重新赋予.虽然我们举了对所有用户用=修改权限的例子,但实际上,=规则是可以只对其中部分进行修改的.</p>
<p>最后最为常用的是用户组1=用户组2,其的作用在于将用户组1的权限和用户组2的权限设置成一样.明确来说,他的作用是将用户组2的权限覆盖用户组1的权限.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">chmod</span> o=u file <span class="comment">## 将文件file的其他人权限设置成文件属主的权限</span></span></span><br></pre></td></tr></table></figure>
<p>最为关键的一点是只有文件的属主和root用户才可以修改文件的权限.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">chmod</span> u+r file1 file2 <span class="comment">## 为文件file1和file2的属主增加读取权限</span></span></span><br></pre></td></tr></table></figure>
<p>但这里要注意这样的修改要么在root用户下进行,要么两个文件的属主是同一个用户</p>
<p>虽然我们前面已经将权限用三个字母来表示,但这对批量修改文件的权限十分麻烦,因此我们可以用八进制来代表设置权限.由于对于任意的权限而言,其只存在两种状态:设置(1)和不设置(0).所以我们可以得到任意一组权限设置的八进制表示,如'rwx'的二进制为111,八进制为7;'r-x'的二进制为101,八进制为5.这样我们就可以将完整的9位权限位用3个八进制数来表示,例如'rwxr-x-w-'分别对应的三个三位二进制为111/101/010,其对应的三个八进制数752.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">chmod</span> 752 file <span class="comment">## 将文件权限设置为 rwx/ r-x/ -w-</span></span> </span><br></pre></td></tr></table></figure>
<p><a id="orgece5a30"></a></p>
<h2 id="ln-建立链接">ln: 建立链接</h2>
<p>ln命令是用来为某个文件在另一个位置创建一个同步的链接.链接主要分为符号链接(软链接)和硬链接两大类.无论硬链接还是软链接,他们都不会重新复制原来的文件,他们只会占用非常少量的磁盘空间.</p>
<p>符号链接,也被称为软链接,其用ln
-s命令来创建生成.软链接具有如下的特点,</p>
<ol type="1">
<li><p>软链接以路径的形式存在,类似于windows系统的快捷方式</p></li>
<li><p>软链接可以跨越不同的文件系统</p></li>
<li><p>软链接可以对一个不存在的文件名进行链接</p></li>
<li><p>软链接还可以对目录文件进行链接7</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ln</span> -s TARGET LINKNAME <span class="comment">## 为文件TARGET创建了一个别名LINKNAME</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l LINKNAME <span class="comment">## 查看LINK_NAME的属性</span></span></span><br><span class="line">lrwxrwxrwx 1 lyd lyd 6  4月 15 11:31 LINK_NAME -&gt; TARGET</span><br></pre></td></tr></table></figure></li>
</ol>
<p>从这里我们可以看出这个文件被指向TARGET文件,因此访问LINK_NAME就相当于访问TARGET.需要注意的是,这里的LINKNAME只是提供了访问TARGET的一个路径,因此我们删除LINKNAME并不会影响TARGET的正常运行,反之我们删除TARGET,虽然不会同时删除LINKNAME,但是其存在已经没有任何意义了.</p>
<p>同样符号链接还可用于目录,</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ln</span> -s learning/ LINK <span class="comment">## 为目录learning创建一个别名LINK</span></span></span><br></pre></td></tr></table></figure>
<p>此外,对于软链接而言,其还存在删除和修改操作如下,</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">rm</span> -rf LINKNAME <span class="comment">## 删除软链接</span></span></span><br></pre></td></tr></table></figure>
<p>切记不要在软链接后面加/,不然如果软链接对应的是目录文件,可能会直接把目录文件里的内容全部删除.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ln</span> -snf NEWTARGET LINK <span class="comment">## 将LINK链接的文件从原文件更改到新文件NEWTARGET</span></span></span><br></pre></td></tr></table></figure>
<p>这里的修改操作,不止允许同一类型之间文件的链接相互更改,还可以把普通文件的链接文件链接到目录文件,亦或反之.</p>
<p>Linux中的另一种链接称为硬链接.其将两个独立的文件联系在一起,因此硬链接和软链接的本质区别是,硬链接是直接引用,而软链接是通过名称进行引用.</p>
<p>硬链接具有的特性如下,</p>
<ol type="1">
<li>以文件副本的形式存在,但不占用实际空间</li>
<li>不允许给目录创建硬链接</li>
<li>硬链接不能跨越文件系统创建,只能在同一个文件系统里创建</li>
</ol>
<p>硬链接和软链接不同,硬链接用不带-s选项的ln命令直接创建,</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ln</span> world worldlink <span class="comment">## 创建world的硬链接文件worldlink</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l worldlink <span class="comment">## 查看硬链接文件的属性</span></span></span><br><span class="line">-r----xrw- 2 lyd lyd 4  4月  8 07:39 world_link</span><br></pre></td></tr></table></figure>
<p>根据上述查看的文件属性,我们得知这两个文件是独立的,但是会被联系在一起而已.</p>
<p>无论软链接还是硬链接,只是对目标文件的一个访问渠道而已,因此我们在任何一类链接文件上修改都会导致目标文件的变化.</p>
<p><a id="org898ec68"></a></p>
<h2 id="输入输出重定向和管道">输入输出重定向和管道</h2>
<p>重定向和管道操作是Linux的Shell命令里的一种高级特性,其允许用户修改程序获取输入或者生成输出的位置.</p>
<p>在默认情况下程序输出结果的位置称之为标准输出.通常来说,标准输出位都是显示器.输出重定向的作用是将程序的输出转移到另一个地方去,</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> &gt; ~/ls_out <span class="comment">## 将输出结果定向到ls_out文件</span></span></span><br></pre></td></tr></table></figure>
<p>如果指定文件不存在,那么这个命令会创建这个文件,反之如果这个文件是存在的,那么他会直接覆盖文件原有的内容.如果我们希望能够保留原来文件中的内容,那么我们可以用输出重定向符号&gt;&gt;,</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">date</span> &gt; date_out <span class="comment">## 将date命令的输出重定向到date_out文件</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> date_out <span class="comment">## 查看date_out文件</span></span></span><br><span class="line">2024年 04月 16日 星期二 21:15:39 CST</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">uname</span> -r &gt;&gt; date_out <span class="comment">## 将输出结果重定向至date_out文件,并且仅在末尾输出,不覆盖原文件</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> date_out <span class="comment">## 再次查看date_out文件</span></span></span><br><span class="line">2024年 04月 16日 星期二 21:15:39 CST</span><br><span class="line">6.5.0-26-generic</span><br></pre></td></tr></table></figure>
<p>类似于标准输出的定义,程序默认情况下接受输入的地方称之为标准输入.通常来说,标准输入指向键盘.如果使用不带任何参数的cat命令,cat不会执行而是等待从标准输入来获取数据,用户可以输入一行会直接输出在屏幕上,直到Ctrl+D用来给cat命令输入一个文件结束符.
在此,我们罗列一下基于shell的常用快捷键及其含义</p>
<ol type="1">
<li>Ctrl+c 终止当前正在执行的程序</li>
<li>Ctrl+z
中断当前进程,但不是终止进程,只是将进程挂起,我们可以用fg命令来重新调用进程(后续介绍)</li>
<li>Ctrl+l 清空屏幕</li>
<li>Ctrl+d 输入特殊的二进制值,表示EOF,作为文件的结束</li>
</ol>
<p>通过使用输入重定向符号&lt;可以让程序从一个文件中获取输入,</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> &lt; file <span class="comment">## 输出file里的内容</span></span></span><br></pre></td></tr></table></figure>
<p>显然cat可以直接接受参数来显示文件内容,因此输入重定向对这类命令并没有优势,故其使用比较少.</p>
<p>类似,其也存在另一种重定向符号&lt;&lt;,被称之为立即文档.立即文档告诉shell从键盘接受输入,并传递给程序,</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> &lt;&lt; <span class="string">EOF ## 立即文档作为输入,EOF</span>用来输入文档终止</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">Hello</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">,</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">world</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">!</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">EOF</span></span><br><span class="line">Hello</span><br><span class="line">,</span><br><span class="line">world</span><br><span class="line">!</span><br></pre></td></tr></table></figure>
<p>这里的EOF只是代用常见的终止缩写,实际上是可以随意使用的,只需要保证输入的内容中不会出终止代号即可.进一步,上面提到的两个重定向符号是可以在同一个命令中出现的.</p>
<p>管道符号|的出现则进一步使输出重定向的功能变灵活.通过一条竖线,将一个命令的输出作为下一个命令的输入,</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> | grep ld <span class="comment">##罗列文件列表以后查找文件名包含ld的文件</span></span></span><br><span class="line">world</span><br><span class="line">worldlink</span><br></pre></td></tr></table></figure>
<p>当然管道可以继续叠加使用,虽然会十分复杂但是运行起来会很高效.</p>
<p><a id="org86fc6aa"></a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Computer Science</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>ANSI-The UNIX System Interface</title>
    <url>/2025/08/22/ANSI-UNIX/</url>
    <content><![CDATA[<h2 id="the-unix-system-interface">The Unix System Interface</h2>
<p>Unix系统提供了一系列的系统调用,这些系统调用其实是操作系统内部的程序,其提供了用户程序调用的接口.我们将会经常借助系统调用来实现一些高效率的操作,或者访问标准库内没有的功能.</p>
<span id="more"></span>
<p><a id="orga545a05"></a></p>
<h3 id="file-descriptors">File Descriptors</h3>
<p>对于Unix系统而言,输入输出可以认为都是对文件进行读/写操作.这是因为对于Unix系统,所有的外围设备,如键盘,显示器等,都是Unix文件系统下的文件.由于输入输出都可以被认为是对文件的操作,因此Unix系统只需要提供一个统一的接口来处理所有外围设备和程序的通信交互.</p>
<p>在任何的操作系统下,如果用户想要操作文件系统里的文件,需要向系统发送打开文件的请求.无论什么系统,只要是对文件进行操作,打开文件是必须的.以写文件为例,文件系统会先去查找文件是否存在,如果不存在,会在指定路径或默认路径下创建一个新文件并允许写入;如果存在,文件系统会检查用户权限,如果用户有写入权限,那么文件系统就会给用户程序返回一个小的非负整形数据,这个数据就是文件描述符.在文件系统提供文件描述符后,以后程序的所有输入输出操作都是基于文件描述符进行,而不是通过文件名来指示某个文件.程序只需要通过文件描述符来调用文件,具体的底层文件信息维护是通过操作系统隐藏封装的.</p>
<p>由于一般来说,标准输入输出都是通过键盘和显示器实现的,因此Unix系统在shell运行程序的时候,会自动打开三个文件,对应三个文件描述符:0为标准输入(stdin),1为标准输出(stdout),2为标准错误(srderr).同样我们可以像前面提到的那样通过<和>来重定向程序的输入和输出文件,</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">prog &lt;infile &gt;outfile</span><br></pre></td></tr></table></figure>
<p>这样的话,他就需要在程序运行时打开infile和outfile两个文件,并且将文件描述符0和1分别指向这两个文件.如果我们想要将标准错误重定向到一个文件,可以使用2&gt;outfile的方式,这样就会将文件描述符2指向outfile文件.值得注意的是,所有的文件改变都与程序无关,而是在shell里完成的,文件只需要知道对应的文件描述符是0,1,2,而至于文件描述符指向的文件这是由操作系统去维护的.</p>
<p><a id="org665723d"></a></p>
<h3 id="low-level-io-read-and-write">Low Level I/O-Read and Write</h3>
<p>低级I/O操作是指直接与操作系统内核进行数据交互的操作,其无需经过标准库的缓冲区;而高级I/O操作则是需要先将数据写入到标准库的缓冲区,根据缓冲更新策略,再一起提交给操作系统内核进行处理.</p>
<p>一般的缓冲区的更新策略有如下三种:</p>
<ol type="1">
<li>全缓冲:
如果缓冲区写满了就写回系统内核.常规文件的读写都是全缓冲的.这是因为全缓冲可以减少读写时调用系统内核的次数,从而加快读写速度.</li>
<li>行缓冲:
如果缓冲区中出现了换行符就直接写回系统内核,或者如果出现缓冲区写满了也会写回系统内核.标准输入和标准输出对应的终端设备一般都是行缓冲的.这是因为行缓冲可以在输入输出时提供更好的交互体验,如在终端输入时可以实时显示输入内容.</li>
<li>无缓冲:
用户每次调用I/O直接与系统内核交互,不经过缓冲区.一般用于即时展示结果的程序.如标准错误输出一般都是无缓冲,为了方便用户及时看到错误信息.</li>
</ol>
<p>输入和输出是通过read和write系统调用实现的.在C语言中,会通过read和write访问这两个系统调用,其函数原型为</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n_read = <span class="built_in">read</span>(<span class="type">int</span> fd,<span class="type">char</span> *buf,<span class="type">int</span> n);</span><br><span class="line"><span class="type">int</span> n_written = <span class="built_in">write</span>(<span class="type">int</span> fd,<span class="type">char</span> *buf,<span class="type">int</span> n);</span><br></pre></td></tr></table></figure>
<p>我们发现这二者的函数参数都是一样的,因此我们直接合并介绍其函数参数即可.第一个参数是文件描述符,read函数用来指代读取的文件,write函数用来指代写入的文件;第二个参数是一个char数组,他用于接收read函数的读取和提供write函数的写入内容;第三个参数是一个整数,其用于表示读取和写入的最大字符数目.其返回值为一个整型数据,其表示实际读写的字符数目.这是因为在读取时,可能缓冲区或文件中的字符数目小于规定的最大读取数目,因此其返回值可能会小于n.但是如果返回值为0,则表示读取完成;如果返回值为-1,那么表示读取过程中出现了错误.对于写入过程来说一般n_written和n的数值都是相等的,除非在写入过程中发生了错误,才会导致二者不相等.</p>
<p>对于这个最大读写字符数目n的选取,其实有一些建议:一般来说,我们会选择1,这代表着我们每次读取1个字符,其实也就是我们前面提到的无缓冲读取;其次,我们一般会选择1024或4096这种与外围设备的物理块内存大小相对应的值.值得注意的是,其实我们选取更大的最大读写字符数目是可以有效的提高计算机的读写效率,这是我们选择更大的读写字符数目,在读写中所需要的读写交互次数更少,因此可以更有效的提高程序运行效率.</p>
<p>本书所用的系统是Unix系统,因此其与Linux系统仍然存在一定的区别.如本书中提及的read和write函数在头文件syscalls.h但实际上Linux系统的应该是在是unistd.h内.我们可以通过利用man来查找read的指南,其结果为</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span></span>;</span><br></pre></td></tr></table></figure>
<p>因此其表示read定义在unistd,而且我们发现他的返回值类型并不是前文提到的int,而是ssize_t.值得注意的是在windows系统下read和write函数定义在io.h下.</p>
<p>这里需要解释一下ssize_t和size_t的含义.虽然二者都有size_t的名称,但其实其表示的东西不同,size_t用于反映内存中对象的大小(以字节为单位),ssize_t则是供返回字节计数或错误提示的函数使用.</p>
<p>size_t的定义其实是为了增强程序的可移植性,是为了方便系统间的移植而定义的,不同系统上的size_t定义可能有所不同.一般在32位系统上其被定义为unsigned
int,而在64位系统上其被定义为unsigned
long.其一般用来表示一种计数,例如有多少字节的东西被使用了,sizeof操作符的结果类型是size_t,这个类型保证能容纳实现所建立的最大对象的字节大小,用来度量内存中可容纳数据项目个数的无符号整数类型,因此其被广泛应用于内存管理函数.</p>
<p>而ssize_t则有所不同,其用来表示可以被执行读写操作的数据块大小,他的第一个s表明他是一个signed类型,也就是signed
size_t类型.如果size_t是unsigned
int,那么其表示int类型.因此其实虽然类型看似不同,最后都是整型,所以也可以用int.</p>
<p>其次,我们发现BUFSIZ是在syscalls.h里给了#define,这里我们通过shell的grep命令来对/usr/include/*的文件进行查找,有如下结果</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/usr/include/stdio.h:#define BUFSIZ 8192</span><br><span class="line">/usr/include/stdio.h:   Else make it use buffer BUF, of size BUFSIZ.  */</span><br></pre></td></tr></table></figure>
<p>因此我们需要引入一个stdio.h,来保证BUFSIZ的定义.BUFSIZ是一个对于当前操作系统比较合适的数值.如果文件大小不是BUFSIZ的倍数,则对read的某次调用会返回一个较小的字节数,write再按这个字节数写入,而后再调用read函数返回0.(这段主要是在介绍Ch8_io.cpp).</p>
<p>对于低级I/O和高级I/O混用的内容,并不太建议出现在同一个程序中,具体的使用可以通过代码Ch8_io_v2.cpp看到比较.</p>
<p><a id="org4629e75"></a></p>
<h3 id="open-creat-close-unlink">Open, Creat, Close, Unlink</h3>
<p>open函数是用于打开指定的文件,其功能与前文提及的fopen类似,但不同的是open函数更加底层,其返回值为一个整型数据,也就是所谓的文件描述符,而fopen返回的则是一个文件指针.如果open的返回值为-1,那么就表示open函数并未正确打开指定文件.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> fd;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">open</span><span class="params">(<span class="type">char</span>* name,<span class="type">int</span> flags,<span class="type">int</span> perms)</span></span>;</span><br><span class="line">fd=<span class="built_in">open</span>(name,flags,perms);</span><br></pre></td></tr></table></figure>
<p>其中第一个参数是一个字符串,用来指示需要操作的文件名与其路径.第二个参数则是表示打开文件的所需的权限,其值已经在fcntl.h中定义了一组宏,如下所示:</p>
<ol type="1">
<li>O_CREAT:在文件打开过程中创建新文件</li>
<li>O_RDONLY:以只读的方式打开文件</li>
<li>O_WRONLY:以只写的方式打开文件</li>
<li>O_RDWR:以读写方式打开文件</li>
<li>O_APPEND:在文件末尾追加数据,而不是覆盖原内容</li>
<li>O_TRUNC:如果文件已经存在,将其截断为空文件</li>
</ol>
<p>这里我们需要解释一下 O_TRUNC,
其的作用是将原有文件内容清空,因此其一般是搭配 O_WRONLY 和O_RDWR
使用,如果使用O_RDONLY
与之搭配,那么系统会报错,出现逻辑冲突,这是因为只读表示你不想修改文件,而截断却会破坏原文件结构,这是两个冲突的操作.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> fd = <span class="built_in">open</span>(<span class="string">&quot;file.txt&quot;</span>, O_RDWR | O_TRUNC);</span><br></pre></td></tr></table></figure>
<p>这里的|其实就是按位取或运算,因此上述的这些其实就是二进制掩码.第三个参数是要搭配
O_CREAT
来使用的,因为O_CREAT的作用是如果读取不到文件,那么就需要创建一个文件,而perms则表示创建的文件的各用户的权限.后续会进一步解释perms的具体内容,在此不再赘述.</p>
<p>如果用open函数打开一个不存在的文件(在不使用O_CREAT的情况),那么其会报错.此时我们需要用CREAT来创建一个新文件,或者用来覆盖没有权限的旧文件.其函数原型为:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">creat</span><span class="params">(<span class="type">char</span>* name,<span class="type">int</span> perms)</span></span>;</span><br><span class="line">fd=<span class="built_in">creat</span>(name,perms);</span><br></pre></td></tr></table></figure>
<p>与open一样,creat的返回值也是文件描述符,如果运行成功,那么会返回一个文件描述符,但是存在一个特殊情况,也就是返回值为-1的时候,表示文件创建失败.如果文件已经存在的话,那么creat会将文件的内容做一个截断,并不会报错.这里有一个有趣的point需要关注一下,对于不存在的文件,我们调用creat时,如果文件不存在,会按照给的这个perms分配用户权限.在Unix系统下,文件系统的权限用户有文件所有者,文件所有组和其他成员对文件的读,写,执行访问.因此Unix系统中采用九个比特位来控制这些权限,1表示有权限,0表示没有权限.但是九个比特位太过繁琐,因此我们选用三个八进制数来表示用户的不同权限.例如755表示文件所有者对文件有读写执行的权限,文件所有组的成员和其他成员则只能读和执行,并不能写入.这里我们需要强调一下为了保证文件的安全性,一切提供权限都以权限最小的原则提供,也就是尽可能对外开放小的权力,以保证文件的安全性.但是实际上我们运行了程序会发现,如果我们给他的perms是0666,但是他的权限却是0664,</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls -l test.cpp</span><br><span class="line">-rw-rw-r-- 1 lyd lyd 870 Jul  7 15:03 test.cpp</span><br></pre></td></tr></table></figure>
<p>这是因为其实unix系统中还存在权限掩码umask,其作用是在创建文件的读写权限时需要减去其定义的权限,方才得到真正的权限.因此creat的真正权限计算公式是perms&amp;~
umask.umask的值可以用shell的umask直接得到,本人所使用的是002,因此0666&amp;~002=0666&amp;775=0664.但是以上的权限方式均只针对文件不存在需要创建的情况,如果文件已经存在,那么我们用creat首先需要该文件本身可写,因为我们后续需要将其内容截断,所以可写入是基本要求,其次creat并不会对原有权限做任何改动,除了如果原权限对文件所有者不可读,他会帮你置为可读,即如果我们的文件是240,运行后他会帮你置成640.</p>
<p>对于umask,我们介绍一下程序上的操作方式.C/C++中提供了一个mask函数,用于重新设置umask,并且返回老的umask.其需要导入如下头文件</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">mode_t</span> <span class="title">umask</span><span class="params">(<span class="type">mode_t</span> mask)</span></span>;</span><br></pre></td></tr></table></figure>
<p>umask会将程序调用的umaks设为mask&amp;0777后的值,然后返回原有的umask值.这里的mode_t是一个用于表示文件模式或权限的数据类型.其为一个无符号整数类型,通常是一个32位的整数.其用于表示文件的访问权限,文件类型以及其他与文件相关的属性.</p>
<p>printf的介绍我们已在前面做了比较全面的介绍,这里我们介绍printf家族的另一个函数vprintf.其的使用与printf实际上是十分类似,其函数原型如下:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">vprintf</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*format, va_list arg)</span></span>;</span><br></pre></td></tr></table></figure>
<p>format是一个字符串,包含了写入的包含了要被写入到标准输出stdout的文本.它可以包含嵌入的format标签,format标签可被随后的附加参数中指定的值替换,并按需求进行格式化.arg表示一个可变参数列表对象,需要用stdarg.h中定义的va_start宏初始化.</p>
<p>一般来说我们都是用printf,只有在我们自己写一个专有的输出函数才会需要使用vptintf,例如我们需要写一个专门的错误输出函数:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">error</span><span class="params">(<span class="type">char</span> *fmt,...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  va_list ap;</span><br><span class="line">  <span class="built_in">va_start</span>(ap,fmt);</span><br><span class="line">  <span class="built_in">fprintf</span>(stderr,<span class="string">&quot;error: &quot;</span>);</span><br><span class="line">  <span class="built_in">vfprintf</span>(stderr,fmt,ap);</span><br><span class="line">  <span class="built_in">fprintf</span>(stderr,<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  <span class="built_in">va_end</span>(ap);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们发现我们实际上是不可以直接将参数转发给printf的,这是因为printf是可以接收不同数目的参数,但是并不能接受变长参数列表.因此只能采用vprintf类的函数,这里我们没有用vprintf是因为我们写的这个是报错函数,如果用vprintf函数会将输出导出到stdout,而stdout可能会被修改到了其他文件,因此我们需要用stderr来保证我们的报错信息不会污染输出文件.</p>
<p>close函数的作用是断开文件描述符和已打开文件的联系,并且释放文件描述符使之可以用于描述其他的文件.与fclose不同的是,close只是将文件描述符关闭,但是对于需要写入的数据并不能保证写入了磁盘,这是所谓的缓冲机制,他会在某些条件下再重新写入,但是一旦关闭电源,那么就会出现数据丢失的现象.而fclose会直接调用fflush,刷新所有缓冲区,将未写入的数据写入文件.</p>
<p>unlink函数的作用是断开指定路径的文件的链接,值得强调的是,这里我们是断开文件的链接,并非直接删除某个文件,只是说如果链接为1的文件,我们会直接删除.其函数原型如下:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">unlink</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* pathname)</span></span>;</span><br></pre></td></tr></table></figure>
<p>执行unlink函数并不是真正的删除文件,他会先检查文件系统中此文件的链接数是否为1,如果不是1,那其表明文件还有其他的链接对象,因此对文件的链接数做减1操作.若链接数为1,并且此时没有进程打开文件,那么内容就会被删除,如果有进程打开文件,那么暂时不会删除,直到所有打开该文件的所有进程全部结束时,文件就会删除.</p>
<p>这里我们深入介绍一下对于软链接和硬链接的不同.软链接本质上其实就是一个符号链接,他与源文件在文件系统中是不同的文件,类似与Windows系统的快捷方式.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ln</span> -s init.el test.txt</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l test.txt</span></span><br><span class="line">lrwxrwxrwx 1 lyd lyd 7 Jul 23 16:52 test.txt -&gt; init.el</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">unlink</span> test.txt</span></span><br></pre></td></tr></table></figure>
<p>这里的unlink可以直接删除test.txt,且不对init.el有任何影响.相反如果我们unlink的对象是init.el,则结果如下:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">unlink</span> init.el</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> test.txt</span></span><br><span class="line">cat: test.txt: 没有那个文件或目录</span><br></pre></td></tr></table></figure>
<p>这相当于将test.txt做成了一个悬挂的没有指向的符号链接.</p>
<p>硬链接是将两个独立文件联系在一起,其为直接引用,而并不是软链接通过名称引用,且硬链接是通过文件副本的形式存在,但不占用实际空间.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ln</span> log.txt test.txt</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l log.txt</span></span><br><span class="line">-rw-rw-r-- 2 lyd lyd 96265 Sep 21  2024 log.txt</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l test.txt</span></span><br><span class="line">-rw-rw-r-- 2 lyd lyd 96265 Sep 21  2024 test.txt</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">unlink</span> test.txt</span></span><br></pre></td></tr></table></figure>
<p>这里的unlink可以直接删除test.txt,且不对log.txt有任何影响.如果我们unlink的对象是log.txt,仍然可以顺利的打开test.txt,这是因为如果我们用硬链接test.txt其实也是文件的一个副本,他和log.txt其实就是同一个文件,因此我们用unlink释放了log.txt,但是文件系统其实还是存在test.txt这个副本的.</p>
<p><a id="orgc753728"></a></p>
<h3 id="random-access-lseek">Random Access-Lseek</h3>
<p>前面我们提到的输入输出方式都是顺序输入,也就是读写都在上一次读写位置之后.但是我们可能需要在文件中移动读写位置,并不希望这个操作附带着读写功能.系统中存在一个调用lseek,他的作用是将读写位置在文件中移动,但是不附带读写数据的操作,其函数原型如下:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="title">lseek</span><span class="params">(<span class="type">int</span> fd, <span class="type">long</span> offset, <span class="type">int</span> origin)</span></span>;</span><br></pre></td></tr></table></figure>
<p>他是将文件描述符fd指代的文件的现在读写位置移动到以origin为基准偏移offset的位置.其实可以通过数组的角度来理解,origin表示偏移量计算的基准点,一般为0,1,2,分别表示文件开头,当前位置和文件结尾.offset表示偏移量,如果为正数,则表示向后移动,如果为负数,则表示向前移动,如果为0,那么就是origin指代的位置.但值得注意的是如果我们在origin为2的时候,仍然用正数作为偏移量,那么会导致越过EOF可能会导致错误.同理,如果我们在origin为0的时候,用负数作为偏移量,那么会导致越过文件开头,同样可能会导致错误.而lseek的返回值是新的读写位置,如果出错则返回-1,并且设置errno.根据我们上面提及的理解方式,实际上lseek就是将文件视作了一个数组,但是这样的代价就是读写操作的效率会降低.</p>
<p>我们已经有了lseek函数,那么我们其实可以修改读写位置来达成一些特殊的目的,例如我们需要在文件末尾追加数据,也就是所谓的append操作,我们可以用lseek来达成,
我们可以将读写位置移动到文件末尾,然后再进行写入操作.其代码如下:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">lseek</span>(fd,<span class="number">0</span>,<span class="number">2</span>); <span class="comment">//将读写位置移动到文件末尾</span></span><br></pre></td></tr></table></figure>
<p>这里的2表示origin为2,也就是文件末尾,而offset为0,因此我们将读写位置移动到文件末尾.如果我们需要在文件开头写入数据,那么可以将offset设为0,origin设为0,这样就可以将读写位置移动到文件开头,</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">lseek</span>(fd,<span class="number">0</span>,<span class="number">0</span>); <span class="comment">//将读写位置移动到文件开头</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C Language</category>
      </categories>
      <tags>
        <tag>Computer Science</tag>
        <tag>C Language</tag>
      </tags>
  </entry>
  <entry>
    <title>Pratical Python for dabeaz-Introduction to Python</title>
    <url>/2025/09/03/Practical-Python-Intro/</url>
    <content><![CDATA[<p>本笔记完全基于David Beazley的Python教程-<a
href="https://dabeaz-course.github.io/practical-python/Notes/Contents.html">Practical
Python</a>.</p>
<h2 id="a-first-program">1.1 A First Program</h2>
<p>在交互模式下,Python提供了下划线变量_,他会保存最后一个表达式的结果,例如:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">37</span>*<span class="number">42</span></span><br><span class="line"><span class="number">1554</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>_*<span class="number">2</span></span><br><span class="line"><span class="number">3108</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>_+<span class="number">50</span></span><br><span class="line"><span class="number">3158</span></span><br></pre></td></tr></table></figure>
<p>但这只在交互模式下有用,我们并不会在程序中使用.</p>
<span id="more"></span>
<p>在Python中,#用于引导单行的注释,多行注释则可以用三个单引号或双引号括起来的字符串来表示.</p>
<p>与C/C++不同,Python并不需要在使用每个变量前声明其类型,其命名规则与C/C++类似,不能以数字开头,不能使用Python的关键字(如if,while等),变量名区分大小写.变量会在首次赋值时创建,并且会根据赋值的值来决定变量的类型.因此,他和C/C++的类型最大的不同在于,他的变量类型其实是可以随着程序需要而改变的,例如:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>height=<span class="number">442</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(height)</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;int&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>height=<span class="number">442.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(height)</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;float&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>height=<span class="string">&#x27;Really tall&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(height)        </span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;str&#x27;</span>&gt;</span><br></pre></td></tr></table></figure>
<p>与C/C++不同,Python并不通过{}来表示代码块,而是通过代码的缩进来表示代码块,通常缩进4个空格,因此对于Python而言,代码的缩进并不是风格问题,而是语法的一部分.不同代码缩进表示不同的代码块,例如:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> num_bills*bill_thickness&lt;sears_height:</span><br><span class="line">    <span class="built_in">print</span>(day,num_bills,num_bills*bill_thickness)</span><br><span class="line">    day=day+<span class="number">1</span> <span class="comment">#ERROR</span></span><br><span class="line">    num_bills=num_bills*<span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>这样的话day=day+1就会报错,因为他并不在while循环的代码块内.反之如果day=day+1并不做缩进,那么他就不在while循环内,而是while循环后的第一条语句,因此day=day+1只会执行一次.</p>
<p>Python的条件判断语句和C/C++类似,但是如果我们希望在if判断中检查多个条件,我们需要用elif来添加检查,而不是用else
if:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> a&gt;b:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;a is greater than b&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> a==b:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;a is equal to b&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;a is less than b&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>Python中并不需要引入其他的包文件,就可以用print函数打印输出,并且print函数可以接受多个参数,并且会在参数间自动添加空格:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello&quot;</span>,<span class="string">&quot;world!&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The answer is&quot;</span>,<span class="number">42</span>)</span><br></pre></td></tr></table></figure>
<p>并且print函数会默认在输出的后面添加一个换行符,如果不希望添加换行符,可以在print函数中添加end参数:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello&quot;</span>,<span class="string">&quot;world!&quot;</span>,end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The answer is&quot;</span>,<span class="number">42</span>)</span><br></pre></td></tr></table></figure>
<p>Python中可以用input函数向用户打印提示并且以字符串的形式获取用户输入:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name=<span class="built_in">input</span>(<span class="string">&quot;What is your name? &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello&quot;</span>,name)</span><br></pre></td></tr></table></figure>
<p>他比较适合于用于调试或者交互,而不适合于正式的程序输入.但这里与C/C++不同的是,Python的输入得到的只能是字符串类型,如果需要其他数据类型,需要用强制类型转换函数进行转换,例如:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">age = <span class="built_in">input</span>(<span class="string">&#x27;Enter your age\n:&#x27;</span>)</span><br><span class="line">age=<span class="built_in">int</span>(age)</span><br><span class="line">age=age+<span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Your age is&#x27;</span>, age)</span><br></pre></td></tr></table></figure>
<p>因为他读取的是一行字符串,所以即使用户在输入的文本中输入了空格,他也会被当做字符串的一部分一起输入,并不会像C/C++那样,遇到空格就结束输入.然而,如果我们需要输入多个值,可以用split方法将字符串拆分为多个部分,例如:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name,age=<span class="built_in">input</span>(<span class="string">&#x27;Enter your name and age:&#x27;</span>).split() <span class="comment">#默认以空格拆分</span></span><br><span class="line">name,age=<span class="built_in">input</span>(<span class="string">&#x27;Enter your name and age:&#x27;</span>).split(<span class="string">&#x27;,&#x27;</span>) <span class="comment">#以逗号拆分</span></span><br></pre></td></tr></table></figure>
<p>如果我们得到的输入多个值是相同的类型,那么我们可以用map函数将拆分后的字符串转换为相同的类型,例如:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a,b,c=<span class="built_in">map</span>(<span class="built_in">int</span>,<span class="built_in">input</span>(<span class="string">&#x27;Enter three integers:&#x27;</span>).split())</span><br><span class="line"><span class="built_in">print</span>(a,b,c)</span><br><span class="line"><span class="comment"># 如果我们并不知道输入的整数有多少个,可以用一个列表来接收</span></span><br><span class="line">num_list=<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>,<span class="built_in">input</span>(<span class="string">&#x27;Enter some integers:&#x27;</span>).split()))</span><br><span class="line"><span class="built_in">print</span>(num_list)</span><br></pre></td></tr></table></figure>
<p>值得注意的是,这个map函数他只针对于多个值都是相同类型的情况,如果多个值类型不同,那么就需要分别转换.</p>
<p>有时我们需要指定一个空代码块,用于if语句或者函数框架设计等,此时可以用pass关键字用来表示无操作语句.他并不会执行任何操作,只是一个占位符,可能用于后续代码的添加,例如:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> a&gt;b:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;a is less than or equal to b&quot;</span>)</span><br></pre></td></tr></table></figure>
<p><a id="orgecc21b8"></a></p>
<h2 id="numbers">1.2 Numbers</h2>
<p>Python有三种数字类型:bool,int,float和complex.这里值得注意的是,Python中并没有对浮点数进行进一步分类,而是归为了一类float,因此python中并没有float和double之分.</p>
<p>bool类型可以与int和float类型进行混合运算,其结果类型仍与int和float相同,这相当于在运算过程中出现了隐式类型转换.在运算的过程中,True会被当做1,False会被当做0.</p>
<p>在int和float类型对应的运算中,其有与C/C++类似但结果不同的运算符:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span>/<span class="number">2</span> <span class="comment"># 其结果为2.5,与C/C++的除法依赖于两侧操作数不同,python的/就是普通除法,无论两端操作数的类型,其结果都是float</span></span><br><span class="line"><span class="number">5</span>//<span class="number">2</span> <span class="comment">#其结果为2,这其实相当于C/C++的整数除法,但是要求两端操作数均为整数时,其结果类型才为int</span></span><br><span class="line"><span class="number">5.0</span>//<span class="number">2</span> <span class="comment">#其结果为2.0,两端操作数只要有一个为float时,其结果类型为float</span></span><br><span class="line"><span class="number">3</span>**<span class="number">2</span> <span class="comment">#其结果为9,其就是C/C++的power函数,只不过power函数要求两个量均为double类型,而**则允许有整数</span></span><br></pre></td></tr></table></figure>
<p>同样与C/C++一样,int也是有位运算的,并且float由于浮点数存储方式的差异并没有位运算.</p>
<p>与C/C++一样,Python也具有与或非三类逻辑运算符,但Python的运算符是and or
not,并不是C中的&amp;&amp; || !.</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Computer Science</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Pratical Python for dabeaz-Regular expression</title>
    <url>/2025/09/07/Practical-Python-Regular/</url>
    <content><![CDATA[<h2 id="regular-expression">1.4 Regular Expression</h2>
<p>在上一节中提到了Python可以利用字符串的find和index方法来查找字符串,但是这种方法只能查找固定的字符串,也就是精确查找.而我们在正常使用过程中模糊查找其实更为常见,例如查找所有以a开头,以b结尾的字符串,这就需要利用正则表达式来实现搜索.</p>
<p>正则表达式的基本语法如下:</p>
<span id="more"></span>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<colgroup>
<col  class="org-left" />
<col  class="org-left" />
<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">
符号
</th>
<th scope="col" class="org-left">
含义
</th>
<th scope="col" class="org-left">
示例
</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">
.
</td>
<td class="org-left">
匹配除换行符外的任意单个字符
</td>
<td class="org-left">
a.b匹配开头为a,结尾为b的连续三个字符
</td>
</tr>
<tr>
<td class="org-left">
^
</td>
<td class="org-left">
匹配字符串的开头
</td>
<td class="org-left">
^abc匹配以abc开头的字符串
</td>
</tr>
<tr>
<td class="org-left">
$
</td>
<td class="org-left">
匹配字符串的结尾
</td>
<td class="org-left">
$abc匹配以abc结尾的字符串
</td>
</tr>
<tr>
<td class="org-left">
[]
</td>
<td class="org-left">
定义字符集合,匹配其中任意一个字符
</td>
<td class="org-left">
[aeiou]匹配任意一个原因字母
</td>
</tr>
<tr>
<td class="org-left">
[^]
</td>
<td class="org-left">
定义字符集合,匹配不在其中任意的一个字符
</td>
<td class="org-left">
[^0-9]匹配任意非数字字符
</td>
</tr>
<tr>
<td class="org-left">
-
</td>
<td class="org-left">
字符类中表示范围
</td>
<td class="org-left">
[a-z]匹配任意小写字母
</td>
</tr>
<tr>
<td class="org-left">
*
</td>
<td class="org-left">
匹配前面的子表达式零次或多次
</td>
<td class="org-left">
a*e匹配开头有且仅有0个或多个a,结尾为e的字符
</td>
</tr>
<tr>
<td class="org-left">
+
</td>
<td class="org-left">
匹配前面的子表达式一次或多次
</td>
<td class="org-left">
a+e匹配开头有且仅有1个或多个a,结尾为e的字符
</td>
</tr>
<tr>
<td class="org-left">
?
</td>
<td class="org-left">
匹配前面的子表达式零次或者一次
</td>
<td class="org-left">
colou?r匹配color和colour
</td>
</tr>
<tr>
<td class="org-left">
{n}
</td>
<td class="org-left">
精确匹配前面的子表达式n次
</td>
<td class="org-left">
da{3}e匹配daaae
</td>
</tr>
<tr>
<td class="org-left">
{n,}
</td>
<td class="org-left">
至少匹配前面的子表达式n次
</td>
<td class="org-left">
da{2,}e匹配daae,daaae等
</td>
</tr>
<tr>
<td class="org-left">
{n,m}
</td>
<td class="org-left">
匹配前面的子表达式n次到m次
</td>
<td class="org-left">
a{2,4}匹配aa,aaa,aaaa
</td>
</tr>
<tr>
<td class="org-left">
()
</td>
<td class="org-left">
定义子表达式或捕获组
</td>
<td class="org-left">
(ab)+匹配ab,abab等
</td>
</tr>
</tbody>
</table>
<p>正则表达式里的特殊字符如果需要作为普通字符使用,则需要在其前面加上反斜杠\进行转义,如:</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<colgroup>
<col  class="org-left" />
<col  class="org-left" />
<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">
符号
</th>
<th scope="col" class="org-left">
含义
</th>
<th scope="col" class="org-left">
等价符号
</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">
​d
</td>
<td class="org-left">
匹配任意数字
</td>
<td class="org-left">
等价于[0-9]
</td>
</tr>
<tr>
<td class="org-left">
​D
</td>
<td class="org-left">
匹配任意非数字
</td>
<td class="org-left">
等价于[^0-9]
</td>
</tr>
<tr>
<td class="org-left">
​w
</td>
<td class="org-left">
匹配任意单词字符(字母,数字,下划线)
</td>
<td class="org-left">
[a-zA-Z0-9_]
</td>
</tr>
<tr>
<td class="org-left">
​W
</td>
<td class="org-left">
匹配任意非单词字符(字母,数字,下划线)
</td>
<td class="org-left">
[^a-zA-Z0-9_]
</td>
</tr>
<tr>
<td class="org-left">
​s
</td>
<td class="org-left">
匹配任意空白字符(空格,制表符,换行符)
</td>
<td class="org-left">
[ ​t​n]
</td>
</tr>
<tr>
<td class="org-left">
​S
</td>
<td class="org-left">
匹配任意非空白字符(空格,制表符,换行符)
</td>
<td class="org-left">
[^ ​t ​n]
</td>
</tr>
<tr>
<td class="org-left">
​b
</td>
<td class="org-left">
边界匹配符,如果在左边出现要求是开头,右边则是结尾,同时出现则精确匹配
</td>
<td class="org-left">
^,$,""
</td>
</tr>
</tbody>
</table>
<p>这里我们对前面提到的正则表达式的基本语法进行一些补充说明:</p>
<ol type="1">
<li><p>*,+,?和{n,m}这些量词都是贪婪的也就是他会尽可能多的匹配字符,如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">text=<span class="string">&quot;&lt;div&gt;abc&lt;/div&gt;&lt;div&gt;def&lt;/div&gt;&quot;</span></span><br><span class="line">re.findall(<span class="string">r&quot;&lt;div&gt;.*&lt;/div&gt;&quot;</span>,text) <span class="comment"># [&#x27;&lt;div&gt;abc&lt;/div&gt;&lt;div&gt;def&lt;/div&gt;&#x27;]</span></span><br></pre></td></tr></table></figure>
<p>这里的.*会尽可能多的匹配字符,直到最后一个</p>
</div>
<p>为止.如果想让其变为非贪婪模式,则可以在量词后面加上?,如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 非贪婪模式</span></span><br><span class="line">re.findall(<span class="string">r&quot;&lt;div&gt;.*?&lt;/div&gt;&quot;</span>, text)</span><br><span class="line"><span class="comment"># 结果: [&#x27;&lt;div&gt;abc&lt;/div&gt;&#x27;, &#x27;&lt;div&gt;def&lt;/div&gt;&#x27;]</span></span><br></pre></td></tr></table></figure></li>
<li><p>匹配开头或者结尾的时候只写了部分模式,这并不会匹配整个字符串,而是匹配字符串的开头或者结尾部分,如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">re.findall(<span class="string">r&quot;^abc&quot;</span>, <span class="string">&quot;abcdef&quot;</span>) <span class="comment"># [&#x27;abc&#x27;]</span></span><br><span class="line">re.findall(<span class="string">r&quot;def$&quot;</span>, <span class="string">&quot;abcdef&quot;</span>) <span class="comment"># [&#x27;def&#x27;]</span></span><br></pre></td></tr></table></figure></li>
<li><p>忘记了对特殊字符做转义</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">re.findall(<span class="string">r&quot;d&#123;3&#125;.txt&quot;</span>,<span class="string">&quot;dddktxt&quot;</span>) <span class="comment"># [&#x27;dddktxt&#x27;]</span></span><br></pre></td></tr></table></figure></li>
<li><p>字符集和字符分组混用错误:[abc]可以匹配单个字符'a','b'和'c';而(abc)匹配整个字符串"abc".</p></li>
</ol>
<p>re模块是Python标准库中用于正则表达式操作的模块,提供查找,匹配,替换,分组等功能.re模块的基本函数为</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<colgroup>
<col  class="org-left" />
<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">
函数
</th>
<th scope="col" class="org-left">
作用
</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">
re.match(pattern,string)
</td>
<td class="org-left">
从字符串开头匹配
</td>
</tr>
<tr>
<td class="org-left">
re.search(pattern,string)
</td>
<td class="org-left">
搜索整个字符串,找到第一个匹配
</td>
</tr>
<tr>
<td class="org-left">
re.findall(pattern,string)
</td>
<td class="org-left">
返回所有匹配的字符串列表
</td>
</tr>
<tr>
<td class="org-left">
re.finditer(pattern,string)
</td>
<td class="org-left">
返回迭代器,每个元素是Match对象
</td>
</tr>
<tr>
<td class="org-left">
re.fullmatch(pattern,string)
</td>
<td class="org-left">
整个字符串必须完全匹配
</td>
</tr>
<tr>
<td class="org-left">
re.split(pattern,string)
</td>
<td class="org-left">
按模式分割字符串
</td>
</tr>
<tr>
<td class="org-left">
re.sub(pattern,repl,string)
</td>
<td class="org-left">
替换匹配的部分
</td>
</tr>
<tr>
<td class="org-left">
re.subn(pattern,repl,string)
</td>
<td class="org-left">
返回(替换后字符串,替换次数)
</td>
</tr>
</tbody>
</table>
<p>返回的match对象的常用属性:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">m=re.search(<span class="string">r&quot;\d+&quot;</span>,<span class="string">&quot;abc123def&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(m.group()) <span class="comment"># 返回匹配的字符串&quot;123&quot;</span></span><br><span class="line"><span class="built_in">print</span>(m.start()) <span class="comment"># 返回匹配子串的起始索引,3</span></span><br><span class="line"><span class="built_in">print</span>(m.end()) <span class="comment"># 返回匹配子串的结束索引,6</span></span><br><span class="line"><span class="built_in">print</span>(m.span()) <span class="comment"># 返回(start,end),(3,6)</span></span><br></pre></td></tr></table></figure>
<p>re模块提供了一个编译模式,可以提高后续使用相同的正则表达式的运行效率.re.compile的作用会将一个正则表达式编译成一个正则对象,后续可以重复使用这个对象来匹配字符串.这样的好处是</p>
<ol type="1">
<li>复用性强,不需要每次都写pattern,直接使用正则对象的方法.</li>
<li>效率更高,编译过的正则对象会缓存,特别是同一个模式需要多次匹配时,具有更高的性能</li>
</ol>
<p>其基本语法为:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="comment"># re.compile的基本语法;pattern为正则表达式字符串,flags则是表示匹配模式</span></span><br><span class="line">regex=re.<span class="built_in">compile</span>(pattern,flags=<span class="number">0</span>)</span><br><span class="line">pattern=re.<span class="built_in">compile</span>(<span class="string">r&quot;\d+&quot;</span>)</span><br><span class="line">text=<span class="string">&quot;Order123, Item456, Code789&quot;</span></span><br><span class="line"><span class="built_in">print</span>(pattern.findall(text))</span><br><span class="line"><span class="keyword">for</span> m <span class="keyword">in</span> pattern.finditer(text):</span><br><span class="line">    <span class="built_in">print</span>(m.group(),m.span())</span><br></pre></td></tr></table></figure>
<p>上面提到了re.compile的标准语法中存在一个flags变量,实际上re的每个函数都有这个变量,在此介绍flags变量的值及其作用:</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<colgroup>
<col  class="org-left" />
<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">
FLAGS
</th>
<th scope="col" class="org-left">
作用
</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">
re.I(re.IGNORECASE)
</td>
<td class="org-left">
忽略大小写,匹配时不区分大小写
</td>
</tr>
<tr>
<td class="org-left">
re.M(re.MULTILINE)
</td>
<td class="org-left">
让^和$作用于每一行的开头和结尾,默认仅匹配整个字符串的开头结尾
</td>
</tr>
<tr>
<td class="org-left">
re.S(re.DOTALL)
</td>
<td class="org-left">
默认.不匹配换行,开启后可以匹配换行
</td>
</tr>
<tr>
<td class="org-left">
re.X(re.VERBOSE)
</td>
<td class="org-left">
正则里可以加空格和注释，提高可读性
</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Computer Science</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Pratical Python for dabeaz-Strings</title>
    <url>/2025/09/03/Practical-Python-String/</url>
    <content><![CDATA[<p>本笔记完全基于David Beazley的Python教程-<a
href="https://dabeaz-course.github.io/practical-python/Notes/Contents.html">Practical
Python</a>.</p>
<h2 id="strings">1.3 Strings</h2>
<p>Python与C/C++不同在于他并没有char类型,因此对于Python的字符串而言,他可以用单引号或者双引号来引导字符串.Python的字符串通常只能传入单行,遇到换行符会报错;但可以通过三引号来表示多行字符串,例如:</p>
<span id="more"></span>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Single quote</span></span><br><span class="line">a=<span class="string">&#x27;Yeah but no but yeah but...&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Double quote</span></span><br><span class="line">b=<span class="string">&quot;Computer says no&quot;</span></span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"></span><br><span class="line"><span class="comment">#Triple quotes</span></span><br><span class="line">c = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">Look into my eyes, look into my eyes, the eyes, the eyes, the eyes,</span></span><br><span class="line"><span class="string">not around the eyes,</span></span><br><span class="line"><span class="string">don&#x27;t look around the eyes,</span></span><br><span class="line"><span class="string">look into my eyes, you&#x27;re under.</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(c)</span><br></pre></td></tr></table></figure>
<p>但我们前面提到的多行注释也可以用三引号表示,这是因为Python其实并没有多行注释的专用符号,我们通过三引号引导的多行字符串对程序进行解释,但不做赋值操作,程序会阅读后并不保存相关数据,也就认为其可用于注释.其次我们用三引号引导的字符串做注释的时候,如果其出现在函数,模块或者类的开头,那么其会被认作是该代码的文本字符串,我们可以通过.__doc__属性或者help函数来查看:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    这个函数用于计算两个数的和</span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">        a: 第一个数字</span></span><br><span class="line"><span class="string">        b: 第二个数字</span></span><br><span class="line"><span class="string">    返回:</span></span><br><span class="line"><span class="string">        两个数字的和</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line"><span class="built_in">help</span>(add)  <span class="comment"># 查看函数的文档字符串</span></span><br><span class="line"><span class="built_in">print</span>(add.__doc__)</span><br></pre></td></tr></table></figure>
<p>正是因为Python的字符串可以用单引号或双引号引导,因此我们可以不借助转义符来表示字符串中包含引号的情况,例如:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=<span class="string">&quot;He said, &#x27;Hello!&#x27;&quot;</span></span><br><span class="line">b=<span class="string">&#x27;She replied, &quot;Hi!&quot;&#x27;</span></span><br></pre></td></tr></table></figure>
<p>但是如果字符串中既包含单引号又包含双引号,那么我们还是需要用转义符\来表示.</p>
<p>在C/C++中,字符串的每个字符在计算机内部都是以ASCII编码的形式存储的,当然更为现代的版本也是支持了UTF8编码.同样Python的字符串也是以Unicode编码形式存储的,或者说我们可以给程序一个字符的unicode编码,程序会将其转换为对应字符后存储.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=<span class="string">&#x27;\xf1&#x27;</span> <span class="comment"># \x表示后面跟的是一个十六进制的数字,其后f1表示两个字节</span></span><br><span class="line">b=<span class="string">&#x27;\u2200&#x27;</span> <span class="comment"># \u表示是unicode编码,其后接的2200是四个十六进制数字,表示其码点为8704</span></span><br><span class="line">c=<span class="string">&#x27;\U0001D122&#x27;</span> <span class="comment"># \u和\U都表示unicode编码,但是\U后面需要接8个十六进制数字,不足8位需要在前面补0,其码点为119074</span></span><br><span class="line">d=<span class="string">&#x27;\N&#123;FOR ALL&#125;&#x27;</span> <span class="comment"># \N&#123;&#125;是通过字符名称来表示字符,其字符名称必须是Unicode标准中定义的名称</span></span><br></pre></td></tr></table></figure>
<p>对于字符串索引,同样字符串也是从0开始索引,但与C/C++不同的是,Python支持负数索引,负数索引表示从字符串的末尾开始向前索引.例如,-1表示字符串的最后一个字符,-2表示导数第二个字符,以此类推:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s=<span class="string">&#x27;Hello world&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(s[<span class="number">0</span>]) <span class="comment"># H</span></span><br><span class="line"><span class="built_in">print</span>(s[-<span class="number">1</span>]) <span class="comment"># d</span></span><br><span class="line"><span class="built_in">print</span>(s[-<span class="number">5</span>]) <span class="comment"># w</span></span><br></pre></td></tr></table></figure>
<p>Python也支持利用:指定字符串检索范围来作切片操作或者提取子字符串,若存在缺省指标,则默认为字符串的开头或者结尾,这里值得注意的是s[start:end]会包含start的索引,但不包含end:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = s[:<span class="number">5</span>]     <span class="comment"># &#x27;Hello&#x27;</span></span><br><span class="line">e = s[<span class="number">6</span>:]     <span class="comment"># &#x27;world&#x27;</span></span><br><span class="line">f = s[<span class="number">3</span>:<span class="number">8</span>]    <span class="comment"># &#x27;lo wo&#x27;</span></span><br><span class="line">g = s[-<span class="number">5</span>:]    <span class="comment"># &#x27;world&#x27;</span></span><br></pre></td></tr></table></figure>
<p>Python的字符串操作有+(链接两个字符串),len(求字符串长度),in/not
in(检查子字符串是否在字符串中出现过)和*(重复字符串):</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Concatenation</span></span><br><span class="line">a=<span class="string">&#x27;Hello&#x27;</span>+<span class="string">&#x27;World&#x27;</span> <span class="comment"># &#x27;HelloWorld&#x27;</span></span><br><span class="line">b=<span class="string">&#x27;Say&#x27;</span>+a <span class="comment"># &#x27;SayHelloWorld&#x27;</span></span><br><span class="line"><span class="comment"># Length</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(a)) <span class="comment"># 10</span></span><br><span class="line"><span class="comment"># Membership test(in/not in)</span></span><br><span class="line">t=<span class="string">&#x27;e&#x27;</span> <span class="keyword">in</span> a <span class="comment"># True,bool类型</span></span><br><span class="line">f=<span class="string">&#x27;x&#x27;</span> <span class="keyword">in</span> a <span class="comment"># False,bool类型</span></span><br><span class="line">g=<span class="string">&#x27;hi&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> a <span class="comment"># True,bool类型</span></span><br><span class="line"><span class="comment"># Replication(s*n)</span></span><br><span class="line">rep=a*<span class="number">2</span> <span class="comment"># &#x27;HelloWorldHelloWorld&#x27;,他主要是同一个字符串的重复,类似于a+a+...+a(n个a相加)</span></span><br></pre></td></tr></table></figure>
<p>Python的字符串还有很多内置的方法,可以通过.来调用,例如:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s.endswith(suffix)     <span class="comment"># 检查字符串后缀是否为suffix,如果有则返回True,否则返回False</span></span><br><span class="line">s.find(t)              <span class="comment"># 在字符串s中查找字符串t第一次出现的位置,如果找不到返回-1</span></span><br><span class="line">s.index(t)             <span class="comment"># 在字符串s中查找字符串t第一次出现的位置,如果找不到返回异常ValueError</span></span><br><span class="line">s.join(slist)          <span class="comment"># 以字符串s作为分隔符,将字符列表的所有元素连接成一个新的字符串</span></span><br><span class="line">s.replace(old,new)     <span class="comment"># 替换字符串s中所有old子字符串为new子字符串,返回一个新的字符串</span></span><br><span class="line">s.rfind(t)             <span class="comment"># 从字符串s的末尾开始查找字符串t最后一次出现的位置,如果找不到返回-1</span></span><br><span class="line">s.rindex(t)            <span class="comment"># 从字符串s的末尾开始查找字符串t最后一次出现的位置,如果找不到返回异常ValueError</span></span><br><span class="line">s.split([delim])       <span class="comment"># 以delim为分隔符切片s,如果不指定delim,则以空白字符(空格,换行,制表符等)为分隔符</span></span><br><span class="line">s.startswith(prefix)   <span class="comment"># 检查字符串前缀是否为prefix,如果有则返回True,否则返回False</span></span><br><span class="line">s.strip()              <span class="comment"># 删除字符串s两端的空白字符(空格,换行,制表符等),返回一个新的字符串</span></span><br></pre></td></tr></table></figure>
<p>值得注意的是,Python的字符串是不可改变的,也就是我们不能通过索引赋值和方法来修改已有的字符串,只能通过对整体的重新赋值来改变字符串的值,如:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s=<span class="string">&#x27;  Hello   &#x27;</span></span><br><span class="line"><span class="built_in">print</span>(s.strip()) <span class="comment"># &#x27;Hello&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(s) <span class="comment"># &#x27;  Hello   &#x27;,原字符串并没有改变</span></span><br></pre></td></tr></table></figure>
<p>对于上面罗列的方法,我们需要指出以下几点:</p>
<ol type="1">
<li>join方法中传入的slist一定要是一个字符串列表,否则会报错.</li>
<li>find和index方法的作用其实一样,但是唯一的不同在于find返回的是-1,而index会报出异常.因此在不确定子字符串是否存在的情况下,建议使用index方法.</li>
<li>在replace方法中,如果old子字符串在s中不存在,他并不会报错,返回的值仍然是原字符串s.</li>
</ol>
<p>Python在普通的字符串之外还提供几类特殊的字符串,如字节字符串,原始字符串和格式化字符串.</p>
<p>字节字符串(byte
string)是以b或者B开头的字符串,其是以字节为单位进行存储的,每个元素默认是0-255之间的整数,适合处理二进制数据,网络传输或者文件I/O等操作.他和普通字符串最大的区别在于,在Python3中,普通字符串依靠Unicode编码,每个字符可以是汉字,英文或者特殊符号等;而字节字符串并不依赖编码规则,而是直接存储字节,因为计算机中存储的最小单元就是字节,所以字节字符串可以存储更多类型的内容,如视频,音频等等.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">bstr=<span class="string">b&#x27;Hello&#x27;</span> <span class="comment"># 字节字符串</span></span><br><span class="line"><span class="built_in">print</span>(bstr) <span class="comment"># b&#x27;Hello&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(bstr[<span class="number">0</span>]) <span class="comment"># 72,字节字符串的每个元素是0-255之间的整数</span></span><br><span class="line"><span class="built_in">print</span>(bstr[<span class="number">1</span>:<span class="number">4</span>]) <span class="comment"># b&#x27;ell&#x27;,字节字符串的切片操作返回的仍然是字节字符串</span></span><br></pre></td></tr></table></figure>
<p>字节字符串并不能与普通字符串进行链接,否则会报类型错误;可以用索引访问每个字节,但是如果访问的是一个元素,返回的是字节对应的整数值,如果访问的是一个切片,返回的则是字节字符串.字节字符串和普通字符串之间可以通过encode和decode方法进行转换,如:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s=<span class="string">&#x27;Hello&#x27;</span></span><br><span class="line">bstr=s.encode(<span class="string">&#x27;utf-8&#x27;</span>) <span class="comment"># 普通字符串转换为字节字符串</span></span><br><span class="line"><span class="built_in">print</span>(bstr) <span class="comment"># b&#x27;Hello&#x27;</span></span><br><span class="line">s2=bstr.decode(<span class="string">&#x27;utf-8&#x27;</span>) <span class="comment"># 字节字符串转换为普通字符串</span></span><br><span class="line"><span class="built_in">print</span>(s2) <span class="comment"># &#x27;Hello&#x27;</span></span><br></pre></td></tr></table></figure>
<p>这里的utf-8表示编码格式,当然也可以使用其他编码格式,如ascii,latin1等.</p>
<p>原始字符串(raw
string)是以r或者R开头的字符串,其最大的特点在于字符串中的转义字符并不会被处理,换言之,他不会处理字符串中出现的\和其后面的字符,而是将其作为普通字符进行存储.如:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">rs=<span class="string">r&#x27;C:\newfolder\test.txt&#x27;</span> <span class="comment"># 原始字符串</span></span><br><span class="line"><span class="built_in">print</span>(rs) <span class="comment"># C:\newfolder\test.txt</span></span><br></pre></td></tr></table></figure>
<p>字符串是括号内包围的原始文本,与输入完全一致.这在反斜杠具有特殊意义的情况下很有用.例如:文件名,正则表达式等.原始字符串有如下的特点需要注意:</p>
<ol type="1">
<li><p>原始字符串不能以奇数个反斜杠结尾,因为这样最后一个反斜杠就不会有任何字符与之配对,会自动匹配引号,从而导致字符串没有结束符而报错.</p></li>
<li><p>字符串前的r/R只影响转义,不会影响字符串内容的其他特性.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">r&#x27;C:\path\to\file\\&#x27;</span> <span class="comment"># 正确,以偶数个反斜杠结尾</span></span><br><span class="line"><span class="string">r&#x27;C:\path\to\file\&#x27; # 错误,以奇数个反斜杠结尾,会报错</span></span><br><span class="line"><span class="string">len(r&#x27;</span>Hello\nWorld<span class="string">&#x27;) # 12,原始字符串中的\n不会被处理为换行符</span></span><br><span class="line"><span class="string">len(&#x27;</span>Hello\nWorld<span class="string">&#x27;) # 11,普通字符串中的\n被处理为换行符 </span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>格式化字符串(f-string)是以f或者F开头的字符串,其允许在字符串中嵌入表达式,这些表达式会在运行时被计算并替换为其结果.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name=<span class="string">&#x27;Alce&#x27;</span></span><br><span class="line">age=<span class="number">25</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;My name is <span class="subst">&#123;name&#125;</span>, I am <span class="subst">&#123;age&#125;</span> years old.&quot;</span>) <span class="comment"># My name is Alce, I am 25 years old.</span></span><br></pre></td></tr></table></figure>
<p>其基本的用法如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 表达式</span></span><br><span class="line">a, b = <span class="number">5</span>, <span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;a&#125;</span>+<span class="subst">&#123;b&#125;</span>=<span class="subst">&#123;a+b&#125;</span>&quot;</span>) <span class="comment"># 5+10=15</span></span><br><span class="line"><span class="comment"># 函数调用</span></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;pi=<span class="subst">&#123;math.pi:<span class="number">.2</span>f&#125;</span>&quot;</span>) <span class="comment"># pi=3.14,保留两位小数</span></span><br><span class="line"><span class="comment"># 格式化</span></span><br><span class="line">value = <span class="number">1234.56789</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;value:<span class="number">.2</span>f&#125;</span>&quot;</span>)   <span class="comment"># 保留两位小数 → 1234.57</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;value:<span class="number">10.2</span>f&#125;</span>&quot;</span>) <span class="comment"># 宽度10，右对齐 → &quot;   1234.57&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;value:&lt;<span class="number">10.2</span>f&#125;</span>&quot;</span>)<span class="comment"># 宽度10，左对齐 → &quot;1234.57   &quot;</span></span><br><span class="line">ratio=<span class="number">0.456</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;value:<span class="number">.1</span>%&#125;</span>&quot;</span>)<span class="comment"># 百分比格式 → 45.6%</span></span><br><span class="line"><span class="comment">#这里需要注意百分比格式的%和f是不能共存的</span></span><br><span class="line">num=<span class="number">42</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;num:05x&#125;</span>&quot;</span>) <span class="comment"># 十六进制格式 → 00042</span></span><br></pre></td></tr></table></figure>
<p>其有几个特点需要注意:</p>
<ol type="1">
<li>f-string中可以嵌入任意的Python表达式,包括函数调用,算术运算,条件表达式等,但是尽量不要太复杂,否则会影响代码的可读性.</li>
<li>大括号本身需要转义,可以使用双大括号来表示单个大括号.</li>
<li>f-string本身是支持转义字符的,但是在表达式中不支持转义字符.</li>
</ol>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Computer Science</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Pratical Python for dabeaz-List, File and Functions</title>
    <url>/2025/09/12/Practical-Python-List/</url>
    <content><![CDATA[<p>本笔记完全基于David Beazley的Python教程-<a
href="https://dabeaz-course.github.io/practical-python/Notes/Contents.html">Practical
Python</a>.</p>
<h2 id="list">1.5 List</h2>
<p>列表是Python中存储有序值集合的主要类型,用如下的方式创建:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">names=[<span class="string">&#x27;Elwood&#x27;</span>,<span class="string">&#x27;Jake&#x27;</span>,<span class="string">&#x27;Curtis&#x27;</span>]</span><br><span class="line">nums=[<span class="number">39</span>,<span class="number">38</span>,<span class="number">42</span>,<span class="number">65</span>,<span class="number">111</span>]</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>我们通过input函数接收到的输入是字符串形式,我们可以用字符串的split方法将其转换为列表形式:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">text=<span class="string">&#x27;GOOG,100,490.10&#x27;</span></span><br><span class="line">row=text.split(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(row) <span class="comment"># 输出为[&#x27;GOOG&#x27;,&#x27;100&#x27;,&#x27;490.10&#x27;]</span></span><br></pre></td></tr></table></figure>
<p>列表与C语言的数组不同,他允许列表内元素具有不同的数据类型.列表可以通过append方法,在列表末尾加新的元素;列表也可以利用insert方法,在指定索引位置插入新的元素:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">names.append(<span class="string">&#x27;Frank&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(names)<span class="comment"># [&#x27;Elwood&#x27;,&#x27;Jake&#x27;,&#x27;Curtis&#x27;,&#x27;Frank&#x27;]</span></span><br><span class="line">names.insert(<span class="number">2</span>,<span class="string">&#x27;Buster&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(names)<span class="comment"># [&#x27;Elwood&#x27;,&#x27;Jake&#x27;,&#x27;Buster&#x27;,&#x27;Curtis&#x27;,&#x27;Frank&#x27;]</span></span><br><span class="line">names.append(<span class="number">10</span>) </span><br><span class="line"><span class="built_in">print</span>(names)<span class="comment"># [&#x27;Elwood&#x27;,&#x27;Jake&#x27;,&#x27;Buster&#x27;,&#x27;Curtis&#x27;,&#x27;Frank&#x27;,10]</span></span><br></pre></td></tr></table></figure>
<p>列表的其余操作与字符串的操作基本一致,在此我们不再赘述.但是有两个不同需要我们额外指明:列表与字符串不同,他是可以通过索引赋值的方式修改列表内的元素的.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">names[<span class="number">1</span>]=<span class="string">&#x27;Joliet&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(names) <span class="comment"># [&#x27;Elwood&#x27;, &#x27;Joliet&#x27;, &#x27;Buster&#x27;, &#x27;Curtis&#x27;, &#x27;Frank&#x27;, 10]</span></span><br></pre></td></tr></table></figure>
<p>其次,列表是没有find方法的,如果我们希望在列表中查找某一个元素的索引,只能使用index方法,其如果查找失败返回的是ValueError,而不是find的-1.</p>
<p>因为前面我们提到了列表其实是可以被修改的,故而我们介绍对列表的删除操作.首先,列表自身具有remove方法,我们可以直接利用remove方法来移除我们指定的元素.但是需要注意的是,如果我们指定的元素出现了多次,那么remove方法仅移除第一次出现的;如果我们试图一个不存在的元素,那么他会抛出ValueError异常,因此使用remove方法的时候,尽量保证元素是合法的.除了remove方法以外,python还提供了一个关键字del,del可以直接针对性的删除某个位置的元素或者某段切片的元素.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">names.remove(<span class="string">&#x27;Buster&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(names)</span><br><span class="line"><span class="keyword">del</span> names[names.index(<span class="number">10</span>)]</span><br><span class="line"><span class="built_in">print</span>(names)</span><br><span class="line">s=[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">del</span> s[<span class="number">2</span>:<span class="number">5</span>]</span><br><span class="line"><span class="built_in">print</span>(s)</span><br></pre></td></tr></table></figure>
<p>python的删除操作并不会产生列表的空位,而是删除了以后,后续的元素不断前移来填充空位.</p>
<p>Python还提供了列表的排序方法.sort()方法可以在原地修改列表并返回None.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">nums.sort()</span><br><span class="line"><span class="built_in">print</span>(nums)</span><br></pre></td></tr></table></figure>
<p>sort方法则提供了两个比较常用的参数:key和reverse.reverse默认是False,也就是默认的排序方式是升序排序,可以通过给他赋值True来完成倒序排序;虽然列表允许其元素具有不同的数据类型,但是sort方法并不能够应用在不同的数据类型,需要用key来指定比较的方式,比较常见的是str,他会将不同的数据类型转换为字符串,并利用字符串的大小比较.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">nums.sort(reverse=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(nums)</span><br><span class="line">names.sort()</span><br><span class="line"><span class="built_in">print</span>(names)</span><br><span class="line">names.append(<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(names)</span><br><span class="line">names.sort(key=<span class="built_in">str</span>)</span><br><span class="line"><span class="built_in">print</span>(names)</span><br></pre></td></tr></table></figure>
<p>sort方法是在原列表的基础上修改,并不会生成新列表.如果希望生成新列表,而不在原列表上修改的话,可以使用sorted函数.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s=<span class="built_in">sorted</span>(names,key=<span class="built_in">str</span>,reverse=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(s)</span><br><span class="line"><span class="built_in">print</span>(names)</span><br></pre></td></tr></table></figure>
<p>这里我们需要指出的是列表是不支持数学运算的,因为他的加法被定义为拼接,乘法定义为重复.</p>
<p><a id="org5172e51"></a></p>
<h2 id="file-management">1.6 File Management</h2>
<p>打开文件的语法:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f=<span class="built_in">open</span>(<span class="string">&#x27;foo.txt&#x27;</span>,<span class="string">&#x27;rt&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>open接受两个参数,第一个参数就是需要打开的文件位置,第二个参数表示以什么模式打开文件,r表示以只读方式,如果文件不存在,就会报错;w为以只写的方式打开,如果文件不存在,那就会创建一个新文件,如果文件存在就会覆盖原文件内容;a表示追加,并不会覆盖原文件内容,而是在文件的末尾追加内容;r+和w+都表示同时赋予读写权限,但区别在于r+不会覆盖原文件,而遇到文件不存在就会报错;而w+会覆盖原文件,但文件不存在会创建一个文件.rt中的t表示以文本模式读取文件的内容,默认都是文本模式读取,故可以省略;但如果我们希望以二进制方式读取那么就需要自己显式声明,用b表示.</p>
<p>文件读取的语法:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data=f.read(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line">data=f.read()</span><br><span class="line"><span class="built_in">print</span>(data)</span><br></pre></td></tr></table></figure>
<p>read方法会一次性读取到文件末尾,而read(n)则是读取n个字符.因此,我们的示例代码的意思是先读取两个字符并输出,然后再从第三个字符开始一直读取到最后再输出.如果我们将这两个读取函数换一下,那么第一次就会返回全部字符,第二次则是返回EOF.</p>
<p>文件的关闭语法:
Python提供了一个手动的close方法,可以自己在程序中手动控制文件的关闭.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f.close()</span><br></pre></td></tr></table></figure>
<p>但是在大项目中,同时打开多个文件,文件的关闭检查是一个十分困难的事情.因此python提供了with语句来简化了文件的关闭操作,他会在进入缩进代码块时打开文件,并在离开缩进代码块时自动关闭文件:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(filename,<span class="string">&#x27;rt&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">  statements</span><br></pre></td></tr></table></figure>
<p>文件逐行读取的方法:因为read方法他默认了从头读取到尾,如果字符串是多行字符串,我们希望逐行读取,可以利用如下代码实现,</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(filename,<span class="string">&#x27;rt&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">  <span class="keyword">for</span> line <span class="keyword">in</span> file:</span><br><span class="line">    <span class="built_in">print</span>(line.strip())</span><br></pre></td></tr></table></figure>
<p>文件的写入方法:python提供了一个write方法来为文件写入字符串数据.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;outfile&#x27;</span>,<span class="string">&#x27;wt&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">  out.write(<span class="string">&#x27;Hello World\n&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>同时也可以利用输出重定向的方式来实现.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;outfile&#x27;</span>,<span class="string">&#x27;wt&#x27;</span>) <span class="keyword">as</span> out:</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;Hello World&#x27;</span>,file=out)</span><br></pre></td></tr></table></figure>
<h2 id="functions">1.7 Functions</h2>
<p>函数是一系列执行任务并返回结果的语句,需要使用return关键词显式指定函数的返回值.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fun_name</span>:</span><br><span class="line">  statements</span><br><span class="line">  <span class="keyword">return</span> return_result</span><br></pre></td></tr></table></figure>
<p>函数通过异常来报告错误,异常会导致函数中止;如果异常没有被处理,那么整个程序就会停止.为了调试目的,异常信息会描述发生了什么,错误发生的位置以及一个回溯信息,显示导致失败的其他函数调用.</p>
<p>异常可以被捕捉和处理.捕捉异常可以使用try-except语句,</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> file:</span><br><span class="line">  fields = line.split(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">  <span class="keyword">try</span>:</span><br><span class="line">    shares = <span class="built_in">int</span>(fields[<span class="number">1</span>])</span><br><span class="line">  <span class="keyword">except</span> ValueError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Couldn&#x27;t parse&quot;</span>, line)</span><br></pre></td></tr></table></figure>
<p>这里我们用ValueError举例,实际上我们需要与试图捕捉的异常类型相匹配.显然,我们在运行程序时并不知道会发生什么异常,因此异常捕捉一般出现在程序意外崩溃之后才被添加.</p>
<p>同时,我们可以在程序中主动抛出异常,使用raise语句,</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">raise</span> RuntimeError(<span class="string">&#x27;What a kerfuffle&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>这个异常同样会导致程序运行中断,也可以用try-except捕捉:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">raise</span> RuntimeError(<span class="string">&#x27;What a kerfuffle&#x27;</span>)</span><br><span class="line"><span class="keyword">except</span> RuntimeError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;异常处理完成&quot;</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Computer Science</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Pratical Python for dabeaz-Datatype</title>
    <url>/2025/10/10/Practical-Python-Datatype/</url>
    <content><![CDATA[<p>本笔记完全基于David Beazley的Python教程-<a
href="https://dabeaz-course.github.io/practical-python/Notes/Contents.html">Practical
Python</a>.</p>
<h2 id="datatypes-and-data-structures">2.1 Datatypes and Data
structures</h2>
<p>None类型: None可选或缺失值的占位符.在条件语句中,认为是False.</p>
<p>元组指的是一组值的组合,其利用如下的方式声明,</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s=(<span class="string">&#x27;GOOG&#x27;</span>,<span class="number">100</span>,<span class="number">49.1</span>)</span><br><span class="line">s=<span class="string">&#x27;GOOG&#x27;</span>,<span class="number">100</span>,<span class="number">49.1</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>()的存在对于定义元组并不是重要的,可以舍去.而我们还有如下两种特殊情况,</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s=() <span class="comment"># 0元组</span></span><br><span class="line">s=(<span class="string">&#x27;GooG&#x27;</span>,) <span class="comment"># 一元组</span></span><br><span class="line">s=<span class="string">&#x27;GOOG&#x27;</span>, </span><br></pre></td></tr></table></figure>
<p>这里需要注意的是一元组的声明是必须要有,在末尾的,否则会被视作基本数据类型.零元组的定义声明则必须要存在(),否则将无法区分语法错误和赋值.</p>
<p>元组通常用于表示简单的记录或者结构.他是一个由多部分组成的单个对象,其包含的多个部分是允许具有不同的数据类型的.和列表一样,他也是一个有序集合,也就是他可以通过下标索引得到对应的值.但不同在于他无法修改元组内容,虽然我们可以通过当前元组去生成一个新元组的方式来覆盖原元组,但其与修改还是有执行逻辑上的差异.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s=(s[<span class="number">0</span>],<span class="number">75</span>,s[<span class="number">2</span>])</span><br></pre></td></tr></table></figure>
<p>我们可以认为元组是把几个相关对象打包成一个实体对象,这样的话,可以在函数调用之中同时传输几个相关对象.元组解包的方式则是利用左侧变量的赋值来获得,但要求左侧变量的数量与元组结构内的相匹配,至于类型则并不需要,因为Python的变量类型是可以通过程序自动调整的.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">names,shares,prices=s</span><br></pre></td></tr></table></figure>
<p>从我们上面的讨论中,元组可以被认为是只读列表,但一般而言,列表存放多个独立变量对象的数据集合,而元组则是描述一个不会改变的事物的属性.</p>
<p>字典则是对于键与值的映射,所以其是键对的集合,这个与Hash表,关联数组十分类似,都可以通过键来访问对应的值.如</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d=&#123;</span><br><span class="line">    <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;GOOG&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;share&#x27;</span>:<span class="number">100</span>,</span><br><span class="line">    <span class="string">&#x27;prices&#x27;</span>:<span class="number">470.10</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(d[<span class="string">&#x27;name&#x27;</span>])</span><br></pre></td></tr></table></figure>
<p>与元组不可修改的性质不同,字典可以根据键名赋值的方式来修改或添加字典值,</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s[<span class="string">&#x27;shares&#x27;</span>]+=<span class="number">100</span></span><br><span class="line"><span class="built_in">print</span>(s[<span class="string">&#x27;shares&#x27;</span>])</span><br><span class="line">s[<span class="string">&#x27;date&#x27;</span>]=<span class="string">&#x27;6/6/2024&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(s)</span><br></pre></td></tr></table></figure>
<p>如果希望删除字典中的某个键对,我们可以利用del关键字来完成删除操作.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">del</span> s[<span class="string">&#x27;date&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(s)</span><br></pre></td></tr></table></figure>
<p>对于字典,有如下额外的操作</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">l=<span class="built_in">list</span>(d) <span class="comment"># 利用list()函数可以将字典的所有键提取成一个列表</span></span><br><span class="line"><span class="built_in">print</span>(l)</span><br></pre></td></tr></table></figure>
<p>list函数会默认读取字典的键,换言之,字典其实有点像是某种意义的封装实体,外界访问字典仅可以通过其键来访问他的值,故而其读取会默认读取字典的键.所以从这个角度来看,如果利用for循环迭代访问字典,迭代的结果其实就是字典的key.</p>
<p>字典提供了一个keys()方法来提取字典的键,其结果并不是常见的数据类型,而是dict_keys,他是一个关于字典键的动态视图.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">keys=d.keys()</span><br><span class="line"><span class="built_in">print</span>(keys)</span><br><span class="line"><span class="keyword">del</span> d[<span class="string">&#x27;account&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(keys)</span><br></pre></td></tr></table></figure>
<p>这个动态视图的动态性指的是他可以同步更新对相关字典的改变,而不需要通过再赋值的方式来修改.同样,字典还提供了提取字典值的方法values,其结果类型是dict_values,他是关于字典值的动态视图.还提供了提取字典键值对的方法items,其结果类型是dict_items,他则是关于字典键值对的动态视图.
如果我们存在一个已知的dict_items类型,可以利用dict函数直接生成一个字典.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d_item=d.items()</span><br><span class="line"><span class="built_in">print</span>(d_item)</span><br><span class="line">dnew=<span class="built_in">dict</span>(d_item)</span><br><span class="line"><span class="built_in">print</span>(dnew)</span><br></pre></td></tr></table></figure>
<p>值得注意的是,这些东西只是提供了字典的某种动态视图,他并不支持下标访问也不支持修改,如果需要修改,那么需要修改原字典.</p>
<p><a id="org3dadcbf"></a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Computer Science</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Pratical Python for dabeaz-Container</title>
    <url>/2025/10/10/Practical-Python-Container/</url>
    <content><![CDATA[<p>本笔记完全基于David Beazley的Python教程-<a
href="https://dabeaz-course.github.io/practical-python/Notes/Contents.html">Practical
Python</a>.</p>
<h2 id="container">2.2 Container</h2>
<p>Python中提供了存储多个对象的容器,主要为列表,字典或集合.列表一般用于存储有序数据;字典则是用于存储无需数据;集合则是与字典类似,但其用于存储无序且不允许重复元素的数据.</p>
<p>我们先介绍集合的概念,其的赋值方式和字典十分类似,但是不同的是他只存储元素值,而字典存储键值对.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s=&#123;<span class="string">&#x27;IBM&#x27;</span>,<span class="string">&#x27;GOOG&#x27;</span>&#125; <span class="comment"># 集合赋值</span></span><br><span class="line">d=&#123;<span class="string">&#x27;IBM&#x27;</span>:<span class="number">90.1</span>,<span class="string">&#x27;GOOG&#x27;</span>:<span class="number">23.12</span>&#125; <span class="comment"># 字典赋值</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>字典和集合存储的都是无序数据,因此他们并不支持利用下标的方式索引,而是利用关键字的方式加以检索.但不同的是,由于字典和集合的赋值方式十分类似,因此我们需要指出二者的空集声明方式是不同的,如</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s=<span class="built_in">set</span>() <span class="comment"># 空集合</span></span><br><span class="line">d=&#123;&#125; <span class="comment"># 空字典</span></span><br><span class="line">s=<span class="built_in">set</span>([<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;a&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(s) <span class="comment"># &#123;&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;&#125;</span></span><br></pre></td></tr></table></figure>
<p>从上面的赋值过程,我们发现其实我们是可以给集合赋值重复元素的,但是程序会自动清除重复元素,因此集合可用来处理程序中出现的重复元素.一般来说,字典的基本操作是键值之间的映射运算,而集合的基本操作则是集合运算,如</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s1=&#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>&#125;</span><br><span class="line">s2=&#123;<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>&#125;</span><br><span class="line">s1|s2 <span class="comment"># 集合并运算:a b c d e</span></span><br><span class="line">s1&amp;s2 <span class="comment"># 集合交运算:c</span></span><br><span class="line">s1-s2 <span class="comment"># 集合差运算:a b</span></span><br><span class="line">s1^s2 <span class="comment"># 集合对称差运算:a b</span></span><br><span class="line">s1.add(<span class="string">&#x27;f&#x27;</span>) <span class="comment"># 集合添加元素操作</span></span><br><span class="line">s2.remove(<span class="string">&#x27;a&#x27;</span>) <span class="comment"># 集合删除元素操作</span></span><br></pre></td></tr></table></figure>
<p>集合和字典一样,底层都是由Hash表实现,因此在字典和集合中查找元素所需的时间复杂度为O(1).</p>
<p>如果考虑的数据对数据顺序十分敏感,那么建议采用列表来存储数据.列表可以包含任何类型的数据对象.列表的构建可以从空列表开始,利用append方法不断延展列表内容.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">l=[]<span class="comment"># 建立空列表</span></span><br><span class="line">l.append(<span class="number">12</span>)</span><br><span class="line">l.append(<span class="number">12.34</span>)</span><br></pre></td></tr></table></figure>
<p>这里我们需要额外声明一下,如果我们想利用append方法往列表内输入元组,必须使用()来显式展示出我们输入的对象是元组,如果我们不加(),会让系统误认为输入了多个参数,从而导致程序报错.</p>
<p>如果考虑的数据需要快速随机查找或者频繁随机查找(随机查找就是按键查找),那么建议采用字典来存储数据.同样,字典的构造也是从空字典开始,而后不断追加字典元素.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d=&#123;&#125;</span><br><span class="line">d[<span class="string">&#x27;IBM&#x27;</span>]=<span class="number">90.2024</span></span><br><span class="line">d[<span class="string">&#x27;AA&#x27;</span>]=<span class="number">10.2</span></span><br></pre></td></tr></table></figure>
<p>对字典的查找,我们可以利用in来完成查找,返回的值是True/False.这一般是用来判断字典中是否存在特定的键.但我们可能需要直接获取键对应的值,那么我们可以采用get方法,他有两个参数,第一个用于输入用于查找的键,第二个则是如果查找不到,则会输出的默认值.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;IBM&#x27;</span> <span class="keyword">in</span> d) <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;AA&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> d) <span class="comment"># False</span></span><br><span class="line"><span class="built_in">print</span>(d.get(<span class="string">&#x27;IBM&#x27;</span>,<span class="number">0.0</span>)) <span class="comment"># 90.2024</span></span><br><span class="line"><span class="built_in">print</span>(d.get(<span class="string">&#x27;AB&#x27;</span>,<span class="number">0.0</span>) <span class="comment"># 0.0</span></span><br></pre></td></tr></table></figure>
<p>字典的键并不是强制要求是字符串,但要求其是不可变的,如元组;列表,集合和其他的字典都不可以作为字典的键.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">holiday=&#123;</span><br><span class="line">    (<span class="number">1</span>,<span class="number">3</span>):<span class="string">&#x27;New York&#x27;</span>,</span><br><span class="line">    (<span class="number">5</span>,<span class="number">6</span>):<span class="string">&#x27;Wuhan&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(holiday[<span class="number">1</span>,<span class="number">3</span>])</span><br></pre></td></tr></table></figure>
<p><a id="orgc8c4435"></a></p>
<h2 id="sequence">2.3 Sequence</h2>
<p>Python中给出了三种不同的序列类型:字符串,列表和元组.序列指有序的数据结构,因此他们可以按整数下标进行索引,同时可以获取其长度.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=<span class="string">&#x27;Hello&#x27;</span> <span class="comment"># String</span></span><br><span class="line">b=[<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>] <span class="comment"># List</span></span><br><span class="line">c=(<span class="string">&#x27;GOOG&#x27;</span>,<span class="number">100</span>,<span class="number">490.1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Indexed order</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(b[-<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(c[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Length of sequence</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(a))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(b))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(c))</span><br></pre></td></tr></table></figure>
<p>序列的基本操作:可以利用*来重复序列数据;+用来串联两个相同类型的序列数据,一定要是相同类型的,不同类型会报错</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(a*<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(b*<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(c*<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">a=(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">b=(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(a+b)</span><br></pre></td></tr></table></figure>
<p>由于序列具有按下标索引的方式,因此序列可以做切片操作,从原序列中提取出子序列,其形式为s[start,end],其从s[start]一直提取到s[end-1].</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=<span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">9</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">2</span>:<span class="number">5</span>])</span><br><span class="line"><span class="built_in">print</span>(a[-<span class="number">5</span>:])</span><br><span class="line"><span class="built_in">print</span>(a[:<span class="number">3</span>])</span><br></pre></td></tr></table></figure>
<p>序列切片的注意点:</p>
<ol type="1">
<li>索引的开始和结束必须是整数</li>
<li>切片提取的时候并不会提取尾值</li>
<li>如果开始或结束有省略值,那么默认为序列开始或者末尾</li>
</ol>
<p>序列的切片重赋值操作并不需要提取出的切片长度和赋值长度相同,程序会自己调整;可以利用del关键字,直接对序列的某段切片执行删除操作.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b=<span class="built_in">list</span>(a)</span><br><span class="line">b[<span class="number">2</span>:<span class="number">5</span>]=[<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>]</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="keyword">del</span> b[<span class="number">2</span>:<span class="number">5</span>]</span><br><span class="line"><span class="built_in">print</span>(b)</span><br></pre></td></tr></table></figure>
<p>序列的常用函数:sum(对序列元素求和),min(选取序列元素的最小值),max(选取序列元素的最大值).需要注意的是这里的sum并不能对字符串操作,min和max也不能让字符串和数字比较.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t = [<span class="string">&#x27;Hello&#x27;</span>, <span class="string">&#x27;World&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">max</span>(t))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">max</span>(<span class="built_in">max</span>(t)))</span><br></pre></td></tr></table></figure>
<p>序列迭代,其实是在迭代序列中的每个元素.每个循环会从序列中提取出一个值放入迭代量i中,再对迭代量i操作.每次循环都会对迭代量i进行覆盖,并且与C的for循环不同,Python的迭代量并不会因为循环结束而释放,并保留最后一次迭代值.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s=[<span class="number">1</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">16</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure>
<p>类似C/C++,Python同样具有break和continue.break适用于跳出循环,但是他只能跳出一层循环,如果我们在嵌套循环中使用,那么break只能跳出当前最内层的循环.continue则是直接跳过本次循环进入下一次循环.</p>
<p>range函数可以创建一个可迭代对象,一般是用于for循环中.其语法形式为</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">range</span>(stop)</span><br><span class="line"><span class="built_in">range</span>(start,stop[,step])</span><br></pre></td></tr></table></figure>
<p>start表示计数从start开始,如果不提供start,那么默认从0开始.stop表示计数到stop,但是不包括stop.step表示推进步长,默认是1.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    <span class="built_in">print</span>(i*i)</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>,<span class="number">20</span>):</span><br><span class="line">    <span class="built_in">print</span>(j)</span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>,<span class="number">51</span>,<span class="number">2</span>):</span><br><span class="line">    <span class="built_in">print</span>(k)</span><br></pre></td></tr></table></figure>
<p>enumerate函数是用于将一个可遍历的数据对象组合为一个索引序列可以同时列出数据和数据下标,一般用于for循环中.他和直接用序列迭代的不同在于提供了额外的计数器来获得对应的数据下标.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">enumerate</span>(sequence,[start=<span class="number">0</span>])</span><br></pre></td></tr></table></figure>
<p>sequence指序列或某种可迭代的对象,start表示下标计数开始的位置,默认是0.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">names=[<span class="string">&#x27;Elwood&#x27;</span>,<span class="string">&#x27;Jake&#x27;</span>,<span class="string">&#x27;Curtis&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> i,name <span class="keyword">in</span> <span class="built_in">enumerate</span>(names):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;i=&#x27;</span>,i,<span class="string">&#x27;name=&#x27;</span>,name)</span><br><span class="line"><span class="keyword">for</span> i,name <span class="keyword">in</span> <span class="built_in">enumerate</span>(names,start=<span class="number">1</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;i=&#x27;</span>,i,<span class="string">&#x27;name=&#x27;</span>,name)</span><br></pre></td></tr></table></figure>
<p>enumerate有个十分常见的应用场景,就是读取文件的行号.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(file,<span class="string">&#x27;rt&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">  <span class="keyword">for</span> lineno,line <span class="keyword">in</span> <span class="built_in">enumerate</span>(f,start=<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>对于元组列表,如果我们直接用一个迭代量进行迭代,那么他会赋值元组,并不是很好操作.我们可以用多个迭代量加以迭代,这样的好处是他会对元组进行解包,每个迭代量对应元组的相应量.这要求迭代量的数量必须与每个元组的项数匹配,列表中每个元组的项数必须相等.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">points = [</span><br><span class="line">    (<span class="number">1</span>, <span class="number">4</span>),(<span class="number">10</span>, <span class="number">40</span>),(<span class="number">23</span>, <span class="number">14</span>),(<span class="number">5</span>, <span class="number">6</span>),(<span class="number">7</span>, <span class="number">8</span>)</span><br><span class="line">]</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> points:</span><br><span class="line">    <span class="built_in">print</span>(x)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x, y <span class="keyword">in</span> points:</span><br><span class="line">    <span class="built_in">print</span>(x,y)</span><br></pre></td></tr></table></figure>
<p>zip函数通过接受多个序列,将其组合之后创建一个迭代器,其类型为zip类型.如果接收到的多个序列长度不一样,那么zip函数的结果以最短的序列为基准.zip比较常见的应用其实是为了创建字典来构造键值对.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">columns = [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;shares&#x27;</span>, <span class="string">&#x27;price&#x27;</span>]</span><br><span class="line">values = [<span class="string">&#x27;GOOG&#x27;</span>, <span class="number">100</span>, <span class="number">490.1</span> ]</span><br><span class="line">pairs = <span class="built_in">zip</span>(columns, values)</span><br><span class="line">d=<span class="built_in">dict</span>(pairs)</span><br></pre></td></tr></table></figure>
<p><a id="orgaa2373f"></a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Computer Science</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Pratical Python for dabeaz-Collection</title>
    <url>/2025/10/10/Practical-Python-Collection/</url>
    <content><![CDATA[<p>本笔记完全基于David Beazley的Python教程-<a
href="https://dabeaz-course.github.io/practical-python/Notes/Contents.html">Practical
Python</a>.</p>
<h2 id="collection-module">2.4 Collection module</h2>
<p>collection模块提供了一些用于数据处理的对象.如Counter计数器,defaultdict和deque等.在此我们只介绍这三个对象.</p>
<p>Counter其实是字典的一个子类,他与普通的字典的区别在于,他的键为待计数的元素,他的值为计数值或其余相关的数据;因此他的值虽然是计数值,但实际上是允许出现0或者负值的.此外,如果我们在字典中查找一个不存在的键,那么会返回一个KeyError异常,而如果对于Counter类查找一个不存在的键,他并不会报错,并且返回0,同时创建一个新键值对,计数值设为0.</p>
<span id="more"></span>
<p>Counter常见的实例化方法如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line">d=Counter() <span class="comment"># 实例化一个空对象</span></span><br><span class="line">d=Counter(iterable objective) <span class="comment"># 实例化一个可迭代对象,其元素为可迭代对象的元素,并且对应的count值设定为1</span></span><br><span class="line">d=Counter(mapping objective) <span class="comment"># 实例化一个映射对象,这里的赋值会依赖于映射的值,此处可以将count值赋为其他类型的值</span></span><br><span class="line">d=Counter(a=<span class="number">1</span>,b=<span class="number">2</span>,c=<span class="number">3</span>) <span class="comment"># 利用关键字参数实例化</span></span><br></pre></td></tr></table></figure>
<p>这里虽然Counter类是字典类的一个子类,所以他其实并没有顺序,但print的顺序是依据键值的大小顺序排列,从大到小排序.还有一个地方需要注意的是如果以字典来实例化Counter类,字典的键可以重复,如果出现了多次相同的键,那么他会保存最后一个键值对,因此利用字典实例化Counter类的话,是可以出现重复的键.但是如果选用利用关键字参数实例化,那么并不可以这样,如果出现了多个相同的关键字,那么他就会报SyntaxError异常.</p>
<p>Counter的常用方法是most_common(n).他的作用是输出计数值最大的n个对象.如果n小于Counter类的元素总数,那么输出的结果就是n个Counter类计数值最大的前n个元素;如果n大于等于Counter类的元素个数,那么相当于直接输出Counter类的所有元素;如果没有输入n,那么也是默认输出全部元素;如果输入n=-1,那么返回空列表.这里我们需要强调一点的是Counter的most_common(n)返回的并不是Counter类,而是列表类型.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(d.most_common(<span class="number">3</span>))</span><br></pre></td></tr></table></figure>
<p>普通的字典是一对一的映射,也就是一个键只能对应一个值;我们可以利用的defaultdict来完成一对多的映射,其基本语法为</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line">d=defaultdict(default_factory)</span><br></pre></td></tr></table></figure>
<p>这里的default_factory是一个可调用对象(比如int,list,set,str),用于生成默认值.如果在defaultdict中查找一个不存在的键,他并不会报错,而是依据可调用对象的方式生成一个默认值.例如int对应的默认值为0,list对应的默认值为[],set对应的默认值为set(),str对应的默认值为''.因此他的一对多映射由如下形式定义:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line">d=default(<span class="built_in">list</span>)</span><br><span class="line">d=[<span class="string">&#x27;x&#x27;</span>].append(<span class="number">10</span>)</span><br><span class="line">d=[<span class="string">&#x27;x&#x27;</span>].append(<span class="number">20</span>)</span><br><span class="line"><span class="built_in">print</span>(d)</span><br></pre></td></tr></table></figure>
<p>deque是双端队列,因此他的队列两端的插入删除操作时间复杂度为O(1).当然可以把他当做stack或者queue使用,只需要调用输入输出方法的时候控制两端的输入输出.其基本语法为:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">d=deque(iterable=<span class="literal">None</span>,maxlen=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
<p>其中的iterable表示可以输入一个可迭代对象,用来初始化队列;maxlen表示双端队列的最大长度,如果超过了这个长度,那么就从另一端弹出元素.队列常用的操作如下</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<colgroup>
<col  class="org-left" />
<col  class="org-left" />
<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">
方法
</th>
<th scope="col" class="org-left">
功能
</th>
<th scope="col" class="org-left">
示例
</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">
append(x)
</td>
<td class="org-left">
在右端添加元素
</td>
<td class="org-left">
d.append(i)
</td>
</tr>
<tr>
<td class="org-left">
appendleft(x)
</td>
<td class="org-left">
在左端添加元素
</td>
<td class="org-left">
d.appendleft(i)
</td>
</tr>
<tr>
<td class="org-left">
pop()
</td>
<td class="org-left">
弹出右端元素
</td>
<td class="org-left">
d.pop()
</td>
</tr>
<tr>
<td class="org-left">
popleft()
</td>
<td class="org-left">
弹出左端元素
</td>
<td class="org-left">
d.popleft()
</td>
</tr>
<tr>
<td class="org-left">
extend(iterable)
</td>
<td class="org-left">
在右端批量添加元素
</td>
<td class="org-left">
d.extend([3,4])
</td>
</tr>
<tr>
<td class="org-left">
extendleft(iterable)
</td>
<td class="org-left">
在左端批量添加元素(顺序反转)
</td>
<td class="org-left">
d.extendleft([1,2])
</td>
</tr>
<tr>
<td class="org-left">
rotate(n)
</td>
<td class="org-left">
向右旋转n步(负数向左)
</td>
<td class="org-left">
d.rotate(1)
</td>
</tr>
<tr>
<td class="org-left">
clear()
</td>
<td class="org-left">
清空队列
</td>
<td class="org-left">
d.clear()
</td>
</tr>
</tbody>
</table>
<p>这里需要强调的是关于extendleft和rotate的应用,我们用下面的示例代码来演示:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># extendleft</span></span><br><span class="line">d=deque([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line">d.extendleft([<span class="number">5</span>,<span class="number">6</span>])</span><br><span class="line"><span class="built_in">print</span>(d) <span class="comment"># deque([6,5,1,2,3,4])</span></span><br><span class="line"><span class="comment"># rotate</span></span><br><span class="line">d = deque([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line">d.rotate(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(d)  <span class="comment"># deque([4, 1, 2, 3])</span></span><br><span class="line">d.rotate(-<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(d)  <span class="comment"># deque([2, 3, 4, 1])</span></span><br></pre></td></tr></table></figure>
<p><a id="org97dfeb8"></a></p>
<h2 id="list-comprehensions">2.5 List Comprehensions</h2>
<p>列表推导式其实就是循环的一种高效写法,他可以视作将操作应用到序列中的每个元素来创建列表.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">square=[s*s <span class="keyword">for</span> s <span class="keyword">in</span> x] <span class="comment"># 计算x每个元素的平方</span></span><br></pre></td></tr></table></figure>
<p>不仅如此,还可以通过加if条件判断语句来过滤一些元素,如</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x=[<span class="number">1</span>,-<span class="number">2</span>,<span class="number">3</span>,-<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">square=[s*s <span class="keyword">for</span> s <span class="keyword">in</span> x <span class="keyword">if</span> s&gt;<span class="number">0</span>] <span class="comment"># 计算x中每个正元素的平方</span></span><br></pre></td></tr></table></figure>
<p>因此列表推导式的通用格式如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[&lt;expression&gt; <span class="keyword">for</span> &lt;variable_name&gt; <span class="keyword">in</span> &lt;sequence&gt; <span class="keyword">if</span> &lt;condition&gt;]</span><br></pre></td></tr></table></figure>
<p>比较常见的应用如下:</p>
<ol type="1">
<li><p>通过列表推导式收集特定的字典的值.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">names=[stu[<span class="string">&#x27;name&#x27;</span>] <span class="keyword">for</span> stu <span class="keyword">in</span> classes]</span><br></pre></td></tr></table></figure></li>
<li><p>可以执行类似数据库的查找操作</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">height_name=[stu[<span class="string">&#x27;name&#x27;</span>] <span class="keyword">for</span> stu <span class="keyword">in</span> classes <span class="keyword">if</span> (stu[<span class="string">&#x27;height&#x27;</span>]&gt;<span class="number">170</span>)&amp;&amp;(stu[<span class="string">&#x27;height&#x27;</span>]&lt;<span class="number">180</span>)]</span><br></pre></td></tr></table></figure></li>
<li><p>可以同时执行列表函数操作</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">total=<span class="built_in">sum</span>([stu[<span class="string">&#x27;scores&#x27;</span>] <span class="keyword">for</span> stu <span class="keyword">in</span> classes])</span><br></pre></td></tr></table></figure></li>
</ol>
<p>类似与列表推导式,其实还存在如集合推导式和字典推导式,在这快速介绍一下,集合推导式的作用其实是可以用来去除一下重复的元素,字典推导式则是在集合推导式的基础上指定键值对映射.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">names=&#123;stu[<span class="string">&#x27;name&#x27;</span>] <span class="keyword">for</span> stu <span class="keyword">in</span> classes&#125;</span><br><span class="line">names_score=&#123;stu[<span class="string">&#x27;name&#x27;</span>]:stu[<span class="string">&#x27;scores&#x27;</span>] <span class="keyword">for</span> stu <span class="keyword">in</span> classes&#125;</span><br></pre></td></tr></table></figure>
<p><a id="orgb093176"></a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Computer Science</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Pratical Python for dabeaz-Object</title>
    <url>/2025/10/10/Practical-Python-Object/</url>
    <content><![CDATA[<p>本笔记完全基于David Beazley的Python教程-<a
href="https://dabeaz-course.github.io/practical-python/Notes/Contents.html">Practical
Python</a>.</p>
<h2 id="objects">2.6 Objects</h2>
<p>Python的赋值并非赋实际值,而是创建并赋值引用副本.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">b=a</span><br><span class="line">c=[a,b]</span><br></pre></td></tr></table></figure>
<p>这里我们设计了三个变量,但其实底层只有一个列表对象[1,2,3],有四个不同的引用指向他,如果我们修改其中任意一个量,都会导致所有引用的值变化.</p>
<span id="more"></span>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b.append(<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(a) <span class="comment"># [1,2,3,4]</span></span><br><span class="line"><span class="built_in">print</span>(b) <span class="comment"># [1,2,3,4]</span></span><br><span class="line"><span class="built_in">print</span>(c) <span class="comment"># [[1,2,3,4],[1,2,3,4]]</span></span><br></pre></td></tr></table></figure>
<p>因此对于任意一个引用副本的变化都会导致全局引用副本的数值变化.因此这与其他的语言十分不同,需要牢记修改的谨慎性.由于赋值并不是赋实际值,而是赋引用副本.那么对变量的重新赋值并不会修改先前指向的内存结果,而只是修改引用指向的位置.</p>
<p>is运算符可以用来判断两个变量是否对应相同的对象.其是通过比较对象身份的方式进行的,而对象身份则是用id()来获取.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">b=a</span><br><span class="line"><span class="built_in">print</span>(a <span class="keyword">is</span> b) <span class="comment"># true</span></span><br><span class="line">c=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(a <span class="keyword">is</span> c) <span class="comment"># false</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(a)) <span class="comment"># 2340643625152,每次运行都会不同</span></span><br></pre></td></tr></table></figure>
<p>这里我们发现a和b是指向同一个对象,但是a和c却并不是,尽管a和c指向的对象值完全一样,这是因为尽管他们的指向的对象值一样,但是他们在计算机里面的逻辑存储位置不同,因此他们并不是同一个对象.但是我们可以利用==运算符来判断他们是否值相同,但值得注意的是变量具有相同的值并不一定代表指向相同的对象.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(a==b) <span class="comment"># true</span></span><br><span class="line"><span class="built_in">print</span>(a==c) <span class="comment"># true</span></span><br></pre></td></tr></table></figure>
<p>对于列表和字典,除了赋值的方法获得副本,还可以通过复制的方式获得副本.需要指出赋值和复制的区别在于如果直接赋值,那么两个变量就会指向同一个对象,容易出现在程序其他地方修改导致的不可预测的错误;而复制只是复制对象的值,并不会指向相同的对象,可以保证独立性.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># shallow copies</span></span><br><span class="line">a=[<span class="number">2</span>,<span class="number">3</span>,[<span class="number">100</span>,<span class="number">101</span>],<span class="number">4</span>]</span><br><span class="line">b=<span class="built_in">list</span>(a)</span><br><span class="line"><span class="built_in">print</span>(a <span class="keyword">is</span> b) <span class="comment"># false</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">1</span>] <span class="keyword">is</span> b[<span class="number">1</span>]) <span class="comment"># false</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">2</span>] <span class="keyword">is</span> b[<span class="number">2</span>]) <span class="comment"># true</span></span><br></pre></td></tr></table></figure>
<p>这里我们发现如果我们用list()做浅复制,那列表内的基本数据类型项并不指向相同的对象,但拥有相同的值;而对于内部列表项(实际上,可以延拓到其他的序列类型),却是指向相同的对象,也就是修改任意一个变量的内部列表项是会传递到另一个,而如果修改其他的基本数据类型项则不会影响.</p>
<p>为了进一步完全的通过复制的方式获得全部数据项的副本,而不是某些项指向相同的对象,可以通过调用copy模块来完成这个操作</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># deep copy</span></span><br><span class="line"><span class="keyword">import</span> copy</span><br><span class="line">a=[<span class="number">2</span>,<span class="number">3</span>,[<span class="number">100</span>,<span class="number">101</span>],<span class="number">4</span>]</span><br><span class="line">b=copy.deepcopy(a)</span><br><span class="line"><span class="built_in">print</span>(a <span class="keyword">is</span> b) <span class="comment"># false</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">1</span>] <span class="keyword">is</span> b[<span class="number">1</span>]) <span class="comment"># false</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">2</span>] <span class="keyword">is</span> b[<span class="number">2</span>]) <span class="comment"># false</span></span><br></pre></td></tr></table></figure>
<p>deepcopy会将对象及其包含的所有对象一起复制,不会出现其中内嵌的序列类型项指向相同的对象.</p>
<p>类型检查:可以通过利用isinstance()函数来判断一个对象是否为特定类型.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">isinstance</span>(variable,<span class="built_in">type</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">isinstance</span>(a,<span class="built_in">list</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;a is a list&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>我们可以利用元组的方式查找多个可能的类型:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">isinstance</span>(a,<span class="built_in">list</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;a is a list&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>最好不要频繁使用类型检查.</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Computer Science</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Pratical Python for dabeaz-Functions and Error</title>
    <url>/2025/10/21/Practical-Python-Functions/</url>
    <content><![CDATA[<p>本笔记完全基于David Beazley的Python教程-<a
href="https://dabeaz-course.github.io/practical-python/Notes/Contents.html">Practical
Python</a>.</p>
<h2 id="functions-and-script-writing">3.1 Functions and Script
Writing</h2>
<p>Python的编程风格更推荐于使用由下向上的代码编写风格.
我们将函数视作程序的构建块,从较小的,较简单的函数开始编写,后面的函数将在先前函数的基础之上继续编写.</p>
<p>在理想情况下,函数只对向函数输入的变量进行操作,避免对全局变量和未知的变量值变化带来的副作用.因此,构建函数的目的是模块化和可预测性.模块化是用来封装程序进程,从而利于程序编写和后期维护;可预测性,是为了避免函数造成一些未知的影响.</p>
<span id="more"></span>
<p>函数中的类型注释,其代码如下所示,</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">var_name:var_type</span>) -&gt; return_type:</span><br></pre></td></tr></table></figure>
<p>这些提示并不会影响函数的作用,只是起一个注释效果,并且即使实际的输入输出类型与注释的不符,IDE或者编译器可能会警告,但并不会影响程序的执行.</p>
<p><a id="org35ec0fa"></a></p>
<h2 id="more-details-on-functions">3.2 More details on functions</h2>
<p>可以在函数参数里面设置一些默认值,那么这些值就是可选参数,使用函数时可以不对其赋值,这样的话,函数会自动调用默认值,但是前提是这些可选参数必须在参数列表的末尾.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">var1,var2,var3=init1,var4=init4</span>)</span><br></pre></td></tr></table></figure>
<p>由于可选参数的存在,因此推荐参用关键字赋值的方式来传递函数参数,这样可以提高代码的清晰度和可读性.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fun(item1,item2,var3=item3)</span><br></pre></td></tr></table></figure>
<p>函数如果没有设置返回值或者return空,那么他的返回值为None.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>():</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">d=fun() <span class="comment"># None</span></span><br></pre></td></tr></table></figure>
<p>函数的返回值并不能同时分开的返回多个值,但可以通过元组的方式实现多值返回.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">divide</span>(<span class="params">a,b</span>):</span><br><span class="line">    q=a//b</span><br><span class="line">    r=a%b</span><br><span class="line">    <span class="keyword">return</span> (q,r)</span><br><span class="line">x=divide(<span class="number">11</span>,<span class="number">3</span>) <span class="comment"># (3,2)</span></span><br><span class="line">x,y=divide(<span class="number">11</span>,<span class="number">3</span>) <span class="comment"># x=3,y=2</span></span><br></pre></td></tr></table></figure>
<p>类似于C/C++的变量作用域的讨论,Python同样可以有这样的讨论;Python的外部变量是全局变量,在任意函数中都可以调用;而函数内定义的变量则是局部变量,其生存域仅在定义其的函数内部,出了函数就会被释放.函数虽然可以调用读取全局变量,但并不能在函数中随意修改全局变量的值.如果试图在函数内部修改外部的全局变量,可以用global关键字的方式来强行修改.全局声明要求其必须在使用前出现,并且相应的变量也必须和函数位于同一个文件中,因此这并不适合于多文件编程,并不推荐使用.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name=<span class="string">&#x27;David&#x27;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>():</span><br><span class="line">    <span class="keyword">global</span> name</span><br><span class="line">    name=<span class="string">&#x27;Guide&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> name</span><br><span class="line">test=fun()</span><br></pre></td></tr></table></figure>
<p>值得注意的是,与C不同的是Python函数并不是传递变量值的副本,而是传递变量引用的副本,因此对于可变类型的参数可以直接在函数内修改,至于不可变类型需要利用局部变量的方式来重新赋值修改.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">a</span>):</span><br><span class="line">    a.append(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>事实上,如果修改值和重新分配变量名称是存在一些差异的;修改值可以直接利用自带方法就地修改,而如果重新通过设置同名局部变量赋值的方式,他并不会影响外层全局变量.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bar</span>(<span class="params">items</span>):</span><br><span class="line">    items=[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">b=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">bar(b)</span><br><span class="line"><span class="built_in">print</span>(b) <span class="comment"># [1,2,3]</span></span><br></pre></td></tr></table></figure>
<p><a id="org756e1b4"></a></p>
<h2 id="error-checking">3.3 Error Checking</h2>
<p>Python不对函数参数类型或值执行类型检查或类型验证.函数将处理与函数语句兼容的数据类型.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a,b</span>):</span><br><span class="line">    <span class="keyword">return</span> a+b</span><br><span class="line">add(<span class="number">3</span>,<span class="number">4</span>) <span class="comment"># 7</span></span><br><span class="line">add(<span class="string">&#x27;Hello&#x27;</span>,<span class="string">&#x27; World&#x27;</span>) <span class="comment"># &#x27;Hello World&#x27;</span></span><br><span class="line">add(<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;4&#x27;</span>) <span class="comment"># &#x27;34&#x27;</span></span><br></pre></td></tr></table></figure>
<p>异常用于在程序发生错误的时候将错误信息发送给程序.除了程序本身运行中可能导致异常信息出现,也可以利用raise方式来手动引发异常.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">a,b</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(a,<span class="built_in">str</span>):</span><br><span class="line">        <span class="keyword">raise</span> RuntimeError(<span class="string">f&#x27;<span class="subst">&#123;a&#125;</span> is not right type&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>
<p>类似于C/C++,Python也可以通过try-except代码块来捕获程序抛出的异常,值得注意的是,异常的传播并不是从内层一直传播到外层的,而是如果出现第一个匹配的except,异常的传播就会停止,并不会继续向外传播.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    <span class="keyword">raise</span> RuntimeError(<span class="string">&#x27;Test&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bar</span>():</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        foo()</span><br><span class="line">    <span class="keyword">except</span> RuntimeError <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">spark</span>():</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        bar()</span><br><span class="line">    <span class="keyword">except</span> RuntimeError <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="comment"># 如果调用spark函数,那么他的异常其实是会被bar里面的except捕获后,终止程序</span></span><br></pre></td></tr></table></figure>
<p>我们可以发现这个except捕获异常的时候同时还赋值了变量e,其实这是捕获异常的同时,将异常实例对象赋值给了变量e,但是我们如果将e打印出来,其实和字符串的表示类似.因此我们把try-except语法块的通用形式给出,</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    statements</span><br><span class="line"><span class="keyword">except</span> Error <span class="keyword">as</span> e: <span class="comment"># 捕获异常信息</span></span><br><span class="line">    statements <span class="comment"># 处理异常信息的语句</span></span><br><span class="line">    statements <span class="comment"># 完成异常捕捉和处理后继续执行语句</span></span><br></pre></td></tr></table></figure>
<p>如果一个函数或一个语句块中可能抛出多种异常,显然我们可以不断堆叠except代码块的方式来捕获多种异常.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    statement</span><br><span class="line"><span class="keyword">except</span> LookupError <span class="keyword">as</span> e:</span><br><span class="line">    statement</span><br><span class="line"><span class="keyword">except</span> RuntimeError <span class="keyword">as</span> e:</span><br><span class="line">    statement</span><br><span class="line"><span class="keyword">except</span> IOError <span class="keyword">as</span> e:</span><br><span class="line">    statement</span><br><span class="line"><span class="keyword">except</span> KeyboardInterrupt <span class="keyword">as</span> e:</span><br><span class="line">    statement</span><br></pre></td></tr></table></figure>
<p>但是这样的话会将代码的长度毫无意义的增长,因此可以将相同处理方式的异常写成更为紧凑的形式.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    statement</span><br><span class="line"><span class="keyword">except</span> (IOError,LookupError,RuntimeError) <span class="keyword">as</span> e:</span><br><span class="line">    statement</span><br></pre></td></tr></table></figure>
<p>这里利用e来存储抛出的异常实例,如果不用e来存储相应异常实例,容易导致虽然出现异常,但并不能显示得出异常的原因.而且这样的异常元组的方式只能应用于对异常的相同处理,如果对不同的异常有不同的处理方式,则不可以使用这类方法.</p>
<p>如果并不确定程序运行中会出现什么类型的异常,是可以通过使用Exception的方式来捕获全部的异常,但这并不适合于程序中大规模使用,因为他虽然能够捕捉所有的异常但并不知道错误原因,因此不利于程序的后期修改.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    statement</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e: <span class="comment"># 虽然他可以捕捉所有的异常信息,但通过赋值e使得异常信息被存储下来,从而有利于后期检查</span></span><br></pre></td></tr></table></figure>
<p>但对于异常捕捉建议遵从以窄捕捉为主,只捕捉自己能够处理的,对于不能处理让外层处理或尝试避免.</p>
<p>由于异常只会被第一次匹配的except捕捉,而不会继续向外传播,我们可以通过raise函数继续引发异常,让外层except继续捕捉异常.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bar</span>():</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        foo()</span><br><span class="line">    <span class="keyword">except</span> RuntimeError <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">raise</span></span><br></pre></td></tr></table></figure>
<p>这里raise后并没有接参数,实际上就是直接将已经实例化的变量e向外层抛出,继续由外层except捕捉.</p>
<p>对于某些重要资源管理(如文件,线程池,CPU资源占用等可能出现死锁现象的资源),即使抛出异常需要仍然利用某些关闭措施,来结束资源占用.故而finally代码块会要求程序无论是否出现异常,无论异常的类型都需要在最后一步执行.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    fun()</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    ending statement <span class="comment"># 释放系统内部空间</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Computer Science</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Pratical Python for dabeaz-Modules</title>
    <url>/2025/12/12/Practical-Python-Modules/</url>
    <content><![CDATA[<p>本笔记完全基于David Beazley的Python教程-<a
href="https://dabeaz-course.github.io/practical-python/Notes/Contents.html">Practical
Python</a>.</p>
<h2 id="modules">3.4 Modules</h2>
<p>模块可以认为是命名值的集合,换言之,模块其实和C++中的命名空间十分类似.模块中包含模块文件中定义的全局变量和定义的函数.当我们导入模块之后,如果需要调用模块中的命名值,只需要将模块名作为前缀调用即可.
在不同的模块中,是允许存在有相同名称的全局变量或函数的,对其调用如下所示</p>
<span id="more"></span>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># foo.py</span></span><br><span class="line">x=<span class="number">1</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="comment"># bar.py</span></span><br><span class="line">x=<span class="number">1</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bar</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="comment"># main.py</span></span><br><span class="line"><span class="keyword">import</span> foo</span><br><span class="line"><span class="keyword">import</span> bar</span><br><span class="line"><span class="built_in">print</span>(foo.x)</span><br><span class="line"><span class="built_in">print</span>(bar.x)</span><br></pre></td></tr></table></figure>
<p>因此,从上面的示例代码中,我们可以发现模块其实是互相独立的,所以模块其实可以做一些代码的命名上的隔离.但是上面我们导入模块的方式是利用import,如果我们采用下面的方式导入x,那他的隔离特性就会被我们破坏:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> foo <span class="keyword">import</span> x</span><br><span class="line"><span class="keyword">from</span> bar <span class="keyword">import</span> x</span><br></pre></td></tr></table></figure>
<p>如果是这样的话,x只会是bar模块中的值,并不会出现前面的隔离情况.</p>
<p>在程序导入模块的时候,模块的源文件会被完整执行到文件末尾.因此,如果源文件中存在某些全局范围下可执行的语句,在导入模块的同时这些语句会被执行.模块的命名空间中存储的是模块源文件中定义的全局变量以及函数文件.但是这里我们需要明确的一点是,这里存储的全局变量指的是在文件末尾的依然存在的全局变量,对于代码中间释放的全局变量则不会存储.</p>
<p>导入模块的方式如下所示</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> modules <span class="comment"># 导入模块</span></span><br><span class="line"><span class="keyword">import</span> modules <span class="keyword">as</span> nickname <span class="comment"># 导入模块并重命名</span></span><br><span class="line"><span class="keyword">from</span> modules <span class="keyword">import</span> func <span class="comment"># 导入模块中的特定函数</span></span><br></pre></td></tr></table></figure>
<p>这里有一些注意的点:模块只会在程序中导入一次,重复import相同的模块并不会重复执行模块的源代码,重复导入只会返回对之前加载模块的引用.因此,在jupyter或交互模式中,如果我们先导入了模块,再修改模块的代码,程序并不会做重复导入,我们需要重启解释器内核.</p>
<p>Python中用sys.module来存储已经加载模块的字典,sys.path则是用来存储Python查找模块时的参考路径列表,值得注意的是当前工作目录总是最优先的.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="built_in">print</span>(sys.modules.keys()) <span class="comment"># 存储已经加载模块的键值</span></span><br><span class="line"><span class="built_in">print</span>(sys.path) <span class="comment"># 存储Python查找模块时的参考路径列表</span></span><br></pre></td></tr></table></figure>
<p>这里的查找参考路径可能没有包含希望的模块,因为sys.path是一个列表,所以我们可以用append的方式把期待的路径添加进去.当然也可以通过环境变量的方式添加到搜索路径.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path.append(<span class="string">&#x27;/project/foo/pyfiles&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>但一般来说并不推荐自己手动修改搜索路径,除非某些异常需要手动导入路径.</p>
<p><a id="org741ec56"></a></p>
<h2 id="main-module">3.5 Main Module</h2>
<p>Python和C/C++不同,他没有主函数或方法;但是Python具有主模块,主模块则是第一个运行的源文件.因此可以认为提供给Python解释器的文件就是主模块,在这个主模块文件调用的其他的模块则不是main模块.这里为了验证文件的调用形式,可以__name__来判断:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    statements</span><br></pre></td></tr></table></figure>
<p>上面的代码表示如果文件以主模块文件的形式那他可以运行if条件的语句.如果不是以主模块文件的形式运行,那他的__name__变量为模块名.</p>
<p>任意的源文件都可以以主模块或者库模块的形式运行或导入调用.模块的常用结构如下所示:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> module</span><br><span class="line">variable</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    statements</span><br></pre></td></tr></table></figure>
<p>python不止可以利用IDE运行,也可以用命令行中调用解释器,所以和C/C++一样,python可以使用命令行参数,如下所示</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python source.py</span><br><span class="line">python source.py data1.csv</span><br></pre></td></tr></table></figure>
<p>python的命令行参数会以文本字符串的形式存储在sys.argv中.并且sys.argv的长度至少为1,因为他的第一个元素是希望运行的python源文件名.其余的参数会存储在sys.argv[i]中,其中i大于等于1.</p>
<p>和C一样的,python的sys模块中也存储着输入输出和错误文件的变量,如下所示</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.stdout <span class="comment"># print输出的文件位置</span></span><br><span class="line">sys.stderr <span class="comment"># 错误和traceback输出的文件位置</span></span><br><span class="line">sys.stdin <span class="comment"># 输入文件的位置</span></span><br></pre></td></tr></table></figure>
<p>同样,标准输入输出也可以通过重定向的方式来重新把输入输出的位置移动到期待的位置.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python prog.py &gt; text.txt</span><br><span class="line">cmd1|prog.py|cmd2</span><br></pre></td></tr></table></figure>
<p>第一个语句会把prog.py的输出重新输出到text.txt上;第二个语句则是cmd1的输出会作为prog.py的输入,而prog.py的输出则会导出给cmd2.这里我们用prog.py直接可以运行,并没有调用解释器.这是因为我们在python文件的开头调用了#!命令,如下所示,</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">! /usr/bin/env python3</span></span><br></pre></td></tr></table></figure>
<p>系统在读取到这一行指令的时候,会自动搜索用户环境变量中的python3解释器并调用.需要注意的是这个命令在Unix环境下生效,在Windows下效果并不是很好.而且这里如果希望可以让python源文件自动执行,在执行之前需要用chmod命令给他赋予可执行权限</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod +x source.py</span><br></pre></td></tr></table></figure>
<p>对于命令行编译python文件,我们还可以手动修改命令行的环境变量.但这个并不是python的语法,而是shell语法.但对于某些需要移植的程序而言,是十分重要的,因此我们在此对他加以介绍.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">setenv variable value</span><br><span class="line">setenv PATH /usr/local/bin:$PATH</span><br></pre></td></tr></table></figure>
<p>第一条式子是设置环境变量的通用式,他只对当前shell进程和子进程生效,如果关闭了当前的shell进程,那么这些环境变量就会恢复默认值.第二个则是一个例子,我们发现他赋的值是并不是一个单独的值,而是在已有的PATH前面加上了一个环境,这里的:是用来分隔环境目录的,我们比较常用的就是在PATH前面加上一个值,如果把:放在$PATH后面那就是在已有的PATH后面加上一个环境.但这里我们不推荐使用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">setenv PATH /usr/local/bin</span><br></pre></td></tr></table></figure>
<p>这个语句会使得在这个shell里的环境变量被完全覆盖可能会有一些意想不到的错误.python中提供了一个字典来存储环境变量,如下所示</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.environ <span class="comment"># 字典</span></span><br></pre></td></tr></table></figure>
<p>Python的程序退出除了正常运行完成,就是通过异常抛出的方式.给出如下的异常抛出方式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">raise</span> SystemExit</span><br><span class="line"><span class="keyword">raise</span> SystemExit(exitcode)</span><br><span class="line"><span class="keyword">raise</span> SystemExit(<span class="string">&#x27;Information statements&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>这里的exitcode只有零值的时候表示程序正常执行,对于非零值,都表示程序运行出错.除了通过raise抛出异常,还可以选择使用python的sys模块的exit方法实现.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.exit(code)</span><br></pre></td></tr></table></figure>
<p><a id="org1832b0f"></a></p>
<h2 id="design-discussion">3.6 Design Discussion</h2>
<p>本节有个比较有趣的程序的类型推断风格:鸭子类型.他一般用于动态语言或某些静态语言(Golang).静态语言的特点是在程序执行之前,代码编译时就可以知道所有变量的类型和方法返回值类型等.因为静态语言声明变量需要附带类型信息,
其是一块内存区域,</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">10</span>;</span><br><span class="line">    x=<span class="string">&quot;ss&quot;</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>例如上面这个代码在代码编译阶段就会报错.静态语言的优点是代码结构非常规范,便于调试,但有时候会显得很罗嗦.</p>
<p>动态语言则是只有程序运行到这一行,程序才知道变量的类型.变量不需要在一开始声明变量的类型,本身也不会携带类型信息,他只与赋值的对象有关.其优点在于方便阅读,不需要写很多类型相关的代码,但其缺点在不方便调试,如果命名不规范容易出现阅读困难,不利于理解.
而鸭子类型指的是如果一个动物走起路来像鸭子,叫声也像鸭子,那么他就是鸭子.这样说来可能很抽象,其实鸭子类型就是动态类型语言的一种设计风格.一个对象的特征不是由父类决定,而是通过对象的方法决定.也就是我们并不关心对象的类型是什么样子的,我们只关心他的方法行为是什么结果.例如如下的代码,</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">max</span>(<span class="params">a,b</span>):</span><br><span class="line">    <span class="keyword">if</span> a&gt;b:</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> b</span><br><span class="line"><span class="built_in">max</span>(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="built_in">max</span>(<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>上面的代码他都可以正确的比较整型和字符类型,对于这个函数而言,我们不关心输入的类型是什么,我们只关心是否能够运行,结果是否正确.</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Computer Science</tag>
        <tag>Python</tag>
      </tags>
  </entry>
</search>
