<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Lecture series on graph theory 1</title>
    <url>/2022/03/28/Graph1/</url>
    <content><![CDATA[<p>Def.  A graph is a <font color=red>discrete structure/combinational structure</font> consisting of vertices and edges which connect to a pair of vertices.</p>
<p>Usually, a vertex is represented by a dot and an edge is represented by a line (straight or curved)  joining two vertices.</p>
<span id="more"></span>
<p><img src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220226/2022-02-26_212559.jpg" alt=""></p>
<center><font color=red size=4>The green points mean crossing of the edges,rather than vertices  </font></center>

<p>A vertex is incident with an edge if the edge join the vertex to another vertex, which is also called the end of the edge.</p>
<p>Two vertices are adjacent to each other if there is an edge joinging them.</p>
<p><img src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220226/2022-02-26_214218.jpg" alt=""></p>
<center><font color=red size=4>We say that the vertex v is incident with the edge e<br>The vertex u is adjacent to the vertex v because uv is an edge of G</font></center>

<p>A graph is simple if there is at most one edge between any two vertices and there is no edge joining a vertex itself.</p>
<p><img src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220226/2022-03-28_185112.jpg" alt=""></p>
<p>In short, a graph is simple if and only if it has no multi-edges and no loops.Next, unless otherwise specified, we will discuss simple graphs by default.</p>
<p>For any given simple graph $G(V,E)$，V is the vertex set and E is the edge set.</p>
<script type="math/tex; mode=display">
if\ \lvert V\rvert=n,\lvert E\rvert\leq\binom{n}{2}</script><p>A graph is complete if the graph has an edge between every pair of vertices.A complete graph of n vertices is usually denoted by $K_n$</p>
<p><img src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220226/2022-03-28_185902.jpg" alt=""></p>
<p>The degree of a vertex v of G, denoted by $d_G(v)$, is the number of edges incident with it.</p>
<p>The maximum degree of G is defined as $\Delta(G):=\max{d_G(x)|v\in V(G)}$</p>
<p>The minimum degree of G is defined as $\delta G:=\min{d_G(v)|v\in V(G)}$</p>
<p>The average degree of G is defined as $d(G):=\frac{\lvert E(G)\rvert}{\lvert V(G)\rvert}$, this index is used to measure the density of the graph.According to this index, graph can be divided into dense graph and sparse graph</p>
<p>A neighbor of v in G is a vertex joined to v by an edge of G.The neighborhood of a vertex v in G is the set of all neighbors of v in G, denoted by $N_G(v)={u|u\in V(G),uv\in E(G)}$.We have $d_G(v)=\lvert N_G(v)\rvert$ easily.</p>
<p><img src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220226/2022-03-28_185933.jpg" alt=""></p>
<font color=red>This picture shows the multi-level neighbors of v. If u is both a second-level neighbor and a third-level neighbor of v, it is classified as a second-level neighbor. <br>Here we give the set representation of neighbors: <br>$N_1(v)=N_G(v),N_2(v)=N_G(N_1(v))-N_1(v)\cup\{v\},\ N_3(v)=N_G(N_2(v))-N_1(v)$<br>and if $w\in N_3(v),\ distance(w,v)=3$</font>

<p>A graph is even if every vertex of G has an even degree.</p>
<p><img src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220226/2022-03-28_185942.jpg" style="zoom:50%;" /></p>
<p><strong>Proposition(Handshaking Lemma)<br>Every graph has an even number of vertices with odd degree.</strong></p>
<p>Proof. </p>
<p>Let </p>
<script type="math/tex; mode=display">
\left\{\begin{aligned}X&=\{x|x\in V(G)\ and\
 d_G(x)\equiv0(mod\ 2)\}\\Y&=\{y|y\in V(G)\ and\
 d_G(y)\equiv1(mod\ 2)\}\end{aligned}\right.</script><p>Then,$\sum<em>{x\in X}d_G(x)+\sum</em>{y\in Y}d_G(y)=2\lvert E(G)\rvert$</p>
<p>So, $\sum_{y\in Y}d_G(y)\equiv0(mod\ 2)$.It follows immediately that $\lvert Y\rvert\equiv0(mod\ 2)$</p>
<p>So the proposition holds. </p>
<p>Question:Let G be an n-vertex graph.How many edges will force G to have a triangle?(Mantel’s Theorem)</p>
<p>Def A walk of G is  <font color=red>a sequence of vertices and edges of G</font>such that (i)both the first element and  the last element of the sequence are vertices and (ii) any two consecutive elements in the sequence contains one vertex and one edge which are incident with each other.</p>
<p><img src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220226/2022-03-28_200038.jpg" alt=""></p>
<font color=red>We give two different walks: $w_{1}=v_1e_1v_2e_2v_3e_2v_2e_1v_1,\  w_2=v_2e_2v_3e_3v_4e_4v_2$<br>For walk,vertex can be repeated, edge can be repeated.</font>

<p>A walk is open if the first vertex is not equal to the last vertex. <font color=red>$w_0=v_2e_2v_3e_3v_4e_4v_2e_1v_1$</font></p>
<p>A walk is a trail if it does not have repeated edges. <font color=red>$w_0$ is a trail</font></p>
<p>A trail is a path if it does not have repeated vertices. </p>
<font color=red>$w_3=v_1e_1v_2e_2v_3e_3v_4=v_1v_2v_3v_4$ is a path</font>

<p>A cycle is a closed trail( or path) without repeated vertices (vertices and edges) <font color =red>except the first vertex and the last vertex. $w_4=v_2e_2v_3e_3v_4e_4v_2$</font> </p>
<p>A graph is connected if for any two vertices x and y, there is a path joining x and y.</p>
<p><img src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220226/2022-03-28_200053.75zqcj50zpw0.jpg" alt=""></p>
<p>A subgraph H of G is a graph with $V(H)\subset V(G),E(H)\subset E(G)$</p>
<p>A maximal connected subgraph of G is called a connected component. <font color=red>Maximal means anything bigger than it is not connected</font></p>
<p>An edge e of G is bridge or cut-edge if #connected components of G-e&gt;#connected components of G</p>
<p><img src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220226/2022-03-28_200107.7d9xw8946f80.jpg" style="zoom:67%;" /></p>
<font color=red>#connected components of G-$e_1$=3>2=#connected components of G<br>Both $e_1$ and$e_2$ are bridges/cut-edges</font>

<p><strong>Thm(BJJ,Fan)<br>Every graph without bridges has a family of cycles which covers every edge exactly 2k times for any integer $k\ge2$</strong></p>
<p>A subgraph H is spanning if $V(H)=V(G)$</p>
<p>A subgraph H is induced by <font color=red> $S\subset V(G)$</font>, if $V(H)=S$ and for any two vertices $x,y\in S$, $xy\in E(H)\Leftrightarrow xy\in E(G)$</p>
<p>A subgraph H is induced by <font color=red> $S\subset E(G)$</font>, if $E(H)=S$ and $v\in V(H)$a if and only if v is incident with an edge in S.</p>
<p><img src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220226/2022-03-28_213047.4nctxwr5lzc0.jpg" alt=""></p>
<p>Let $x,y\in V(G)$, the distance between x and y in G is the length of the shortest path joining x and y, denoted by $dist_G(x,y)$. In other words,</p>
<script type="math/tex; mode=display">
dist_G(x,y)=\min\{\lvert E(P)\rvert\big|P\ is\ a\ path\ joining\ x\ and\ y\}</script><p><img src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220226/2022-03-28_215149.3o033gismx60.jpg" style="zoom:67%;" /></p>
<font color=red>$dist_G(x,y)=k$, this means finding a shortest path between any two vertices x and y is easy</font>

<font color=red>However, finding a longest path between any two vertices x and y.Given an integer k, is there an (x,y)-path with length k?They are NPC problems</font>
]]></content>
      <categories>
        <category>Graph Theory</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Operation Research</tag>
      </tags>
  </entry>
  <entry>
    <title>Lecture series on graph theory 4</title>
    <url>/2022/05/22/Graph4/</url>
    <content><![CDATA[<p><strong>Proposition. The adjacency matrix of a graph is a real symmetric matrix.</strong></p>
<span id="more"></span>
<p><img src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220226/2022-05-22_131847.16yosr9l8xs0.jpg" alt=""></p>
<font color='red'>Here we broefly discuss the topic of random matrices.<br>Probability of adjacent connection between $R_j$ and $C_j$, $P(R_j\sim C_j)=\frac{1}{2}$, $\ P(R_j\not\sim C_j)=\frac{1}{2}$</font>
$$
P(A(G)\ is \ invertible)=P(M\ is\ invertible)
$$
**Thm Let G be a graph. The number of walks from $v_i$ to $v_j$ of length k is equal to the $(i,j)$-entry of $(A(G))^k$**

---

**Proof**

Let $A(G)=(a_{ij})_{n\times n}$. Then $(i,j)$-entry of $(A(G))^k$ is given by 
$$
[(A(G))^k]_{ij}=\sum a_{ii_1}a_{i_1i_2}\cdots a_{i_{k-1}j}
$$
where the sum ranges over all sequences $(i_1,i_2,\dots,i_{k-1})$ with $i_t\in[n]=\{1,2,\dots,n\}$
$$
\begin{aligned}
(A(G))^2_{ij}&=(A(G)\cdot A(G))_{ij}=\sum_{i_1=1}^na_{ii_1}a_{i_1j}\\
(A(G))^3_{ij}&=((A(G))^2\cdot A(G))_{ij}=\sum_{i_2=1}^n(\sum_{i_1=1}^na_{ii_1}a_{i_1i_2})a_{i_2j}=\sum_{i_1,i_2=1}^{n}a_{ii_1}a_{i_1i_2}a_{i_2j}\\
\end{aligned}
$$
By the definition of adjacency matrix, $a_j=1\Leftrightarrow v_iv_j\in E(G)$

It follows that the summand $a_{ii_1}a_{i_1i_2}\cdots a_{i_{k-1}j}$ is 1 $\Leftrightarrow\ v_iv_{i_1}v_{i_2}\cdots v_{i_{k-1}}v_j$ is a walk of length k. Hence the summing over all $(i_1,\cdots,i_{k-1})$ just gives the total number of walks of length k from $v_i$ to $v_j$

---

A(G) is $n\times n$ symmetric matrix. All n eigenvalues of A(G) are real. Assume the n eigenvalues satisfy 
$$
\lambda_1\geq\lambda_2\geq\cdots\geq\lambda_n
$$
<font color='red'>Note that $\lambda_1+\lambda_2+\cdots+\lambda_n=0$,some eigenvalues could be negative.<br>If G is a bipartite graph, the eigenvalues are symmetric about origin.</font>

<p><strong>Thm Let G be a graph with eigenvalues $\lambda_1,\cdots,\lambda_n$. Then the number of closed walks in G of length k is given by</strong></p>
<script type="math/tex; mode=display">
w_G(k)=\lambda_1^k+\cdots+\lambda_n^k</script><hr>
<p><strong>Proof</strong></p>
<p>Let G be a graph with adjacency matrix A(G). Then it follows from the above theorem that</p>
<script type="math/tex; mode=display">
w_G(k)=\sum_{i=1}^n[(A(G))^k]_{ii}=tr(A(G)^k)</script><p>Since A(G) has $\lambda_i$ as an eigenvalue with $i\in{1,2,\cdots,n}$, the matrix $A(G)^k$ has eigenvalue $\lambda_i^k$for $i\in{1,2,\cdots,n}$</p>
<font color='red'>$A(G)\vec{v_i}=\lambda_i\vec{v_i},\quad A(G)^k\vec{v_i}=A(G)^{k-1}A(G)\vec{v_i}=A(G)^{k-1}\lambda\vec{v_i}=\lambda_i^k\vec{v_i}$</font>

<p>Then, $tr(A(G)^k)=\sum<em>{i=1}^n\lambda_i^k$, so $w_G(k)=tr(A(G)^k)=\sum</em>{i=1}^n\lambda_i^k$</p>
<hr>
<p><strong>Incidence matrix and Laplacian matrix</strong></p>
<p>Let G be a graph s.t. $V(G)={v_1,v_2,\cdots,v_n}$ and $E(G)={e_1,e_2,\cdots,e_m}$</p>
<script type="math/tex; mode=display">
B(G)=(b_{ij})_{n\times m}\ where\ b_{ij}=\left\{\begin{aligned}&1\quad v_i\ is\ incident\ with\ e_j\\
&0\quad v_i\ isn't\ incident\ with\ e_j\end{aligned}\right.</script><p><img src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220226/2022-05-22_162156.x0o95v76evk.jpg" alt=""></p>
<font color='red'>We can find that evey column has two non-zero entries.</font>

<p><img src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220226/2022-05-22_162610.6c5zcmwtfbc0.jpg" alt=""></p>
<font color='red'>We can find that each column of $\vec{B}$ has one entry of 1, one entry of -1 and other entry of 0.Therefore, add all entries in column and get 0</font>

<p><img src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220226/2022-05-22_163017.jpg" alt=""></p>
<p>$D(G)$ is a diagonal matrix whose diagonal entries are the degrees of vertices.</p>
<p>Laplacian matrix of G: $L(G)= D(G)-A(G)=\vec{B}\cdot\vec{B}^T$</p>
<p><strong>Proposition. Let G be a graph. Then L(G) is positive semi-definite and consequently, all eigenvalues of L(G) are real and non-negative.</strong></p>
<script type="math/tex; mode=display">
\beta_1\geq\beta_2\geq\cdots\geq\beta_n\geq0</script><p>$\tau(G)$= the total number of spanning trees in G.</p>
<p><strong>Thm(Matrix Tree Theorem) Let G be a graph with vertices $v_1,\dots,v_n$. Then $\tau(G)=det(L_0(G))$ where $L_0(G)$ is obtained from $L(G)$ by deleting the i-th row and i-th column for any $i\in[n]={1,2,\dots,n}$</strong></p>
<hr>
<p><strong>Proof.</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220226/2022-05-22_174049.4vsowf7szwq0.jpg" alt=""></p>
<p>If T is a spanning tree, either $e\in T$ or $e\not\in T$.</p>
<p>An edge e of G is said to be contracted if it is deleted and its ends are identified, the resulting graph is denoted by $G\cdot e$.</p>
<p><img src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220226/2022-05-22_174508.6er13gzch2o0.jpg" alt=""></p>
<p>If $e\not\in T$, T is a spanning tree of G-e; if $e\in T$, $T\cdot e$ is a spanning tree of $G\cdot e$.</p>
<p>Therefore, $\tau(G)=\tau(G-e)+\tau(G\cdot e)$</p>
<p>Use induction on the number of edges of G.</p>
<p>If G has no edges and n=1, so $\tau(G)=1=det(L_0(G))$ where $L_0(G)$ is a $0\times 0$ matrix with determinant 1 by convenience.</p>
<p>If $n&gt;1$, then $\tau(G)=0$, and $L_0(G)$ is a 0-matrix in which every entry is 0. So $\tau(G)=det(L_0(G))$ .</p>
<p>Therefore, the statement holds for $|E(G)|=0$.</p>
<p>Assume the statement holds all graph with number of edges less than $|E(G)|$.</p>
<p>By recordering the vertices of G, we may assume that $i=1$ and $v_1v_2\in E(G)$, Let $e=v_1v_2$. Then  $\tau(G)=\tau(G-e)+\tau(G\cdot e)$.</p>
<p>By inductive hypothesis, $\tau(G-e)=det(L_0(G-e))$ and $\tau(G\cdot e)=det(L_0(G\cdot e))$.</p>
<p>Assume $L_0(G)=\begin{pmatrix}d_2&amp;P\P^T&amp;R\end{pmatrix}$ obtained from $L(G)=\left(\begin{array}{c:c:c}d_1&amp;1&amp;\cdots\\hdashline1&amp;d_2&amp;P\\hdashline\vdots&amp;P^T&amp;R\end{array}\right)$ by deleting the first row and the first column.</p>
<p>Then $L_0(G-e)=\begin{pmatrix}d_2-1&amp;P\P^T&amp;R\end{pmatrix}$ and $L_0(G\cdot e)=R$</p>
<p>Note that $L_0(G)=L_0(G-e)+\begin{pmatrix}1&amp;\vec{0}\\vec{0}^T&amp;R\end{pmatrix}$</p>
<p>Using the Laplace expansion along the first row,</p>
<script type="math/tex; mode=display">
det(L_0(G))=det(L_0(G-e))+det(L_0(G\cdot e))=\tau(G-e)+\tau(G\cdot e)=\tau(G)</script><hr>
<p><strong>Thm Let G be a connected graph with n vertices. Suppose that the eigenvalues of L(G) are $\mu<em>1\geq\mu_2\geq\cdots\geq\mu</em>{n-1}\geq\mu_n=0$. Then</strong></p>
<script type="math/tex; mode=display">
\tau(G)=\frac{1}{n}\mu_1\mu_2\cdots\mu_{n-1}</script><hr>
<p><strong>Proof</strong></p>
<p>Let $L(G)$ be the  Laplacian matrix and let </p>
<script type="math/tex; mode=display">
det(L(G)-\lambda I)=(\mu_1-\lambda)(\mu_2-\lambda)\cdots(\mu_n-\lambda)=-\lambda(\mu_1-\lambda)(\mu_2-\lambda)\cdots(\mu_{n-1}-\lambda)</script><p>So the cofficient of $\lambda$ term is $-\mu<em>1\mu_2\cdots\mu</em>{n-1}$. Note that, consider $L(G)-\lambda I$.</p>
<p>Add all rows of $L(G)-\lambda I$ except the first row to the first row, and let $M(\lambda)$ be the new resulting matrix.</p>
<p>Then $det(M(\lambda))=det(L(G)-\lambda I)$ and the first row of $M(\lambda)=[-\lambda,-\lambda,\cdots,-\lambda]$.</p>
<p>Let $N(\lambda)$ be the resulting matrix obtained from $M(\lambda)$ by factoring out $-\lambda$.</p>
<p>Then $M(\lambda)=-\lambda N(\lambda)$ and $det(M(\lambda))=-\lambda det(N(\lambda))$, So </p>
<script type="math/tex; mode=display">
det(L(G)-\lambda I)=-\lambda det(N(\lambda))</script><p>Therefore, the cofficient of $\lambda$ term in $det(L(G)-\lambda I)$is equal to $-det(N(0))$.</p>
<p>Add all columns of $N(0)$ except the first column to the first column.</p>
<font color='red'>(Note that $i^{th}$-row $(i>1)$ of $N(0)$ is the same as the  $i^{th}$-row $(i>1)$ of $L(G)$</font>

<p>Then the first column of the new matrix is $\left[\begin{matrix}n&amp;0&amp;0&amp;\cdots&amp;0\end{matrix}\right]^T$.</p>
<p>Use Laplace expansion along the $1^{st}$ column, $det(N(0))=n\cdot det(L_0(G))$</p>
<script type="math/tex; mode=display">
n\cdot det(L_0(G))=(-1)\cdot(-\mu_1\mu_2\cdots\mu_{n-1})\Rightarrow det(L_0(G))=\frac{1}{n}\mu_1\mu_2\cdots\mu_{n-1}</script><p>By previous theorem,</p>
<script type="math/tex; mode=display">
\tau(G)=\frac{1}{n}\mu_1\mu_2\cdots\mu_{n-1}</script><hr>
]]></content>
      <categories>
        <category>Graph Theory</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Operation Research</tag>
      </tags>
  </entry>
  <entry>
    <title>Lecture series on graph theory 3</title>
    <url>/2022/05/20/Graph3/</url>
    <content><![CDATA[<p>Given a graph G, $T={v|d_G(v)\equiv1\ mod\ 2}$, a subgraph P is called a parity subgraph if </p>
<script type="math/tex; mode=display">
d_P(v)\equiv\left\{
\begin{aligned}
&0\ mod\ 2,\ v\not\in T\\
&1\ mod\ 2,\ v\in T
\end{aligned}
\right.\qquad i.e.\ d_P(v)\equiv d_G(v)</script><p>$G-E(P)$ is an even subgraph <font color='red'>( i.e. every vertex of G-E(P) has even degree)<br>Problem: To find a parity subgraph with the minimum number of edges.</font></p>
<span id="more"></span>
<p>More general, let $T\subset V(G)$, a set of edges $J$ is called a $T$-join if all the edges of $J$ induce a subgraph, s.t. $d_J(v)\equiv1\ mod\ 2\Leftrightarrow v\in T$, <font color='red'>A parity subgraph of G is a $T$-join of G where $T={v|d_G(v)\equiv1\ mod\ 2}$<br>Problem: To find a $T$-join with the minimum number of edges.</font></p>
<p><strong>Bipartite Graph</strong></p>
<p>A graph is bipartite if its vertex set can be partitioned into two sets X and Y such that every edge of G joins a vertex of X and a vertex of Y.</p>
<font color='red'>For example.</font>

<p><img src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220226/2022-05-22_185717.5b3liqdtj4g0.jpg" alt="2022-05-21_121856"></p>
<p><strong>Proposition. A graph is bipartite $\Leftrightarrow$ it has no odd cycles</strong></p>
<hr>
<p><strong>Proof</strong></p>
<p>$\Rightarrow$ Let $G$ be a bipartite graph and let $(X,Y)$ be a bipartition of $G$. Color vertices in X by            red and vertices in Y by blue. Let $C$ be a cycle. Then the red vertices and blue vertices appear alternatively on $C$. So $C$ has an even number of vertices. Therefore, $G$ has no odd cycles.</p>
<p>$\Leftarrow$ Let v be a vertex of $G$. Let $X={x|d_G(x,v)\equiv0(mod\ 2)}$ and $Y={y|d_G(y,v)\equiv 1(mod\ 2)}$</p>
<p>Since $G$ has no odd cycle, there is no edges joining two vertices from the same part. So G is bipartite. </p>
<hr>
<font color='red'>Every part in the bipartition induce the graph without edges.</font>

<p>A vertex subset $I$ of $V(G)$ is independent  if $G$ has no edges joining any two vertices of $I$.</p>
<p>The maximum cardinality of independent sets is called the independent number of $G$.</p>
<font color='red'>Problem: Determine the independent number of a given graph $G$ (NPC)</font>

<p>If G is bipartite, the its independent number $\alpha(G)\geq\frac{n}{2}$.</p>
<font color='red'>**(The Four color problem) Every graph drawn on the plane without crossing edges has a vertex partition into four independent sets.<br>According to the above, if G is a plane graph, $\alpha(G)\geq\frac{\lvert V(G)\rvert}{4}$**</font>

<hr>
<p><strong>Second Proof of the Mantel’s Theorem</strong></p>
<font color='red'>Recall: Let G be an n-vertex graph without triangle, then $\lvert E(G)\rvert\leq\frac{n^2}{4}$</font>

<p>Let x be a vertex of G such that $d_G(x)=\Delta(G)$. So $N_G(x)$ is an independent set of G.</p>
<script type="math/tex; mode=display">
\lvert E(G)\rvert\leq\sum_{y\not\in N_G(x)}d_G(y)\leq(n-d_G(x))\Delta (G)=(n-d_G(x))d_G(x)\leq\frac{n^2}{4}</script><p> and equality holds $\Leftrightarrow n-d_G(x)=d_G(x),\ i.e.\ d_G(x)=\frac{n}{2}$</p>
<hr>
<p><strong>Degenerated Graph</strong></p>
<p>A graph G is k-degenerate if every subgraph of G has a vertex of degree at most k. <font color='red'>A tree is 1-degenerate</font></p>
<p>A graph G is k-colorable if the vertex of G can be colored by k different colors such that any vertex subset with same color is an independent set. i.e. the vertex set of G can be partitioned into k independent subsets.</p>
<p><strong>Proposition: A k-degenerated graph is (k+1)-colorable</strong></p>
<hr>
<p><strong>Proof.</strong> Let G be k-degenerate graph. Then G has a vertex v of degree at most k. </p>
<p>Use induction on the number of vertex.</p>
<p> The inductive hypothesis implies that $G-v$ is (k+1)-colorable. All vertices in $N_G(x)$ have been colored by at most k different colors in any (k+1)-coloring of G-v. Then color v by the (k+1)th color. So G is (k+1)-colorable.</p>
<hr>
<font color='red'>1-factor is a spanning subgraph in which every vertex has degree one.</font>

<font color='red'>1-degenerate graph is a tree(or a forest)</font>

<p><img src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220226/2022-05-21_190614.g013sfif35c.jpg" alt="2022-05-21_190614"></p>
<p><strong>Corollary. Every graph G is $(\Delta(G)+1)$-degenerate</strong></p>
<p><strong>Def. A Planar graph is a graph with a drawing on the plane $\mathbb{R}^2$</strong> . A connected region of $\mathbb{R}^2-G$ is a face of G.</p>
<p><img src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220226/2022-05-21_191223.3jzn0lp4vyg0.jpg" alt="2022-05-21_191223"></p>
<p><strong>Thm(Euler Formula) Let G be a planar graph, and let n,m and f be the numbers of vertex,edges and faces of G, Then </strong></p>
<script type="math/tex; mode=display">
n-m+f=2</script><p><strong>Proposition. Every planar graph is 5-degenerate</strong></p>
<hr>
<p><strong>Proof.</strong> Let G be a planar graph. It suffices to show that G has a vertex of degree at most five. Without loss of generality, assume that G is a maximal planar graph (<font color='red'>i.e. every face is bounded by a triangle</font>). Otherwise, we can add edges to G to keep it to be a planar graph.</p>
<p>Since every edge appears on the boundaries of two faces and every face contains exactly three edges, it follows that </p>
<script type="math/tex; mode=display">
3f=2m\Rightarrow f=\frac{2}{3}m</script><p>Let $\delta=\delta(G)$, the minimum degree of G, then </p>
<script type="math/tex; mode=display">
\delta n\leq\sum_{x\in V(G)}d_G(x)=2m\Rightarrow n\leq\frac{2}{\delta}m</script><p>By Euler’s Formula: $n-m+f=2$</p>
<script type="math/tex; mode=display">
2=n-m+\frac{2}{3}m\leq(\frac{2}{\delta}-\frac{1}{3})m</script><p>Therefore, $\frac{2}{\delta}-\frac{1}{3}&gt;0\Rightarrow \delta&lt;6\Leftrightarrow \delta\leq5$</p>
<p>Every planar graph has a vertex of degree at most 5, which implies a planar graph is 5-degenerate.</p>
<hr>
<p><strong>Corollary. Every planar graph is 6-colorable.</strong></p>
<font color='red'>Actually we can use Kempe chain to prove the proposition that every planar graph is 5-colorable.<br>Problem:What kind of Eulerian graphs having an even-cycle decomposition?<br>Conjecture(Akiyama,1980s) Every planar graph with n vertices has an induced 2-degenerate graph with at least n/2 vertices.<br>Conjecture(Albertson&Berman,1970s) Every planar graph with n vertices has an induced 1-degenerate graph with at least n/2 vertices.</font>

<p><strong>Matrices and Graphs</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220226/2022-05-21_235307.fn17ct60tvc.jpg" alt=""></p>
<font color='red'>A is a symmetric matrix and because we only consider simple graphs, its diagonal elements are all zero.</font>

<p><img src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220226/2022-05-21_235516.2htdkwuxlpy0.jpg" alt=""></p>
<p>A square matrix A is symmetric if $A^T=A$</p>
<p>A scalar $\lambda$ is eigenvalue of A if there exists a non-zero vector $\vec{X}$, s.t. $A\vec{X}=\lambda\vec{X}$ and $\vec{X}$ is called an eigenvector of A with respect to $\lambda$.</p>
<p>A basis $B$ of a vector space is orthonormal if $||\vec{X}||=1$ for any $\vec{X}\in B$, and $&lt;\vec{X_1},\vec{X_2}&gt;=0$ for any $\vec{X_1},\vec{X_2}\in B$</p>
<p><strong>Thm. Let A be a real symmetric $(n\times n)$-matrix. Then A is a diagonizable and $\mathbb{R}^n$ has orthonormal basis of eigenvectos of A</strong></p>
<script type="math/tex; mode=display">
A\sim\left(\begin{matrix}
   \lambda_1 & \dots &0\\
   \vdots & \ddots &\vdots\\
   0 & \dots &\lambda_n\\
  \end{matrix}\right)</script><p><strong>Proposition. All eigenvalues of a real symmetric $(n\times n)$-matrix is real</strong></p>
<hr>
<p><strong>Proof</strong> We assume that A is a $n\times n$ matrix, $\lambda$ is an eignevalue of A.</p>
<p>Assume that $\vec{X}$ is an eigenvector of $\lambda$, Then</p>
<script type="math/tex; mode=display">
\begin{aligned}
\lambda||\vec{X}||&=<\lambda\vec{X},\vec{X}>=<A\vec{X},\vec{X}>=\vec{X^T}A\vec{X}\\&=\vec{X^T}A^T\vec{X}=(A\vec{X})^T\vec{X}=<\vec{X},A\vec{X}>=\bar{\lambda}||\vec{X}||
\end{aligned}</script><p>So $\lambda=\bar{\lambda}\Rightarrow\lambda$ is real.</p>
<hr>
<p>A real symmetric matrix A is positive semi-definite if ,for all $\vec{X}\in\mathbb{R}^n$, $\vec{X}^TA\vec{X}\geq0$ and A is positive definite if $\vec{X}^TA\vec{X}&gt;0$</p>
<p><strong>Proposition. All eigenvalues of a positive semi-definite $\Leftrightarrow\ \exists$ a matrix B, s.t. $A=B^TB$</strong></p>
<hr>
<p><strong>Proof.</strong>$\Rightarrow$ We assume that A is a positive semi-definite matrix.</p>
<p>Then A is diagonaizable and assume that $A=Q^TDQ$ where D is a diagonable matrix with eigenalues on its diagonal. Note that all egienvalues of A are non-negative.</p>
<script type="math/tex; mode=display">
A=Q^TDQ=Q^TD^{\frac{1}{2}}D^\frac{1}{2}Q=(\sqrt{D}Q)^T(\sqrt{D}Q)=B^TB,\quad where\ B=\sqrt{D}Q</script><p>$\Leftarrow$ Let $A=B^TB$.</p>
<p> Then for any $\vec{X}\in\mathbb{R}^n$, $\vec{X}^TA\vec{X}=\vec{X}^TB^TB\vec{X}=(B\vec{X})^TB\vec{X}=||B\vec{X}||\geq0$</p>
<p>So A is positive semi-definite.</p>
]]></content>
      <categories>
        <category>Graph Theory</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Operation Research</tag>
      </tags>
  </entry>
  <entry>
    <title>Lecture series on graph theory 6</title>
    <url>/2022/05/24/Graph6/</url>
    <content><![CDATA[<p><strong>Interlacing Theorem</strong></p>
<p><strong>Thm(Eigenvalue Interlacing Theorem)<br>Let A be a symmetric real $n\times n$ and let B be  an m-th principal submatrix<font color='red'>(obtained by deleting both i-th row and i-th column for some n-m values of i)</font>. Suppose A has eigenvalues $\lambda_1\geq\cdots\geq\lambda_n$, and B has eigenvalues $\beta_1\geq\cdots\geq\beta_m$.Then</strong></p>
<script type="math/tex; mode=display">
\lambda_k\geq\beta_k\geq\lambda_{k+(n-m)},\qquad k=1,2,\dots,m</script><span id="more"></span>
<p><img src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220226/2022-05-24_122238.626hmwj3vik0.jpg" alt=""></p>
<p>Further,if $m=n-1$, then </p>
<script type="math/tex; mode=display">
\lambda_1\geq\beta_1\geq\lambda_2\geq\beta_2\geq\cdots\geq\lambda_i\geq\beta_i\geq\lambda_{i+1}\geq\cdots\geq\beta_{n-1}\geq\lambda_{n}</script><hr>
<p><strong>Proof</strong></p>
<p>Without loss of generality, assume that $A=\left[\begin{matrix}B&amp;X\X^T&amp;C\end{matrix}\right]$ and $\lambda_i\vec{x}_i=A\vec{x}_i$ for $i\in[n]$ such that all $\vec{x}_i$ are linearly independent and normalized, and $\beta_j\vec{y}_j=B\vec{y}_j$ for $j\in[m]$ s.t. all $\vec{y}_j$ are linearly independent and normalized.</p>
<p>Let $V=span{\vec{x}_k,\cdots,\vec{x}_n}$ and $W=span{\vec{y}_1,\cdots,\vec{y}_k}$. Extend $W$ to a subspace of $\mathbb{R}^n$ s.t.</p>
<script type="math/tex; mode=display">
\widetilde{W}=\left\{\left.\left[\begin{matrix}\vec{w}\\0\end{matrix}\right]\right|\vec{w}\in W\right\}\subset\mathbb{R}^n</script><p>Then $\dim(V)=n-k+1$ and $\dim(\widetilde{W})=\dim(W)=k$</p>
<p>Note that both $V\subset \mathbb{R}^n$ and $\widetilde{W}\subset \mathbb{R}^n$, and </p>
<script type="math/tex; mode=display">
\dim(V)+\dim(\widetilde{W})=n-k+1+k=n+1>\dim(\mathbb{R}^n)</script><p>It follows that there exists a vector $\tilde{w}$ which satisfies $\tilde{w}\in V\cap\widetilde{W}$.</p>
<font color='red'>$\lambda_k$ is the largest eigenvalue with an eigenvector in V; $\beta_k$ is the smallest eigenvalue with an eigenvector in W.</font>

<p>Therefore,</p>
<script type="math/tex; mode=display">
\begin{aligned}
\lambda_k&=\max\{\vec{x}^TA\vec{x}|\vec{x}\in V,||\vec{x}||=1\}\\
&\geq\frac{\tilde{w}^TA\tilde{w}}{\tilde{w}^T\tilde{w}}=\left.\left[\begin{matrix}\vec{w}^T&0\end{matrix}\right]\left[\begin{matrix}B&X\\X^T&C\end{matrix}\right]\left[\begin{matrix}\vec{w}\\0\end{matrix}\right]\right/\left[\begin{matrix}\vec{w}^T&0\end{matrix}\right]\left[\begin{matrix}\vec{w}\\0\end{matrix}\right]\\
&=\frac{\tilde{w}^TB\tilde{w}}{\tilde{w}^T\tilde{w}}\geq\min\{\vec{y}^TA\vec{y}|\vec{y}\in W,||\vec{y}||=1\}=\beta_k
\end{aligned}</script><p>So we have $\lambda_k\geq\beta_k$.</p>
<p>On the other hand, let $V=span{\vec{x}<em>1,\cdots,\vec{x}</em>{k+n-m}}$ <font color='red'>(i.e. $\lambda_{k+n-m}$ is the smallest eigenvalue with an eigenvector in V)</font> and $W=span{\vec{y}<em>1,\cdots,\vec{y}</em>{k+n-m}}$ <font color='red'>(i.e. $\beta_k$ is the largest eigenvalue with an eigenvector in W)</font>.</p>
<p>Let $\widetilde{W}=\left{\left.\left[\begin{matrix}\vec{w}\0\end{matrix}\right]\right|\vec{w}\in W\right}\subset\mathbb{R}^n$. Then $\dim(V)=k+n-m$ and $\dim(\widetilde{W})=m-k+1$.</p>
<p>Therefore, $\dim(V)+\dim(\widetilde{W})=n-k+1+k=n+1&gt;\dim(\mathbb{R}^n)$</p>
<p>It follows that there exists a vector $\tilde{w}$ which satisfies $\tilde{w}\in V\cap\widetilde{W}$.</p>
<script type="math/tex; mode=display">
\begin{aligned}
\lambda_{k+n-m}&=\min\{\vec{x}^TA\vec{x}|\vec{x}\in V,||\vec{x}||=1\}\\
&\leq\frac{\tilde{w}^TA\tilde{w}}{\tilde{w}^T\tilde{w}}=\left.\left[\begin{matrix}\vec{w}^T&0\end{matrix}\right]\left[\begin{matrix}B&X\\X^T&C\end{matrix}\right]\left[\begin{matrix}\vec{w}\\0\end{matrix}\right]\right/\left[\begin{matrix}\vec{w}^T&0\end{matrix}\right]\left[\begin{matrix}\vec{w}\\0\end{matrix}\right]\\
&=\frac{\tilde{w}^TB\tilde{w}}{\tilde{w}^T\tilde{w}}\leq\max\{\vec{y}^TA\vec{y}|\vec{y}\in W,||\vec{y}||=1\}=\beta_k
\end{aligned}</script><p>So $\lambda_{k+n-m}\leq\beta_k$.</p>
<p><strong>Bounding degree of induced subgraph</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220226/2022-05-24_162631.52l2utvvt9c0.jpg" alt=""></p>
<p><strong>Thm(Huang,2019) Let H be an induced subgraph of the n-dimensional hypercube $Q_n$. If $|V(H)|&gt;2^{n-1}=\frac{|V(Q)|}{2}$,then $\Delta (H)\geq\sqrt{n}$</strong></p>
<font color='red'>**n-dimensional hypercube $Q_n$**</font>

<p><img src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220226/2022-05-24_163151.69hvpww08lw0.jpg" alt=""></p>
<font color='red'>An n-dimensional hypercube $Q_n$ is a graph with vertex set consisting of all $\{0,1\}$-sequences of length n and two vertices are adjacent to each other if and only if the two $\{0,1\}$-sequences has exactly one position different</font>

<p>The adjacency matrix of n-dimensional hypercube $Q_n$ satisfies the following</p>
<p><img src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220226/2022-05-24_163613.2kylzo171uo0.jpg" alt=""></p>
<p>If we give every edge in n-dimensional hypercube $Q_n$ a sign, we can get a signed adjacency matrix.</p>
<p><img src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220226/2022-05-24_163633.44mufz49sju0.jpg" alt=""></p>
<p><strong>Lemma The signed n-dimensional hypercube with adjacency matrix $S_n$ has an eigenvalue $\sqrt{n}$ of multiplicity $2^{n-1}$ and eigenvalue $-\sqrt{n}$ with multiplicity $2^{n-1}$</strong></p>
<hr>
<p><strong>Proof</strong></p>
<p><strong>claim: $S_n^2=nI$</strong></p>
<p>If $n=1$, $S<em>1=\left[\begin{matrix}0&amp;1\1&amp;0\end{matrix}\right],S_1^2=I$. Assume that $S</em>{n-1}^2=(n-1)I$</p>
<p>Then </p>
<script type="math/tex; mode=display">
S_n^2=\left[\begin{matrix}S_{n-1}&I\\I&-S_{n-1}\end{matrix}\right]\left[\begin{matrix}S_{n-1}&I\\I&-S_{n-1}\end{matrix}\right]=\left[\begin{matrix}S_{n-1}^2+I&O\\O&S_{n-1}^2+I\end{matrix}\right]=nI</script><p>So claim holds.</p>
<p>Note that $nI$ has eigenvalues n. Therefore, $S_n$ has eigenvalues either $\sqrt{n}$ or $-\sqrt{n}$.</p>
<p>Since the trace of $S_n$ is 0, $S_n$ has eigenvalues $\sqrt{n}$ of multiplicity $2^{n-1}$ and $-\sqrt{n}$ with multiplicity $2^{n-1}$.</p>
<hr>
<p><strong>Proof of Huang’s Theorem</strong></p>
<p>Let H be a induced subgraph of $Q_n$ with more than $2^{n-1}$ vertices. It suffices to show that every subgraph H with exactly $2^{n-1}+1$ vertices has maximum degree at least $\sqrt{n}$.</p>
<p>Let $(Q_n,\sigma)$ be  the signed graph with adjacency matrix $S_n$ as defined above. Then $(H,\sigma)$ is a signed induced subgraph of $(Q_n,\sigma)$, whose adjacency matrix $A$ is a $(2^{n-1}+1)$-principle submatrix of $S_n$.</p>
<p>By the proposition <font color='red'>(i.e. $|\lambda(H,\sigma)|\leq\Delta (H)$</font> and the interlacing theorem</p>
<script type="math/tex; mode=display">
\Delta (H)\geq\lambda_1(A)\geq\lambda_{1+2^n-(2^{n-1}+1)}(S_n)=\lambda_{2^{n-1}}(S_n)=\sqrt{n}</script><p>$\lambda_1(A)$ means the largest eigenvalue of A.</p>
<hr>
<p><strong>Unfriendly partitions of subcubic graphs</strong></p>
<p>A graph G is subcubic if the maximum degree of G is at most 3. <font color='red'>($\Delta(G)\leq3$)</font></p>
<font color='red'>Conjecture (Pisanski and Fowler,2012)  <br>All subcubic graphs except finitely many have median eigenvalues in the interval$[-1,1]$. There exists a constant c such that if $|V(G)|\geq|c|$, then $\lambda_{\lfloor\frac{\lambda+1}{2}\rfloor},\lambda_{\lceil\frac{\lambda+1}{2}\rceil}\in[-1,1]$</font>

<p>Let G be a graph. A partition $(X,Y)$ of $V(G)$ is unfriendly if every vertex has at least the same number of neighbors in the other subset as in it owns.</p>
<font color='red'>In other words, for every vertex v of G, $d_{G[x]}(v)\leq\frac{1}{2}d_G(v)$ and $d_{G[Y]}(v)\leq\frac{1}{2}d_G(v)$</font>

<p>If $(X,Y)$ is an unfriendly partition of a subcubic graph $G$, then the maximum degree of the induced subgraph $G[X]$ and $G[Y]$ is at most 1.</p>
<p>An unfriendly partition $(X,Y)$ is unbalanced if $|X|\not=|Y|$</p>
<p>A partition is a bisection if $\Big||X|-|Y|\Big|\leq1$</p>
<p><strong>Proposition Let G be a subcubic graph with n vertices. If G has an unbalanced unfriendly partition, then</strong></p>
<script type="math/tex; mode=display">
\lambda_{\lfloor\frac{n+1}{2}\rfloor}\in[-1,1]\qquad\lambda_{\lceil\frac{n+1}{2}\rceil}\in[-1,1]</script><hr>
<p><strong>Proof</strong></p>
<p>Let G be a subcubic graph with n vertices and $(X,Y)$ be an unbalanced unfriendly partition.</p>
<p>Without loss of generality, assume that $|X|&gt;|Y|$</p>
<p>Then $\lambda_1(X)\leq\Delta(X)\leq1$ and $\lambda_1(Y)\leq\Delta(Y)\leq1$. So both X and Y are bipartite.</p>
<p>All eigenvalues of $X$ and $Y$ belong to $[-1,1]$. Since $|X|&gt;|Y|$, it holds that </p>
<script type="math/tex; mode=display">
|X|\geq\left\lceil \frac{n}{2}\right\rceil+1>\frac{n}{2}>\left\lceil \frac{n}{2}\right\rceil-1\geq|Y|</script><p>It follows that the interlacing theorem that </p>
<script type="math/tex; mode=display">
1\geq\lambda_1(X)\geq\lambda_{1+n-|X|}(G)\geq\lambda_{1+n-(\lceil\frac{n}{2}\rceil+1)}(G)\geq\lambda_{\left\lfloor \frac{n+1}{2}\right\rfloor}(G)\geq\lambda_{\left\lceil \frac{n+1}{2}\right\rceil}(G)\geq\lambda_{\left\lceil \frac{n+1}{2}\right\rceil}(X)\geq-1</script><p>The completes the proof.</p>
<hr>
<font color='red'>Q: Does every subcubic graph have an unbalanced unfriendly partition?</font>

<font color='red'>A: No</font>

<p><img src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220226/2022-05-26_005635.7fv36qke8og0.jpg" alt=""></p>
<font color='red'>Conjecture(Ban&Linal,2016) Every cubic graph has an unfriendly almost balanced partition $(X,Y)$ s.t. $\Big||X|-|Y|\Big|\leq2$</font>
]]></content>
      <categories>
        <category>Graph Theory</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Operation Research</tag>
      </tags>
  </entry>
  <entry>
    <title>Lecture series on graph theory 2</title>
    <url>/2022/03/28/Graph2/</url>
    <content><![CDATA[<p>First, we try to prove the Mantel’s Theorem, which was presented as a question in the last blog post.</p>
<p><strong>Thm(Mantel’s Theorem)<br>Let G be a graph with n vertices. If G does not contain a triangle, then</strong></p>
<script type="math/tex; mode=display">
\lvert E(G)\rvert\leq\frac{n^2}{4}</script><p>Before the proof begin, we introduce what triangle means.</p>
<span id="more"></span>
<p><img src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220226/2022-03-29_220946.jpg" alt=""></p>
<font color=red>$C=v_1v_2v_3v_4v_5v_1$ is a 5-cycle.Generally, k-cylce has k vertices.Specially, we call a 3-cycle as a triangle</font>

<p>Now, let’s take a few examples to find potential patterns which may help to prove this theorem.</p>
<p><img src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220226/63DEEBC1B5B34ABA2048219295C11EF6.jpg" alt=""></p>
<font color=red>In general, we can divide n vertices into two groups, then we add all edges between two groups.Because there is no edge joining the vertices from the same side, if there is a cycle in graph, it must be an even cycle, such as alternating left-hand and right-hand sides.<br>If n is even, #edges=$\frac{n}{2}\cdot\frac{n}{2}=\frac{n^2}{4}$, if n is odd, #edges=$\frac{n+1}{2}\cdot\frac{n-1}{2}=\frac{n^2-1}{4}\leq\frac{n^2}{4}$</font>

<hr>
<p><strong>Proof of the Mantel’s Theorem</strong></p>
<p>Let G be an n-vertex graph without a triangle.</p>
<p><img src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220226/2022-03-29_225536.jpg" alt=""></p>
<p>$\forall x,y\in V(G)$, if $xy\in E(G)$, $N_G(x)\cap N_G(y)=\emptyset$ because G has no triangle.</p>
<p>Because $N_G(x)\cup N_G(y)\subset V(G)$, $d_G(x)+d_G(y)\leq n$</p>
<p>From the above formula, we have </p>
<script type="math/tex; mode=display">
\sum_{xy\in E(G)}(d_G(x)+d_G(y))\leq\sum_{xy\in E(G)}n=n\cdot\lvert E(G)\rvert \tag{1}</script><p><img src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220226/2022-03-29_225550.4v4nzok1fwc0.jpg" alt=""></p>
<p>We find that $d<em>G(x)$ appears in $d_G(x)+d_G(y_1),d_G(x)+d_G(y_2),\dots,d_G(x)+d_G(y</em>{d_G(x)})$</p>
<script type="math/tex; mode=display">
So\ \sum_{xy\in E(G)}(d_G(x)+d_G(y))=\sum_{x\in V(G)}d_G(x)\cdot d_G(x)=\sum_{x\in V(G)}d_G(x)^2\tag{2}</script><p>From (1) &amp; (2), we have </p>
<script type="math/tex; mode=display">
\sum_{x\in V(G)}d_G(x)^2\leq n\cdot\lvert E(G)\rvert\tag{3}</script><p>According to the relationship between degree and edge: $\sum<em>{x\in V(G)}d_G(x)=2\lvert E(G)\rvert$ and  the Cauchy-Schwarz inequality:$(\sum</em>{k=1}^n a<em>k^2)(\sum</em>{k=1}^n b<em>k^2)\geq(\sum</em>{k=1}^na_kb_k)^2$, we have</p>
<script type="math/tex; mode=display">
\sum_{x\in V(G)}d_G(x)^2\geq \frac{(\sum_{x\in V(G)}d_G(x))^2}{n}=\frac{4\lvert E(G)\rvert^2}{n}\tag{4}</script><p>From (3) &amp; (4), $\frac{4\lvert E(G)\rvert^2}{n}\leq \sum_{x\in V(G)}d_G(x)^2\leq n\cdot \lvert E(G)\rvert$ which implies $\lvert E(G)\rvert \leq\frac{n^2}{4}$</p>
<hr>
<p>If a graph G has more than $\frac{n^2}{4}$ edges, then G has a triangle.</p>
<font color=red>Furthermore, we can extend the triangle to k-cycle and obtain the Erdős-Gallai's Theorem <br>We can also extend the triangle to a complete graph with k vetices, which are called k-clique and obtain the Turán's Theorem</font>

<p>Tree: A tree is a connected graph without cycles.</p>
<p><strong>Proposition: Every tree with at least two vetices has at least two vertices of degree one</strong></p>
<hr>
<p><strong>Proof</strong></p>
<p>Let P be the longest path of G. Then both end vertices of P have degree one in G.If not, we suppose that $u,v\in V(P),\ uv\in E(P)$ and u is the end vertex of P, but $d_G(u)&gt;1$.</p>
<p>Case 1:</p>
<p><img src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220226/2022-04-04_204919.4qpcnrekreg0.jpg" alt=""></p>
<p>$w\not\in V(P)$ and $wu\in E(G)$,then $\tilde{P}=P+wu$ is longer than P. This contradicts the fact that P is the longest path.</p>
<p>Case 2:</p>
<p><img src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220226/2022-04-04_204927.tn63688yr68.jpg" alt=""></p>
<p>$w\in V(P),w\not=v$ and $wu\in E(G)$, then we can find that there is a cycle. This  contradicts the fact that G is a tree.</p>
<hr>
<p>A vertex of a tree is a leaf if it has degree one.</p>
<p><strong>Proposition: A connected graph with n vertices is a tree if and only if it has n-1 edges. </strong></p>
<hr>
<p><strong>Proof</strong></p>
<p>$\Rightarrow$ n=1, G has no edges.</p>
<p>Now, we assume that it is correct for a tree with n-1 vertices to have n-2 edges.From this assumption, we want to deduce that a tree with n vertices has n-1 edges.</p>
<p>Since $n\ge2$, G has a vertex v of degree one. Let u be the only neighbor of v in G. Because G is a tree with n vertices, G-v is a tree with n-1 vertices. According to the asssumption,$\lvert E(G-v)\rvert=(n-1)-1$.</p>
<script type="math/tex; mode=display">
\lvert E(G)\rvert=\lvert E(G-v)\rvert+1=(n-1)-1+1=n-1</script><p>$\Leftarrow$ Let G be a connected graph with n vertices and n-1 edges. We claim that G has a vertex of degree one.</p>
<p>We prove this claim first.If not, $\forall x\in V(G)$, assume $d_G(x)\ge2$</p>
<p>Then we have $\lvert E(G)\rvert=\frac{1}{2}\sum_{x\in V(G)}d_G(x)\ge\frac{1}{2}\cdot2\lvert V(G)\rvert=n&gt;n-1$ which contradicts that $\lvert E(G)\rvert=n-1$. The contradiction implies the claim holds.</p>
<p>From this claim, G has a vertex of degree one. Use the induction on G-v. Since G-v has n-1 vertices and $(n-1)-1$ edges. By inductive hypothsis, G-v is a tree and has no cycles.Since v is a degree one vertex, G has no cycles. Therefore, G is a tree.</p>
<hr>
<p><strong>Corollary: Every graph with minimum degree at least two contains a cycle.</strong></p>
<p>A spanning tree of G is a connected spanning subgraph of G without cycles.</p>
<font color=red>Problem: counting the number of edge-disjoint spanning trees in a graph.<br>If the number of edge-disjoint spanning trees is large, the graph is well-connected. (Related to edge-connectivity of the graph)</font>

<p>Now we introduce two classic search algorithms in graph theory.</p>
<p>A breadth-first-search tree of a graph (BFS-tree)</p>
<p><img src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220226/2022-04-05_111757.6pnsx44gbus0.jpg" style="zoom: 50%;" /></p>
<p>(i) Start at $x=x_0$ and join x to all neighbors of x, Let $N_1=N_G(x)$</p>
<p>(ii) For each $y\in N<em>i$, join y to all neighbors of y without creating cycles and let $N</em>{i+1}=\cup_{y\in N_i}N_G(y)$</p>
<p>The algorithm will take $O (\lvert V\rvert+\lvert E\rvert)$ steps to find a BFS-tree rooted at $x_0$.</p>
<p>A deepth-first-search tree of a graph (DFS-tree)</p>
<p><img src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220226/微信图片_20220405111924.6g6tlxqwfto0.jpg" style="zoom:15%;" /></p>
<p>(i) Start at $x=x_0$ and $T_0={x_0}$ </p>
<p>(ii) Join x to one of its neighbor $x_1\in N_G(x_0)$ and$T_1={x_0,x_1}$</p>
<p>(iii) If $N<em>i=N_G(x_i)\backslash T_i\not=\emptyset$, then join $x_i$ to a vertex $x</em>{i+1}\in N<em>i$ and let $T</em>{i+1}=T<em>i\cup{x</em>{i+1}}$ and $x_{i+1}\to x_i$</p>
<p>If $N<em>i=N_G(x_i)\backslash T_i=\emptyset$, then set $x</em>{i-1}\to x<em>{i}$ and $N</em>{i-1}=N<em>G(x</em>{i-1})\backslash T_i\to N_i$ and continue.</p>
<p>Eulerian graph: </p>
<font color=red>Problem: Let G be a graph.When does G have a closed trail which contains all edges of G?</font>

<p>A closed trail is Eulerian if the trail go through all edges of G. A graph is called Eulerian if it has an Eulerian trail.</p>
<p><strong>Proposition: Every Eulerian graph is a connected graph which has only even-degree vertices</strong></p>
<hr>
<p><strong>Proof</strong> Let G be an Eulerian graph. Then G has an Eulerian trail, denoted by $T=v_1e_1v_2e_2\cdots v_me_mv_1$. So G is connected.</p>
<p>Now, orient the edges of G along the trail T such that, for an edge $e<em>i$ in T, orient $e_i$ from $v_i$ to $v</em>{i+1}$. Since T has no repeated edges, every edge receives exactly one orientation. For each vertex $v_i$, T visits $v_i$ and then leaves $v_i$, which implies</p>
<script type="math/tex; mode=display">
\# edges\ oriented\ towards\ v_i=\#edges\ oriented\ away\ from\ v_i</script><p>But the degree of $v_i$ satisfies</p>
<script type="math/tex; mode=display">
\begin{aligned}
d_G(v_i)&=\# edges\ oriented\ towards\ v_i+\#edges\ oriented\ away\ from\ v_i\\
&\equiv0(mod\ 2)
\end{aligned}</script><p>So every vertex of G has an even degree.</p>
<hr>
<p>A cycle decomposition D of a graph G is a set of egde-disjoint cycles $D={C_1,C_2,\dots,C_k}$ such that  </p>
<script type="math/tex; mode=display">
\cup_{C_i\in D}E(C_i)=E(G)</script><p><strong>Proposition: Every even graph has a cycle decomposition.</strong></p>
<hr>
<p><strong>Proof</strong> Let G be an even graph. Suppose to the contrary that G does not have a cycle decomposition.</p>
<p>Assume G is a minimal counterexample.If G has a vertex v of degress zero, the G-v is a   subgraph of G and hence is not a counterexample. So G-v has a cycle decomposition. So does G, a contradiction to that G is a counterexample.</p>
<p>So assume that$\delta(G)\ge2$. Then by corollary, G has a cycle C. Then, G-E(C) is an even subgraph of G. So G-E(C) has a cycle decomposition D. Then, $D\cup{C}$ is a cycle-decomposition of G, which contradicts that G is a counterexample. So prop. holds.</p>
<hr>
<font color='red'>Corollary: Every Eulerian graph has a cycle decomposition.</font>

<font color='red'>（conjecture,Hajos,1968）All Eulerian graph with n vertex. How many cycles in a cycle decomposition D?$\lvert D\rvert\le\frac{n-1}{2}$?</font>
]]></content>
      <categories>
        <category>Graph Theory</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Operation Research</tag>
      </tags>
  </entry>
  <entry>
    <title>Lecture series on graph theory 7</title>
    <url>/2022/05/26/Graph7/</url>
    <content><![CDATA[<p><strong>Thm(Wilf,1967) Let G be a graph. Then $\chi(G)\leq\lambda_1(G)+1$, where $\chi(G)$ is the chromatic number</strong></p>
<p>A proper vertex coloring is a map $c:V(G)\to\mathbb{N}$ s.t. $c(v_i)\not=c(v_j)$ if $v_iv_j\in E(G)$.</p>
<p>A graph is a k-colorable if there exists a proper vertex coloring </p>
<script type="math/tex; mode=display">
c:V(G)\to\{1,2,\cdots,k\}=[k].</script><span id="more"></span>
<p>The chromatic number of a graph is the smallest integer k s.t. G is k-colorable, denoted by $\chi(G)$.</p>
<p><strong>(Four color Theorem) Every planar graph is 4-colorable</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220226/2022-05-26_011010.4crr6n46e6o.jpg" alt=""></p>
<p><strong>Lemma Let G be a graph. Then</strong></p>
<script type="math/tex; mode=display">
\chi(G)\leq1+p</script><p><strong>where $p=\max{\delta(H)|\text{H is an induced subgraph of G}}$, <font color='red'>$\delta(G)$ is minimum degree of H.</font></strong></p>
<hr>
<p><strong>Proof of Lemma</strong></p>
<p>Use greedy algorithm:</p>
<p>Consider that $c:V(G)\to\mathbb{N}$ such that color the first vertex by the smallest value and color the k-th vertex by using the smallest value that has not been used to color any of the first k-1 vertices that are adjacent to the k-th vertex. So it suffices to show that there is an ordering of the vertices of G for which the greedy algorithm gives an (1+p)-coloring of G.</p>
<p>Let $x_n$ be a vertex of $G=H_n$ having degree at most p.<font color='red'>（$x_n$ could be the vertex of G with the degree $\delta(G)$</font></p>
<p>By the definition of the value of p, the subgraph $H<em>{n-1}=G-x_n$ has a vertex $x</em>{n-1}$ of degree at most p. Continue this process, let $H<em>{n-1}=G-{x_n,x</em>{n-1},\cdots,x<em>{n-i+1}}$ which again has a vertex of degree at most p, denoted by $x</em>{n-i}$ for $i\in[n]$</p>
<p>Then $H<em>{1}=G-{x_n,x</em>{n-1},\cdots,x_{2}}$ is an isolated vertex of degree 0.</p>
<p> Then the ordering $x_1,x_2,\cdots,x_n$ is a desired one.</p>
<hr>
<p><strong>Proof of Wilf’s Theorem</strong></p>
<p>Let G be a graph. For any induced subgraph H of G, $\delta(G)\leq d(G)\leq\lambda_1(H)\leq\lambda_1(G)$</p>
<p>Therefore, $p=\max{\delta(H)|\text{H is an induced subgraph of G}}\leq\lambda_1(G)$</p>
<p>It follows from the above Lemma</p>
<script type="math/tex; mode=display">
\chi(G)\leq 1+p\leq1+\lambda_1(G)</script><hr>
<p>If G is k-colorable, let $c:V(G)\to[k]$ be a k-colorable. $c^{-1}(i)$, the preimage of color i, is an independent set. Independent number of G: $\alpha(G)\geq\max\left{|c^{-1}(i)|\big|i\in[k]\right}\geq n/k$.</p>
<p>So $\alpha(G)\geq n/\chi(G)\geq n/(1+\lambda_1(G))$.</p>
<p><strong>Coloring, Integer flow</strong></p>
<p>Let G be a graph. An integer flow of G is an ordered pair $(D,f)$ where $D$ is an orientation of $G$ and $f$ is an integer function $f:E(G)\to\mathbb{Z}$ s.t. for every vertex v of G $\sum<em>{e\in E^{+}(v)}f(e)=\sum</em>{e\in E^{-}(v)}f(e)$ where $E^{+}(v)$ is the set of all arcs with $v$ as tail and $E^{-}(v)$ is the set of all arcs with v as head.</p>
<font color='red'>Recall: this incidence matrix of D is matrix is $\vec{B}$ and $\vec{f}=<f(e_1),\cdots,f(e_m)>\in\mathbb{Z}^m$ where $m=|E(G)|$ , then $\vec{B}\cdot\vec{f}=0$. This vector $\vec{f}$ is called an integer flow of G.</font>

<p>An integer flow $(D,f)$ is nowhere-zero if $f(e)\not=0$ for all edges of $G$ <font color='red'>i.e. $\vec{f}$ has no zero component.</font></p>
<p>An integer flow $(D,f)$ is a k-flow if $|f(e)|<k$ <font color='red'>i.e. every component of $\vec{f}$ has absolute value less than k.&lt;/font&gt;</p>
<p>If G has a k-flow, the orientation in the k-flow does not matter.</p>
<p><strong>Proposition Every Eulerian graph has nowhere 2-flow. A connected graph with a nowhere-zero 2-flow is Eulerian.</strong></p>
<p><strong>Lemma Let $(D,f)$ be a flow of G, then for each $X\subset V(G)$, it holds that</strong>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      </p>
<script type="math/tex; mode=display">
\sum_{e\in E^{+}X}f(e)=\sum_{e\in E^{-}(X)}f(e)</script><hr>
<p><strong>Proof</strong></p>
<p>Since $(D,f)$ is a flow, it follows that, for every vertex v,</p>
<script type="math/tex; mode=display">
\sum_{e\in E^{+}(v)}f(e)=\sum_{e\in E^{-}(v)}f(e)</script><p>So $\sum<em>{e\in E^{+}(v)}f(e)-\sum</em>{e\in E^{-}(v)}f(e)=0$</p>
<p>Note that</p>
<script type="math/tex; mode=display">
0=\sum_{v\in X}(\sum_{e\in E^{+}(v)}f(e)-\sum_{e\in E^{-}(v)}f(e))=\sum_{e\in E^{+}(X)}f(e)-\sum_{e\in E^{-}(X)}f(e)</script><hr>
<p><strong>Corollary A graph has a nowhere-zero integer flow $\Leftrightarrow$ it has no cut-edge.</strong></p>
<hr>
<p><strong>Proof</strong></p>
<p>$\Rightarrow$ It follows directly from the above lemma.</p>
<p>$\Leftarrow$ Assume that G has no cut-edge. Then every edge of G belongs to a cycle. </p>
<p>Let $C={C_1,C_2,\cdots,C_k}$ be a set of cycles covering all edges of G.</p>
<p>Every $C_1$ has nowhere-zero 2-flow $(D,f_1)$</p>
<script type="math/tex; mode=display">
f:E(G)\to\mathbb{N}\quad s.t.\ f(e)=\sum_{i=1}^k 2^if_i(e)</script><p>Then $(D,f)$ is a nowhere-zero integer flow.</p>
<hr>
<p><strong>The Coloring-Flow Duality Theorem (Tutte)<br>Let G be a 2-connected planar graph. Then G is proper face k-colorable if and only if G has a nowhere-zero k-flow. In other words, let $G^{\star}$ be its planar dual. Then $G^{\star}$ is proper k-colorable $\Leftrightarrow$ G has a nowhere-zero k-flow.</strong></p>
]]></content>
      <categories>
        <category>Graph Theory</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Operation Research</tag>
      </tags>
  </entry>
  <entry>
    <title>Lecture series on graph theory 5</title>
    <url>/2022/05/22/Graph5/</url>
    <content><![CDATA[<p>Let G be a finite graph. We consider a random walk on the vertices of G of the following type. Start at a vertex $v$ .<font color='red'>(v could be chosen randomly according to some probably distribution or could be specified in advance).</font> Among all edges incident to v, choose one uniformly at random<font color='red'>( i.e. if $d_G(v)=d$, each of these edges is chosen with probability 1/d)</font> </p>
<p><strong>Problem: determine the probability of being at a given vertex after a given number steps.</strong></p>
<span id="more"></span>
<p>Let M(G) be the matrix whose rows and columns are indexed by vertices $v<em>1,\dots,v_n$, we assume that $m</em>{ij}$ is the $(i,j)$-entry of M(G), which satisfies the following formula</p>
<script type="math/tex; mode=display">
m_{ij}=\frac{a_{ij}}{d_i}</script><p>where $a<em>{ij}$ is the number of edges between $v_i$ and $v_j$. The $m</em>{ij}$ is probability that if one starts at $v_i$ and then the next step will be at $v_j$.</p>
<font color='red'>Recall: the number of k-walks from $v_i$ to $v_j$= the $(i,j)$-entry of $A(G)^k$</font>

<p>$\exists v<em>ie_1v</em>{i<em>1}e_2v</em>{i<em>2}\cdots e_kv_j,\ P(v_ie_1v</em>{i<em>1}e_2v</em>{i<em>2}\cdots e_kv_j)=\frac{a</em>{ii<em>1}}{d_i}\frac{a</em>{i<em>1i_2}}{d</em>{i<em>1}}\cdots\frac{a</em>{i<em>{k-1}i_j}}{d</em>{i<em>{k-1}}}=m</em>{ii<em>1}m</em>{i<em>1i_2}\cdots m</em>{i_{k-1}j}$</p>
<script type="math/tex; mode=display">
\begin{aligned}
P(v_i\to v_j\ in\ k\ steps)&=\sum_{k-walk\ from\ v_i\to v_j} P(v_ie_1v_{i_1}e_2v_{i_2}\cdots e_kv_j)\\
&=\sum m_{ii_1}m_{i_1i_2}\cdots m_{i_{k-1}j}=(i,j)-entry\ of\ M(G)^k
\end{aligned}</script><p>Assume the probability to pick $v<em>i$ is $p(v_i)$ for $i\in{1,\dots,n}$ s.t. $\sum</em>{i=1}^n p(v_i)=1$</p>
<p>Let $P=[\begin{matrix}p(v_1)&amp;p(v_2)&amp;\cdots&amp;p(v_n)\end{matrix}]$. Then the probability of a walk ending up at $v_i$ in k steps is </p>
<script type="math/tex; mode=display">
P(there\ is\ a\ walk\ ending\ up\ at\ v_i\ in\ k\ steps)=[PM(G)^k]_i</script><p>If G is k regular <font color='red'>( every vertex has degree k)</font> then $M(G)=\frac{1}{d}A(G)$</p>
<p>Then the eigenvalue $\beta_i$ of $M(G)$ satisfies $\beta_1=\frac{1}{d}\lambda_i$ where $\lambda_i$ is an eigenvalue of G.</p>
<script type="math/tex; mode=display">
P(\exists\ a\ closed\ k-walk\ starting\ v)=\beta_1^k+\cdots+\beta_n^k=\frac{1}{d^k}(\lambda_1^k+\cdots+\lambda_n^k)</script><p><strong>Weighted graphs and digraphs</strong></p>
<p>Let G be a graph. A weighted graph is a graph G associated with a weight function: $w:E(G)\to\mathbb{F}$ where $\mathbb{F}$ is a field, denote by $(G,w)$. Most of the time, we consider the case that $\mathbb{F}=\mathbb{R}$.</p>
<p>The adjacency matrix of a weighted graph is a real symmetric matrix $A(G,w)=(a<em>{ij})</em>{n\times n}$ with $a_{ij}=w(v_iv_j)$, the weight of the edge of $v_iv_j$.</p>
<p>Let H be a subgraph of $(G,w)$. The weight of H is defined as $w(H)=\sum_{e\in E(H)}w(e)$</p>
<p>For example, how to find a minimum weight path between two given vertices? How to find a minimum spanning tree or how to find a cycle or walk with large weight<font color='red'>( so-called heavy cycles or walks)</font></p>
<p>A digraph is a graph with an orientation which assigns an orientation to each edge.</p>
<p><img src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220226/2022-05-23_002508.6gvjbxprb7g0.jpg" alt=""></p>
<font color='red'>An orientation edge (or arc) from $v_i$ to $v_j$ is an ordered pair of vertices , denoted by $(v_i,v_j)$ where $v_i$ is called the tail and $v_j$ is called the head of arc.</font>
$$
A(D,w)=[a_{ij}]_{n\times n}\  where\ a_{ij}=\left\{\begin{aligned}& w(v_iv_j),\quad v_i\to v_j\\
&-w(v_iv_j),\quad v_j\to v_i\\
&0,\quad otherwise\end{aligned}\right. 
$$
Then $A(D,w)$ is no longer symmetric <font color='red'>but skew-symmetric:$A+A^T=O$</font>

<p>For a given graph G, let D be an orientation of G, $\vec{B}$ is an oriented incidence matrix</p>
<script type="math/tex; mode=display">
\vec{B}\cdot \vec{f}=\vec{b}\ where\ \vec{b}\in\mathbb{R}^{|V(G)|},\ \vec{f}\in\mathbb{R}^{|E(G)|}</script><p>A solution to $\vec{B}\cdot \vec{f}=\vec{b}$ is called a network flow. $\vec{b}$ is called a boundary condition.</p>
<p>If $\vec{b}=\vec{0},\ \vec{B}\cdot \vec{f}=\vec{0}.\qquad(*)$  </p>
<p>A vector $\vec{f}$ satisfies $(*)$ is called a circulation or real flow if $\vec{f}\in\mathbb{R}^{|E(G)|}$.</p>
<p>If a solution to $(*)$ satisfies $\vec{f}\in\mathbb{Z}^{|E(G)|}$, then $\vec{f}$ is called an integer flow.</p>
<font color='red'>Tutte's five-flow conjecture: For a graph without bridge, it has a nowhere zero 5-flow i.e. $\exists \vec{f}\in\mathbb{Z}^{|E(G)|}$ and every component of f is not zero and absolute value of every component is at most 4. $\vec{f}=[f_1, f_2,\cdots,f_m]$ where $m=|E(G)|,\ f_i\in\{-4,-3,-2,-1,0,1,2,3,4\}$</font>

<p><strong>Eigenvalues and subgraphs </strong></p>
<p>Let G be a graph with n vertices, $A(G)$ be the adjacency matrix.</p>
<p>All n eigenvalues of $A(G)$ are real because $A(G)$ is real and symmertic</p>
<script type="math/tex; mode=display">
\lambda_1(G)\geq\lambda_2(G)\geq\cdots\geq\lambda_{\lceil \frac{n+1}{2}\rceil}\geq\lambda_{\lfloor \frac{n+1}{2}\rfloor}\geq\lambda_n(G)</script><p>where $\lambda<em>{\lceil \frac{n+1}{2}\rceil},\lambda</em>{\lfloor \frac{n+1}{2}\rfloor}$ are median eigenvalues.</p>
<p>The largest eigenvalues $\lambda_1(G)$ is usually called the spectral radius of G.</p>
<p><strong>Proposition. Let G be an n-vertex graph and A be its adjacency matrix.Let $\lambda<em>1\geq\cdots\geq\lambda_n$ be the eigenvalues of A<br>Then 1. $\lambda_1 =\max</em>{\vec{x}\not=\vec{0}}\frac{\vec{x}^TA\vec{x}}{\vec{x}^T\vec{x}}$,   2. $\lambda_1\geq|\lambda_n|$</strong></p>
<hr>
<p><strong>Proof</strong></p>
<p>1.The eigenvalues of A (say $\vec{u}_1,\vec{u}_2,\dots,\vec{u}_n$) can be chosen as a standard orthogonal basis of $\mathbb{R}^n$. </p>
<p>Assume that array ($x_1,x_2,\dots,x_n$) is the coordinate of $\vec{x}$ under this basis</p>
<script type="math/tex; mode=display">
\frac{\vec{x}^TA\vec{x}}{\vec{x}^T\vec{x}}=\frac{\lambda_1x_1^2+\cdots+\lambda_nx_n^2}{x_1^2+\cdots+x_n^2}\leq\lambda_1</script><p>with equality holds if and only if $x_1\not= 0$ and $x_i=0$ for $i={2,\cdots,n}$, i.e. $\vec{x}$ is exactly an eigenvector of $\lambda_1$.</p>
<ol>
<li><p>Let $\vec{v}$ be get from $\vec{u}_n$ by convert each component into its absolute value (i.e. $\vec{v}=(|\vec{u}_n(1)|,|\vec{u}_n(2)|,\cdots,|\vec{u}_n(n)|)$)</p>
<p>From proof of 1. we can write $\lambda_n$ as</p>
<script type="math/tex; mode=display">
|\lambda_n|=|\frac{\vec{u}^T_nA\vec{u}_n}{\vec{u}_n^T\vec{u}_n}|=|\vec{u}^T_nA\vec{u}_n|\leq\sum_{i,j\in[n]}A(i,j)|\vec{u}_n(i)\vec{u}_n(j)|=|\frac{\vec{v}^TA\vec{v}}{\vec{v}^T\vec{v}}|\leq\lambda_1</script><p>We have used triangle inequality at the first inequality and the result of 1. at the second inequality.</p>
</li>
</ol>
<hr>
<p><strong>Propsition. Let G be a graph, and $\Delta (G)$ be the maximum degree and $d(G)$ be the average degree. Then we have </strong></p>
<script type="math/tex; mode=display">
d(G)\leq\lambda_1\leq\Delta (G)</script><hr>
<p><strong>Proof</strong></p>
<p>Note that, there exist $\vec{x}\not=\vec{0}$, s.t. $A\vec{x}=\lambda\vec{x}$ where A is the adjacency matrix.</p>
<script type="math/tex; mode=display">
\lambda_1=\sup\{\vec{x}^TA\vec{x}\Big|||\vec{x}||=1\ and\ \vec{x}\in\mathbb{R}^n\}</script><p>Let $\vec{x}_1=\frac{1}{\sqrt{n}}[\begin{matrix}1&amp;1&amp;\dots&amp;1\end{matrix}]^T$, then</p>
<script type="math/tex; mode=display">
\begin{aligned}\lambda_1&\geq \vec{x}_1^TA\vec{x}_1=\frac{1}{\sqrt{n}}[\begin{matrix}1&1&\dots&1\end{matrix}]A\frac{1}{\sqrt{n}}[\begin{matrix}1&1&\dots&1\end{matrix}]^T\\
&=\frac{1}{n}[\begin{matrix}1&1&\dots&1\end{matrix}][\begin{matrix}d(v_1)&d(v_2)&\cdots&d(v_n)\end{matrix}]^T\\
&=\frac{1}{n}\sum_{i=1}^nd(v_i)=d(G)\end{aligned}</script><p>For the upper bound, let $\vec{x}$ s.t. $A\vec{x}=\lambda_1\vec{x}$ where $\vec{x}=[\begin{matrix}x_1&amp;x_2&amp;\cdots&amp;x_n\end{matrix}]^T$</p>
<p>Let $x_i$ be the largest value among all components of $\vec{x}$. Then, </p>
<script type="math/tex; mode=display">
\lambda_1 x_i=\sum_{v_iv_j\in E(G)}x_j\leq\Delta(G)x_j</script><p>So $\lambda_1\leq\Delta (G)$ follows.</p>
<hr>
<p><strong>Corollary Let G be a k-regular graph. Then $\lambda_1(G)=k$</strong></p>
<p>A signed graph $(G,\sigma)$ is a weighted graph s.t. $\sigma:\ E(G)\to{-1,1}$</p>
<script type="math/tex; mode=display">
A(G,\sigma)=[a_{ij}]_{n\times n}\ where\ a_{ij}=\left\{\begin{aligned}&\sigma(v_iv_j),\quad v_iv_j\in E(G)\\&0,\quad otherwise\end{aligned}\right.</script><p>So $A(G,\sigma)$ is a symmetric real matrix.</p>
<p>We can assume that $\lambda_1(G,\sigma)\geq\lambda_2(G,\sigma)\geq\cdots\geq\lambda_n(G,\sigma)$, <font color='red'>but $\lambda_1(G,\sigma)\geq|\lambda_n(G,\sigma)|$ may not hold.</font></p>
<p><strong>Prop. Let $(G,\sigma)$ be a signed graph with maximum degree $\Delta (G)$. Then</strong></p>
<script type="math/tex; mode=display">
|\lambda(G,\sigma)|\leq\Delta(G)\ where\ \lambda(G,\sigma)\ is\ an\ eigenvalue\ of\ G</script><hr>
<p><strong>Proof</strong></p>
<p>Let $\vec{x}$ be an eigenvector of $\lambda$ s.t. $\lambda\vec{x}=A\vec{x}$.</p>
<p>Let $\vec{x}=[\begin{matrix}x_1&amp;x_2&amp;\cdots&amp;x_n\end{matrix}]^T$ and $x_i$ has the largest absolute value among all $x_j$’s.</p>
<p>Then </p>
<script type="math/tex; mode=display">
|\lambda x_i|=|(A\vec{x})_i|=|\sum_{v_iv_j\in E(G)}\sigma(v_iv_j)x_j|\leq\sum_{v_iv_j\in E(G)}|x_j|\leq\Delta(G)|x_i|</script><p>So $|\lambda|\leq\Delta(G)$</p>
<hr>
<p><strong>Thm A graph G is bipartite $\Leftrightarrow$ its spectrum is symmetric about the origin.</strong></p>
<font color='red'>(i.e. $\lambda_i$ is an eigenvalue of G $\Leftrightarrow$ $-\lambda_i$ is an eigenvalue of G)</font>

<hr>
<p><strong>Proof</strong></p>
<p>$\Rightarrow$ Assume that G is bipartite.Let A be The adjacency matrix of G.</p>
<script type="math/tex; mode=display">
A=\left[\begin{matrix}O&B\\B^T&O\end{matrix}\right]\ where\ B\ is\ the\ bipartite\ adjacency\ matrix.</script><p>Let $\lambda$ be an eigenvalue of G with $\vec{x}=(\begin{matrix}\vec{x}_1^T&amp;\vec{x}_2^T\end{matrix})^T$</p>
<p>Then</p>
<script type="math/tex; mode=display">
A\vec{x}=\left(\begin{matrix}O&B\\B^T&O\end{matrix}\right)\left(\begin{matrix}\vec{x}_1\\\vec{x}_2\end{matrix}\right)=\left(\begin{matrix}B\vec{x}_2\\B^T\vec{x}_1\end{matrix}\right)=\lambda\left(\begin{matrix}\vec{x}_1\\\vec{x}_2\end{matrix}\right)</script><p>Then</p>
<script type="math/tex; mode=display">
A\left(\begin{matrix}\vec{x}_1\\-\vec{x}_2\end{matrix}\right)=\left(\begin{matrix}O&B\\B^T&O\end{matrix}\right)\left(\begin{matrix}\vec{x}_1\\-\vec{x}_2\end{matrix}\right)=\left(\begin{matrix}-B\vec{x}_2\\B^T\vec{x}_1\end{matrix}\right)=-\lambda\left(\begin{matrix}\vec{x}_1\\-\vec{x}_2\end{matrix}\right)</script><p>So $-\lambda$ is also an eigenvalue of A.</p>
<p>$\Leftarrow$ Let $\lambda<em>1\geq\cdots\geq\lambda_n$ be all eigenvalues of G.<font color='red'>(i.e. $\lambda_i=-\lambda</em>{n-i+1}$)&lt;/font&gt;</p>
<p>For any positive integer k, the matrix $A^k$ has eigenvalues $\lambda_1^k,\lambda_2^k,\cdots,\lambda_n^k$</p>
<p>Because G has symmetric specturm, it follows that $\lambda_1^k+\cdots+\lambda_n^k=0$ if k is an odd integer.</p>
<script type="math/tex; mode=display">
0=\lambda_1^k+\cdots+\lambda_n^k=w_k(G)</script><font color='red'>$w_k(G)$ is the total number of close k-walks.</font>

<p>So every closed walk have an even length. Therefore G is bipartite.</p>
<hr>
<font color='red'>Problem: characterize graphs which satisfy # positive eigenvalues=# negative eigenvalues</font>
]]></content>
      <categories>
        <category>Graph Theory</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Operation Research</tag>
      </tags>
  </entry>
  <entry>
    <title>Lecture series on graph theory 8</title>
    <url>/2022/05/27/Graph8/</url>
    <content><![CDATA[<p><strong>Proof of the coloring-flow duality theorem</strong></p>
<span id="more"></span>
<p>$\Rightarrow$ Assume that G is face k-colorable (proper coloring)</p>
<p>We need to show that G has a nowhere-zero k-flow $(D,f)$</p>
<script type="math/tex; mode=display">
\begin{aligned}
(i.e. &f:E(G)\to\{-(k-1),-(k-2),\cdots,-1,1,\cdots,k-2,k-1\}\\& s,t,\forall v\in V(G),\sum_{e\in E^{+}(v)}f(e)=\sum_{e\in E^{-}(v)}f(e))
\end{aligned}</script><p>Let $F(G)$ be the set of all faces of G and let $c:F(G)\to[k]$ be a face coloring.</p>
<p>Assign an orientation $D$ to $E(G)$: each edge $e\in E(G)$ is oriented such that the face with a smaller color index is on the right side of the arc.</p>
<p><img src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220226/2022-05-27_121553.4l885wgltpq0.jpg" alt=""></p>
<p>Define a function $f:E(G)\to[k-1]$ such that $f(e)$ is the absolute value of the difference of the colors of two faces incident with e.</p>
<font color='blue'>**claim: $(D,f)$ is a nowhere-zero k-flow**</font>

<hr>
<p><strong><font color='blue'>Proof of claim:</font></strong></p>
<font color='blue'>Clearly, $0<f(e)<k$, because the smallest color index is 1 and the largest color index is k;and two faces share edges have different color indices.So f is nowhere-zero.</font>

<font color='blue'>Let v be vertex of G and $v_1,v_2,\cdots,v_d$ be all neighbors of v appearing around v in a clockwise order.Let $f_i$ be the face containing edges $vv_1$ and $vv_{i+1}$ . Note that, for any $i\not=j,f_i\not=f_j$ because G is 2-connected.</font>

<font color='blue'>Define</font>
$$
\textcolor{blue}{\epsilon_i=\left\{\begin{aligned}&-1,\quad if\ v\to v_i\ in\ D\\&1,\quad if\ v_i\to v\ in\ D
\end{aligned}\right.}
$$
<font color='blue'>Then, for each $i\in[d]$</font>
$$
\textcolor{blue}{c(f_i)=c(f_d)+\sum_{j=1}^i\epsilon_if(vv_j) \tag{*}}
$$
![](https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220226/2022-05-27_124414.4gsbkbgif9u0.jpg)
$$
\begin{aligned}&\textcolor{blue}{c(f_1)=c(f_d)}+\textcolor{red}{f(vv_1)}\\&\textcolor{blue}{c(f_2)=c(f_1)-f(vv_2)=c(f_d)+f(vv_1)-f(vv_2)=c(f_d)+\sum_{j=1}^2\epsilon_jf(vv_j)}\end{aligned}
$$
<font color='blue'>From (*), $c(f_i)=c(f_d)+\sum_{j=1}^i\epsilon_if(vv_j)$. It follows that</font>
$$
\textcolor{blue}{\sum_{j=1}^d\epsilon_jf(vv_j)=0\Rightarrow\sum_{e\in E^{+}(v)}f(e)=\sum_{e\in E^{-}(v)}f(e)}
$$

---

$\Leftarrow$ Assume that G has a nowhere-zero k-flow $(D,f)$. 

Define a map $c:F(G)\to\{1,2,\cdots,k-1\}$

Choose an arbitrary face $f_0$ and let $c(f_0)=1$. For each arc $e_i$ in D, let $f_i'$ and $f_i''$ be two faces incident with $e_i$. If one of  $f_i'$ and $f_i''$ is colored, then the color of another face is given by the following equality
$$
c(f_i'')=c(f_i')+f(e_i)(mod\ k)
$$
It suffices to show that the vertex coloring is well-defined.<font color ='red'>In other words, the process does not color one face by two or more different colors.</font>

<p>Let $f_1$ be uncolored face incident with two colored faces $f_2$ and $f_3$.Let $e_i$ be the edge on the boundary of $f_1$ and $f_i$ for $i=2,3$. Without loss of generality, let $f_i$ be on the left side of the arcs $e_2$ and $e_3$.</p>
<font color='blue'>**claim: $c(f_2)+f(e_2)\equiv c(f_3)+f(e_3)(mod\ k)$**</font>

<hr>
<font color='blue'>**Proof of claim:**</font>

<p><img src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20220226/2022-05-27_164800.1de6ecdbpaps.jpg" alt=""></p>
<font color='blue'>Consider the dual graph $G^\star$ of G.</font>

<font color='blue'>The vertex subset $X^\star=\{f\in V(G^\star)\big|f\in F(G)\ is\ colored\ already\}$ induces a connected subgraph of $G^\star$. Thus, there is a cycle $C^\star$ of $G^\star$ containing $f_1,f_2$ and $f_3$.The cycles $C^\star$ also contains the edge $f_1f_2$ and$f_1f_3$, $V(C^\star)\backslash \{f_1\}\subset X^\star$.</font>

<font color='blue'>Since all edges of G corresponding to the edge of $C^\star$​ separate G into two parts</font> <font color='red'>(i.e. these edges form an edge-cut)</font><font color='blue'>, Let X be the set of vertices in one part. It follows from a lemma that </font> 
$$
\textcolor{blue}{\sum_{e\in E^{+}(v)}f(e)-\sum_{e\in E^{-}(v)}f(e)=0}
$$
<font color='blue'>So the clain follows.</font>

<hr>
<p>This completes the whole proof.</p>
<font color='red'>Recall: Every Eulerian graph G has a cycle decomposition: edges of G can be decomposed into edge-disjoint cycles.</font>

<p>A cycle cover of a graph is a family of cycles which cover all edges of G.</p>
<p>A graph has a cycle cover $\Leftrightarrow$ it has even-subgraph cover.</p>
<p><strong>Thm If a graph G has k-even-subgraph cover, then G has a nowhere-zero $2^k$-flow</strong></p>
<hr>
<p><strong>Proof</strong></p>
<p>For each even-subgraph $H_i$, it has a 2-flow $(D,f_i)$.</p>
<p>So $(D,f)$ is a nowhere-zero $2^k$-flow where $f=\sum_{e\in E(G)}2^{i-1}f_i(e)$</p>
<hr>
<p><strong>(8-flow theorem,Jaeger) Every bridgeless graph has nowhere-zero 8-flow</strong></p>
<p><strong>(Splitting Lemma) Let G be a connected graph without cut-edge.If G has a vertex v of degree at least four. Then there are two edges $e_1$ and $e_2$ incident with v s.t. the resulting graph after splitting $e_1$ and $e_2$ from v remains to be connected and without cut-edge.</strong></p>
<font color='red'>(Cycle double cover conjecture,1970s) Every connected cubic graph without cut-edge has a family of cycles covering every edge exactly twice.</font>

<p>A proper k-edge-coloring of a graph G is a map $c:E(G)\to[k]$ s.t. $c(e)\not=c(e’)$ if $e$ and $e’$ have a common end vertex.</p>
<p><strong>Thm Every 3-edge-colorable cubic graph has a family of cycles which cover every edge exactly twice</strong></p>
<hr>
<p><strong>Proof</strong></p>
<p>Let $c:E(G)\to[3]$. Then $c^{-1}(1)\cup c^{-1}(2)$ is a family of cycles, $c^{-1}(1)\cup c^{-1}(3)$ is a family of cycles, $c^{-1}(2)\cup c^{-1}(3)$ is a family of cycles.</p>
<script type="math/tex; mode=display">
l_{e_1}=c^{-1}(1)\cup c^{-1}(2),l_{e_2}=c^{-1}(1)\cup c^{-1}(3),l_{e_3}=c^{-1}(2)\cup c^{-1}(3)</script><p>So $l<em>{e_1}\cup l</em>{e<em>2}\cup l</em>{e_3}$ is a family of cycles which cover every edge exactly twice.</p>
<hr>
<font color='blue'>(3-flow conjecture) Every 5-edge connected graph has a nowhere-zero 3-flow.</font>

<font color='red'>A graph is a k-edge-connected if for any two vertices x ang y, the graph has k edge-disjoint paths joining x and y.</font>

<font color='blue'>(Tutte-Nashwillam Theorem) Every 2k-edge-connected graph has a k edge-disjoint spanning trees.</font>

<font color='blue'>(Lovasz,Wu,Thomassen,Zhang,2012) Every 6-edge-connected graph has a nowhere-zero 3-flow.</font>

<font color='blue'>(5-flow conjecture.1950s) Every bridgeless graph has a nowhere-zero 5-flow</font>

<font color='blue'>(Seymour,1980) Every bridgeless graph has a nowhere-zero 6-flow.</font>

<font color='blue'>For cubic graph,cycle double cover conjecture$\approx$ the strong embedding conjecture</font>

<font color='blue'>(Strong Embedding Conjecture,1980s) Every 2-connected graph can be embedded on a closed surface such that every face is bounded by a cycle.</font>
]]></content>
      <categories>
        <category>Graph Theory</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Operation Research</tag>
      </tags>
  </entry>
  <entry>
    <title>Functional Analysis-A Quick Introduction to the Theory of Conjugate Convex Functions(1)</title>
    <url>/2023/08/08/functional-4/</url>
    <content><![CDATA[<h3 id="1-4-共轭凸函数-1"><a href="#1-4-共轭凸函数-1" class="headerlink" title="1.4 共轭凸函数(1)"></a>1.4 共轭凸函数(1)</h3><p>我们先从下半连续函数和凸函数开始讨论, 考虑定义在集合 $E$ 上, 取值在 $(-\infty,+\infty]$ 的函数 $\phi$, 我们给出一些记号如 $\phi$ 的定义域为 $D(\phi)={x\in E|\phi(x)&lt;+\infty}$, $\phi$ 的上图像为 $\text{epi}\ \phi={[x,\lambda]\in E\times\mathbb{R}|\phi(x)\leq \lambda}$, 其中 $\mathbb{R}=(-\infty,+\infty)$.<br><span id="more"></span><br>假设 $E$ 是拓扑空间, 定义 $\phi: E\to(-\infty,+\infty]$ 是下半连续函数, 若 $\forall \lambda\in\mathbb{R}$, 集合 $[\phi\leq\lambda]={x\in E|\phi(x)\leq\lambda}$ 是闭集. 下面列举一些下半连续函数的基本性质:</p>
<ul>
<li> $\phi$ 是下半连续函数, 那么其对应的上图像 $\text{epi}\ \phi$ 是 $E\times\mathbb{R}$ 上的闭集, 反之亦然.</li>
<li> $\phi$ 是下半连续函数, 则 $\forall x,\ \forall\epsilon>0$, 存在 $x$ 的领域 $V$, 使得 $\phi(y)\geq\phi(x)-\epsilon,\ \forall y\in V$, 反之亦然.</li>
<li>若 $\phi_1,\ \phi_2$ 是下半连续函数, 那么 $\phi_1+\phi_2$ 也是下半连续函数.</li>
<li>$\{\phi_i\}_{i\in I}$ 是一族下半连续函数, 那么 $\phi=\sup_{i\in I}\phi_i(x)$ 是下半连续函数</li>
<li>若 $E$ 为紧空间, 而 $\phi$ 是下半连续的, 则 $\phi$ 在 $E$ 上可以达到下确界, 也就是 $\exists x_0\in E$, 使得 $\phi(x_0)=\inf_E\phi$</li>
</ul>

<p>假设 $E$ 是向量空间, 定义 $\phi:E\to(-\infty,+\infty]$ 是凸函数, 若 $\phi$ 满足 $\phi(tx+(1-t)y)\leq t\phi(x)+(1-t)\phi(y),\ \forall x,y\in E,\ \forall t\in[0,1]$. 同样我们在下面列举一些凸函数的基本性质.</p>
<ul>
<li>若 $\phi$ 是凸函数, 则其对应的上图像 $\text{epi}\ \phi$ 是凸集. 反之亦然</li>
<li>若 $\phi$ 是凸函数, 则 $\forall \lambda\in\mathbb{R}$</li>
<li>若 $\phi_1,\ \phi_2$ 是凸函数, 则 $\phi_1+\phi_2$ 是凸函数</li>
<li>若 $\{\phi_i\}_{i\in I}$ 是一族凸函数, 则 $\phi(x)=\sup_{i\in I}\phi_i$ 是凸函数</li>
</ul>

<p>假设 $E$ 是赋范线性空间, 设给定 $\phi:E\to(-\infty,+\infty]$ 满足 $\phi\not\equiv+\infty$, 即 $D(\phi)\not=\empty$, 记 $\phi$ 的共轭函数<font color='red'>(Conjugate function)</font> $\phi^\star: E^\star\to(-\infty,+\infty]$,</p>
<script type="math/tex; mode=display">
\phi^\star(f)=\sup_{x\in E}\left\{\langle f,x\rangle-\phi(x)\right\},\ (f\in E^\star)</script><font color='red'>$\big($从一维的角度来看, $\phi^\star$ 实际上指的是 $\langle f,x\rangle$ 和 $\phi(x)$ 两图像中最大的距离$\big)$</font>

<p>上面定义的共轭函数 $\phi^\star$ 是在 $E^\star$ 上的下半连续凸函数, 下面我们给出相关证明,<br><strong>Proof</strong> 我们先考虑其凸性, 在 $\forall f_1,\ f_2\in E^\star,\ t\in[0,1]$ 的情况下,</p>
<script type="math/tex; mode=display">
\begin{aligned}
\phi^\star
\end{aligned}</script>]]></content>
      <categories>
        <category>Functional Analysis</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Functional Analysis</tag>
      </tags>
  </entry>
  <entry>
    <title>Functional Analysis—Hahn-Banach Theorem</title>
    <url>/2023/06/19/functional-1/</url>
    <content><![CDATA[<h3 id="1-1-Hahn-Banach定理的解析形式—线性泛函延拓"><a href="#1-1-Hahn-Banach定理的解析形式—线性泛函延拓" class="headerlink" title="1.1 Hahn-Banach定理的解析形式—线性泛函延拓"></a>1.1 Hahn-Banach定理的解析形式—线性泛函延拓</h3><p><strong>Theorem 1.1 (H-B定理解析形式)</strong>$\quad$ 设映射 $p:E\to\mathbb{R}$ 满足</p>
<script type="math/tex; mode=display">
\begin{align}
&p(\lambda x)=\lambda p(x),\ \forall x\in E ,\ \lambda>0\\
&p(x+y)\leq p(x)+p(y),\ \forall x,y\in E
\end{align}</script><p>此外, $G$ 为 $E$ 上的线性子空间以及线性泛函 $g:G\to\mathbb{R}$ 满足</p>
<script type="math/tex; mode=display">
\begin{align}
g(x)\leq p(x),\ \forall x\in G
\end{align}</script><p>那么存在 $E$ 上的线性泛函 $f$ 延拓 $g$, 即 $f(x)=g(x),\ \forall x\in G$ 且成立 $f(x)\leq p(x),\ \forall x\in E$.<br><span id="more"></span></p>
<p><strong>Zorn 引理</strong><br>在介绍 Zorn 引理之前, 我们先介绍一些后续将会用到的符号.</p>
<p>设 $(P,\leq)$ 是一个有序集(偏序集), 我们称子集 $Q\subset P$ 完全有序, 若对于 $Q$ 中任意一对 $a,b$ 有序关系 $a\leq b$, $b\leq a$ 或者二者同时成立.</p>
<p><strong><font color='red'>Remark 1.</font></strong> <font color='red'>完全有序指集 $Q$ 中所有元素都可进行比较序关系,例如数集</font></p>
<p>设子集 $Q\subset P$, 称 $c\in P$ 是 $Q$ 的上界, 如果 $\forall x\in Q$ 都有 $x\leq c$ 成立. 称 $m\in P$ 是 $P$ 的极大元, 如果不存在 $P$ 中的元素 $x$ 满足 $m\leq x$, 除了 $m=x$.</p>
<p><strong><font color='red'>Remark 2.</font></strong> <font color='red'>我们上面定义的极大元和最大元是不一样的, 具体的差异是, 极大元指的是在能够比较的元素之中没有比他大的元素, 而最大元则要求他能和全部元素可比且没有比他大的元素</font></p>
<p>我们称集合 $P$ 是诱导的 $(\text{inductive})$, 如果 $P$ 的任意完全有序子集均有上界 </p>
<p><strong>Zorn Lemma</strong> 任意非空有序(偏序)的诱导集合有极大元</p>
<p><strong>Proof of Theorem 1.1</strong> </p>
<p><strong><font color='red'>Key:</font></strong> <font color='red'>定义一个集合 $P$ 和其上的偏序关系 $\leq$, 证明其是诱导的, 构造其极大元.</font></p>
<p>考虑这样的集合</p>
<script type="math/tex; mode=display">
P=\left\{h:D(h)\subset E\to\mathbb{R}\left|\begin{aligned}&D(h)\ \text{is a linear subspace of}\ E\\&h\ \text{is linear},\ G\subset D(h)\\&h\ \text{extends}\ g,\ \text{and}\ h(x)\leq p(x),\ \forall x\in D(h)\end{aligned}\right.\right\}</script><p>在 $P$ 上我们赋予偏序关系 $\leq$, 即</p>
<script type="math/tex; mode=display">
h_1\leq h_2\Leftrightarrow D(h_1)\subset D(h_2),\ h_2\ \text{延拓}\ h_1.</script><p>显然 $P$ 非空, 因为 $g\in P$. </p>
<p>下面我们要说明 $P$ 是一个诱导集, 也就是我们要说明任意一个 $P$ 的完全有序子集都有上界.</p>
<p>我们假设 $Q\subset P$ 是一个完全有序集合, 我们可以记 $Q={h<em>i}</em>{i\in I}$ ($I$ 是指标集), 我们定义一个线性泛函 $h$ 满足</p>
<script type="math/tex; mode=display">
D(h)=\bigcup_{i\in I} D(h_i),\quad h(x)=h_i(x),\ \text{if}\ x\in D(h_i)</script><p><strong><font color='red'>Remark 3.</font></strong> <font color='red'>对于定义的线性泛函 $h$ 是否是良定义的, 我们给出一定的说明. 如果 $D(h_1)\bigcap D(h_2)\not=\emptyset$, 因为 $Q$ 是完全有序的, 因此我们不妨假设序关系 $h_1\leq h_2$ 成立, 故 $h_2$ 延拓了 $h_1$, 即 $h_2(x)=h_1(x),\ \forall x\in D(h_2)\bigcap D(h_1).$</font></p>
<p>显然 $h\in P$ 且 $h$ 是 $Q$ 的上界(指定义的伴序关系下的上界). 因此根据 Zorn Lemma 知, 我们构造的 $P$ 存在极大元, 不妨设其为 $f$. 下面我们证明 $D(f)=E$, 我们采用反证法的技巧.</p>
<p>如果 $D(f)\not=E$, 也就是说存在 $x_0\in E$ 但是 $x_0\not\in D(f)$. 我们构造一个 $E$ 的子集 $D(h)=D(f)+\mathbb{R} x_0$, 其对应的线性泛函是 $h$, 其满足</p>
<script type="math/tex; mode=display">
h(x+tx_0)=f(x)+t\alpha,\ (t\in \mathbb{R},\ \forall x\in D(f))</script><p>其中的常数 $\alpha$ 我们将在后续讨论中给出取值方法. 我们为了推出矛盾, 要验证 $h\in P$, 也就是通过选取 $\alpha$ 来保证 $f(x)+t\alpha\leq p(x+tx_0),\ \forall t\in \mathbb{R},\ \forall x\in D(f)$ 成立.</p>
<p>由 (1) 式知, 我们只需要保证下式成立即可,</p>
<script type="math/tex; mode=display">
\left\{\begin{aligned}
&f(x)+\alpha\leq p(x+x_0)\\
&f(x)-\alpha\leq p(x-x_0)
\end{aligned}\right.</script><p>由于二者等价性比较显然, 我们隐去不谈. 根据上式知, 我们选取 $\alpha$ 满足 <script type="math/tex">\sup_{y\in D(f)}\{f(y)-p(y-x_0)\}\leq\alpha\leq\inf_{x\in D(f)}\{p(x+x_0)-f(x)\}</script><br>下面我们只用说明这样的 $\alpha$ 是存在的,</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\qquad f(x)+f(y)=f(x+y)\leq p(x+y)\leq p(y-x_0)+p(x+x_0)\\
&\Rightarrow f(y)-p(y-x_0)\leq p(x+x_0)-f(x)
\end{aligned}</script><p>这代表 $\alpha$ 是存在的, 因此 $h\in P$ 且 $f\leq h$, 这与 $f$ 是极大元矛盾. 因此 $D(f)=E.$</p>
<p>考虑 H-B 定理的应用, 考虑集合 $E$ 是赋范向量空间(n. v. s.) </p>
<p>范数本质上也是一种映射 $\Vert\cdot\Vert:E\to\mathbb{R}$ 满足</p>
<script type="math/tex; mode=display">
\begin{align}
&\Vert x+y\Vert\leq\Vert x\Vert+\Vert y\Vert,\ \forall x,y\in E\\
&\Vert\alpha x\Vert=|\alpha|\Vert x\Vert,\ \alpha\in\mathbb{R},\ \forall x\in E\\
&\Vert x\Vert=0\Rightarrow x=0(\text{此处 }0\text{ 并不是简单的数,而是向量空间的零元})
\end{align}</script><p>我们记 $E^\star$ 为 $E$ 的对偶空间, 即 $E$ 上定义的所有连续线性泛函构成的空间, 同样我们可以构造 $E^\star$ 上的范数为 </p>
<script type="math/tex; mode=display">
\Vert f\Vert_{E^\star}=\sup_{\scriptsize    \begin{aligned}&\Vert x\Vert=1\\&x\in E\end{aligned}}|f(x)|=\sup_{\scriptsize    \begin{aligned}&\Vert x\Vert=1\\&x\in E\end{aligned}}f(x)</script><p>$\forall f\in E^\star, x\in E$, 我们称 $\langle f,x\rangle=f(x)$ 且称 $\langle\cdot,\cdot\rangle$ 是定义在对偶集 $E,E^\star$ 的数量积.</p>
<p><strong>Proposition</strong> $E^\star$ 是一个 Banach 空间, 尽管我们并没有给出 $E$ 的完备性.</p>
<p><strong>Proof</strong> 我们要证明 $E^\star$ 是 Banach 空间, 等价于证明 $\forall {f_n}\subset E^\star$ 是 Cauchy 列, 则 $\exists f\in E^\star,\ f_n\to f$.</p>
<p>$\forall x\in E$, 有 $|f_n(x)-f_m(x)|\leq\Vert f_n-f_m\Vert\cdot\Vert x\Vert$, 且由于 $f_n$ 是 $E^\star$ 上的 Cauchy 列, 故 $\Vert f_n-f_m\Vert\to 0,\ n,m\to \infty$. 因此 $\forall x\in E$, 有 $|f_n(x)-f_m(x)|\to 0,\ n,m\to \infty$, 即 $f_n(x)$ 是 $\mathbb{R}$ 上的 Cauchy 列, $f_n(x)$ 收敛, 不妨我们记其收敛到 $f(x)$.</p>
<p>下面我们仅需要说明 $f_n$ 在 $E^\star$ 上是收敛到 $f$ 的, 也就是说, $\forall \epsilon&gt;0,\exists N&gt;0,\forall n&gt;N,\Vert f_n-f\Vert\leq\epsilon.$ 显然 $f(x)$ 是线性泛函, 由上确界的定义可得</p>
<script type="math/tex; mode=display">
\forall \epsilon>0,\exists x_0\in E,\ \Vert x_0\Vert=1,\ |f_n(x_0)-f(x_0)|\geq\Vert f_n-f\Vert-\epsilon.</script><p>两边取上极限得</p>
<script type="math/tex; mode=display">
\overline{\lim_{n\to\infty}}\Vert f_n-f\Vert\leq\lim_{n\to\infty}|f_n(x_0)-f(x_0)|+\epsilon=\epsilon</script><p>因此证毕.</p>
<p><strong>Corollary 1</strong> 记 $G$ 是 $E$ 的子向量空间, 若 $g:G\to \mathbb{R}$ 是连续线性泛函, 那么在 $E^\star$ 中存在一个线性泛函 $f$ 延拓了 $g$ 且满足</p>
<script type="math/tex; mode=display">
\Vert f\Vert_{E^\star}=\sup_{\scriptsize    \begin{aligned}&\Vert x\Vert=1\\&x\in G\end{aligned}}|g(x)|=\Vert g\Vert_{G^\star}</script><p><strong>Proof.</strong> 我们令 $p(x)=\Vert g\Vert<em>{G^\star}\Vert x\Vert$ , 应用 H-B 定理知有 $f(x)\leq p(x)=\Vert g\Vert</em>{G^\star}\Vert x\Vert,\ \forall x\in E$, 因此 $\Vert f\Vert<em>{E^\star}\leq\Vert g\Vert</em>{G^\star}$. 同时有下式成立</p>
<script type="math/tex; mode=display">
\Vert f\Vert_{E^\star}=\sup_{\scriptsize    \begin{aligned}&\Vert x\Vert=1\\&x\in E\end{aligned}}|f(x)|\geq\sup_{\scriptsize    \begin{aligned}&\Vert x\Vert=1\\&x\in G\end{aligned}}|g(x)|=\Vert g\Vert_{G^\star}</script><p>综上所述, $\Vert f\Vert<em>{E^\star}=\Vert g\Vert</em>{G^\star}$.</p>
<p><strong>Corollary 2</strong> $\forall x<em>0\in E,\ \exists f_0\in E^\star$ 使得 $\Vert f_0\Vert</em>{E^\star}=\Vert x_0\Vert_E$ 且 $\langle f_0,x_0\rangle=\Vert x_0\Vert^2$.</p>
<p>Proof. 考虑 $G=\mathbb{R} x<em>0$ 和 $g(tx_0)=t\Vert x_0\Vert^2$. 下我们说明 $\Vert g\Vert</em>{G^\star}=\Vert x_0\Vert^2$, 依据定义可立马得到,</p>
<script type="math/tex; mode=display">
\Vert g\Vert_{G^\star}=\sup_{\scriptsize    \begin{aligned}&\Vert x\Vert=1\\&x=tx_0\end{aligned}}|g(tx_0)|=\sup_{\scriptsize    \begin{aligned}&\Vert x\Vert=1\\&x=tx_0\end{aligned}}t\Vert x_0\Vert^2=\Vert x_0\Vert</script><p>根据 Corollary 1的结果, 存在 $f0\in E^\star$ 满足 $\Vert f<em>0\Vert{E^\star}=\Vert g\Vert</em>{G^\star}=\Vert x_0\Vert.$ 和 $\langle f_0,x_0\rangle=f_0(x_0)=g(x_0)=\Vert x_0\Vert^2.$</p>
<p><strong><font color='red'>Remark 4.</font></strong> <font color='red'>上面我们讨论的$f_0$ 并不是唯一的. 只有当 $E^\star$ 严格凸, 例如当 $E$ 是 Hilbert 空间或者 $E$ 是 $L^p$ 空间$(1&lt;p&lt;\infty)$, $f_0$唯一. 记 $\forall x_0\in E, F(x_0)={f_0\in E^\star|\Vert f_0\Vert=\Vert x_0\Vert,\ \langle f_0,x_0\rangle=\Vert x_0\Vert^2}$. 一般而言, 映射 $d: x_0\to F(x_0)$ 是多值映射,\ 我们称映射 $d$ 为 $E$ 到 $E^\star$ 的对偶映射.</font></p>
<p><strong><font color='red'>Remark 5.</font></strong> <font color='red'>我们称赋范向量空间 $E$ 是严格凸的, 如果 $\forall x,y\in E,\ \Vert x\Vert=\Vert y\Vert=1,\ x\not=y$, 有$\Vert tx+(1-t)y\Vert&lt;1,\ \forall t\in(0,1)$.</font></p>
<p><strong>Corollary 3</strong> $\forall x\in E$ 有 <script type="math/tex">\Vert x\Vert=\sup_{\scriptsize \begin{aligned}&\Vert f\Vert\leq1\\&f\in E^\star\end{aligned}}|\langle f,x\rangle|=\max_{\scriptsize \begin{aligned}&\Vert f\Vert\leq1\\&f\in E^\star\end{aligned}}|\langle f,x\rangle|</script>.</p>
<p><strong>Proof.</strong> 若 $x\not=0$, 显然有 $|f(x)|\leq\Vert f\Vert\Vert x\Vert$, 也就是</p>
<script type="math/tex; mode=display">
\sup_{\scriptsize \begin{aligned}&\Vert f\Vert\leq1\\&f\in E^\star\end{aligned}}|\langle f,x\rangle|\leq\Vert x\Vert</script><p>根据 Corollary 2的结果知, $\exists f_0\in E^\star$ 满足 $\Vert f_0\Vert=\Vert x\Vert,\ \langle f_0,x\rangle=\Vert x\Vert^2$. 我们记 $f_1=f_0/\Vert x\Vert$, 则 $\Vert f_1\Vert=1$ 且 $\langle f_1,x\rangle=\Vert x\Vert$.</p>
]]></content>
      <categories>
        <category>Functional Analysis</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Functional Analysis</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux-Shell常用指令</title>
    <url>/2024/03/30/linux-1/</url>
    <content><![CDATA[<h1 id="Shell-基本命令"><a href="#Shell-基本命令" class="headerlink" title="Shell 基本命令"></a>Shell 基本命令</h1><p>Bash提供了命令行补全的特性.我们可以利用Tab键来完成命令以及文件名的自动补全.如果以已输入的字符开头的文件不止一个,那么连续输入两次Tab键,shell将会以列表的形式给出所有以输入字符开头的文件名.</p>
<p>同样我们可以补全Linux命令,这是因为Linux的命令本质上是一些可执行文件,所以可以认为命令补全和文件名补全其实是同一件事.</p>
<p>此外,Shell在查找文件中存在通配符的专用符号,其为*,?,[].这些通配符可以搜索并匹配文件名的一部分,从而可以做到批量检索文件.</p>
<span id="more"></span>
<ol>
<li><p>*用于匹配文件名中任意长度的字符串.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> *.cpp <span class="comment">## 检索以.cpp结尾的文件</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>?和*类似,但是与*匹配任意长度的字符串不同,?只能匹配一个字符串</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> text? <span class="comment">## 检索文件名中以text开头并且后面接一个字符的文件.</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>[]用于匹配所有出现在方括号内的字符.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> text[1A]  <span class="comment">## 用于列出以text开头而仅以1或者A结束的文件</span></span></span><br></pre></td></tr></table></figure>
<p>如果需要查找多个连续字符范围的,可以利用短线-来指定一个字符集范围.所有包含在上下界之间的字符都会被匹配.同样可对字母操作,如在ASC码中,A-Z可以包含所有的大写字母.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> text[1-3] <span class="comment">## 用于列出以text开头而仅以1-3中字符结束的文件</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> text[A-Z] <span class="comment">## 用于列出以text开头而仅以大写字母结束的文件</span></span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>虽然我们上面的演示都以通配符位于文件末,但实际上通配符的位置是任意的.并且可以随意搭配使用.</p>
<p><a id="org48c8384"></a></p>
<h2 id="pwd-显示当前目录"><a href="#pwd-显示当前目录" class="headerlink" title="pwd: 显示当前目录"></a>pwd: 显示当前目录</h2><p>pwd命令会显示当前所在的位置,也就是工作目录.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> /usr/local/bin  <span class="comment">## 进入/usr/local/bin目录</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">pwd</span>                <span class="comment">## 显示当前所在位置</span></span></span><br><span class="line">/user/local/bin</span><br></pre></td></tr></table></figure>
<p><a id="org0a74477"></a></p>
<h2 id="cd-改变目录"><a href="#cd-改变目录" class="headerlink" title="cd: 改变目录"></a>cd: 改变目录</h2><p>cd是Linux文件系统在不同文件夹之间转移的常用指令.其后一般都加上路径名作为参数表示跳转到相应的位置,但其有一些特殊的路径符号来简化跳转特定文件夹的指令.</p>
<ol>
<li><p>/表示根目录,不管在什么目录下,命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> / <span class="comment">## 跳转到根目录</span></span></span><br></pre></td></tr></table></figure>
<p>都会快速跳转到根目录下.</p>
</li>
<li><p>..表示当前目录的上一级目录,例如如果现在工作目录都是/usr/bin</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> .. <span class="comment">## 跳转到上一级目录</span></span></span><br></pre></td></tr></table></figure>
<p>其会跳转到上一级目录即/usr中.</p>
</li>
<li><p>.表示当前目录,我们如果需要跳转到当前目录的某个文件夹中可以用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> ./xxx  <span class="comment">## 跳转到同级目录中的下级目录</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>~表示用户主目录,其一般是/home/下名称为用户名的文件夹,在其中存储对应用户的数据和设置.同样我们可以用cd命令不加任何参数来跳转到用户主目录.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> ~  <span class="comment">## 跳转到用户主目录</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span>    <span class="comment">## 跳转到用户主目录</span></span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><a id="orge55b477"></a></p>
<h2 id="ls-列出目录内容"><a href="#ls-列出目录内容" class="headerlink" title="ls: 列出目录内容"></a>ls: 列出目录内容</h2><p>ls命令实际上是list的简化形式.list的用法十分多,但其基本语法是</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls [OPTION]... [FILE]... ## ls命令的基本形式</span><br></pre></td></tr></table></figure>
<p>最简单的情况,我们直接在任意工作目录下输入ls命令,用于列出当前目录下所有文件和子目录.为了区分文件目录和文件,linux系统会用不同颜色来标注不同的类型.由于不同的系统对于颜色渲染不太一样,甚至可能没有颜色,我们可以用-F参数的ls命令,-F会在每个目录后面加上/,在可执行文件后加*,在链接文件后加@.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -F <span class="comment">##列出文件并且在列出的文件名称后加一符号</span></span></span><br></pre></td></tr></table></figure>
<p>虽然我们可以用ls列出当前目录下的所有内容,但实际上有很多的名称以.开头的文件并未展示,我们称这类文件为隐含文件,在默认情况下是不会展示的.我们可以用参数-a来显示所有的文件.对于命令的参数是可以组合使用的,并且制定多个选项只需要用一个短线即可.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -a  <span class="comment">## 列出所有文件及目录(以.开头的隐含文件也会被列出)</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -aF <span class="comment">## 列出所有文件和目录的同时加上一个后缀符号</span></span></span><br></pre></td></tr></table></figure>
<p>ls另外一个比较常见的参数是-l,这个选项可以用来查看文件的各种属性,</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l  <span class="comment">## 列出所有文件和目录以及其对应的属性</span></span></span><br><span class="line">  总计 152</span><br><span class="line">  drwxr-xr-x  2 lyd  lyd   4096  2月  5 09:49  公共</span><br><span class="line">  drwxr-xr-x  2 lyd  lyd   4096  2月  5 09:49  模板</span><br><span class="line">  drwxr-xr-x  2 lyd  lyd   4096  2月  5 09:49  视频</span><br><span class="line">  drwxr-xr-x  3 lyd  lyd   4096  2月 25 20:55  图片</span><br><span class="line">  drwxr-xr-x  2 lyd  lyd   4096  2月  5 09:49  文档</span><br><span class="line">  drwxr-xr-x  2 lyd  lyd   4096  3月 14 15:39  下载</span><br><span class="line">  drwxr-xr-x  2 lyd  lyd   4096  2月  5 09:49  音乐</span><br><span class="line">  drwxr-xr-x  2 lyd  lyd   4096  2月  5 09:49  桌面</span><br></pre></td></tr></table></figure>
<p>这一共有九个不同的信息栏,从左到右依次表示,</p>
<ol>
<li>文件的权限标志(后续会进一步讨论其含义)</li>
<li>文件连接个数(同上)</li>
<li>文件所有者的用户名</li>
<li>该用户所在的用户组祖名(后续会讨论)</li>
<li>文件的大小</li>
<li>最后一次修改时的月份</li>
<li>最后一次修改的日期</li>
<li>最后一次修改的时间</li>
<li>文件名</li>
</ol>
<p>ls命令后接路径名,可以直接查看子目录的内容,</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> /etc/init.d/ <span class="comment">## 用来查看/etc/init.d/的内容</span></span></span><br></pre></td></tr></table></figure>
<p>除了ls命令可以列出目录,我们也可以用windows系统常用的dir命令来列出,但其功能比ls要少.我们也可以用vdir来代替ls -l来列出目录和文件的完整信息.但由于ls的功能明显更为强大,我们就不再多介绍dir和vdir的用法.</p>
<p><a id="org824b1c7"></a></p>
<h2 id="cat-和-more-查看文本文件"><a href="#cat-和-more-查看文本文件" class="headerlink" title="cat 和 more: 查看文本文件"></a>cat 和 more: 查看文本文件</h2><p>cat命令用于查看文件内容(一般是文本文件,如果打开的是PDF或者其他形式的文件会以文本文件的形式打开),后跟文件名作为参数.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> xxx <span class="comment">## 查看文件内容</span></span></span><br></pre></td></tr></table></figure>
<p>cat后面的文件名参数可以添加多个文件名,同样也可以用通配符来批量查看文件.</p>
<p>为了调试方便,我们可以用-n参数来在展示的文本文件形式的每行前面显示行号</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> -n xxxx <span class="comment">## 查看文件内容的同时显示行号</span></span></span><br></pre></td></tr></table></figure>
<p>但是当我们打开多个文件的时候,用-n参数并不会智能地区分每个文件的终止,而是连续的对行号进行递增编号.</p>
<p>但由于cat命令会将文件的内容全部展示在shell命令行之上,对于内容较多的文件,这样的打开方式并不合适.因此我们可以用more命令来一页页的显示文章内容,</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">more XXX <span class="comment">## 以分页的形式展示文件内容</span></span></span><br><span class="line">....</span><br><span class="line">--More-- (75%) </span><br></pre></td></tr></table></figure>
<p>more命令会在最后显示一个百分比,其表示已显示内容占整个文件的比例.我们可以用空格键向下翻一页,用Enter则可以向下滚动一行,用Q退出文本文件展示.</p>
<p>more命令和cat一样可以添加多个文件名,也可以通配符来批量查看文件.</p>
<p><a id="orge830626"></a></p>
<h2 id="head-和-tail-查看文件的开头和结尾"><a href="#head-和-tail-查看文件的开头和结尾" class="headerlink" title="head 和 tail: 查看文件的开头和结尾"></a>head 和 tail: 查看文件的开头和结尾</h2><p>head和tail用于展示文件的开头和结尾.我们可以用-n参数来修改展示的行数,如果我们不加-n命令手动修改展示行数,那么会默认展示10行的内容.head命令的默认输出是包括输出文件名,但不会计入展示文件开头的行数,我们可以用-q参数来取消输出文件名.不仅如此,head后面还可以接多个文件名,用于批量展示多个文件的开头和结尾.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">head</span> -n k xxx <span class="comment">## 展示文件前k行,如果没有-n参数,默认展示文件的前10行</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">head</span> -q xxx <span class="comment">## 不展示文件名</span></span></span><br></pre></td></tr></table></figure>
<p>tail和head的用法完全一致.</p>
<p><a id="org41780dc"></a></p>
<h2 id="less-更好的文本阅读工具"><a href="#less-更好的文本阅读工具" class="headerlink" title="less: 更好的文本阅读工具"></a>less: 更好的文本阅读工具</h2><p>less和前面提到的more十分类似,都不能对文本文件进行修改,也支持打开多个文本文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">less ~/.bashrc <span class="comment">## 用less查看文件</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">~/.bashrc: executed by bash(1) <span class="keyword">for</span> non-login shells.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">see /usr/share/doc/bash/examples/startup-files (<span class="keyword">in</span> the package bash-doc)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="keyword">for</span> examples</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">If not running interactively, don<span class="string">&#x27;t do anything</span></span></span><br><span class="line">case $ - in</span><br><span class="line">    *i*) ;;</span><br><span class="line">      *) return;;</span><br><span class="line">esac</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">don&#x27;</span>t put duplicate lines or lines starting with space <span class="keyword">in</span> the <span class="built_in">history</span>.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">See bash(1) <span class="keyword">for</span> more options</span></span><br><span class="line">HISTCONTROL=ignoreboth</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">append to the <span class="built_in">history</span> file, don<span class="string">&#x27;t overwrite it</span></span></span><br><span class="line">shopt -s histappend</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">for setting history length see HISTSIZE and HISTFILESIZE in bash(1)</span></span></span><br><span class="line">HISTSIZE=1000</span><br><span class="line">HISTFILESIZE=2000</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">check the window size after each command and, if necessary,</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">update the values of LINES and COLUMNS.</span></span></span><br><span class="line">:</span><br></pre></td></tr></table></figure>
<p>在屏幕的末尾会有一个冒号,其表示等待用户输入命令.在此我们罗列常用的移动命令,</p>
<ul>
<li><SPC> 向下滚动一页</li>
<li><Enter> 向下滚动一行</li>
<li>b 向上翻一页</li>
<li>y 向上滚动一行</li>
<li>d 向下翻半页</li>
<li>u 向上翻半页</li>
</ul>
<p>在less查看的文本文件中,我们还可以用/跟上想要查找的内容,来实现对文本内容的检索,less会把第一个搜索目标高亮显示,如果我们还需要查找相同内容,我们只需要用n来跳转到下一个搜索目标,同样如果我们需要跳转到前一次的搜索结果我们可以用N来跳转.</p>
<p>实际上/并不是全文检索,而是以光标为基准向后搜索字符串,相反我们可以用?来以光标为基准向前搜索字符串.</p>
<p>由于less的用法较多,可以在冒号后接h来打开less自带的帮助文档查看指令及其作用.</p>
<p>为了展示更多的文件信息,我们可以用-M来展示更多的文件信息,</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">  $ </span><span class="language-bash">less -m ~/.bashrc</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">~/.bashrc: executed by bash(1) <span class="keyword">for</span> non-login shells.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">see /usr/share/doc/bash/examples/startup-files (<span class="keyword">in</span> the package bash-doc)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="keyword">for</span> examples</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">If not running interactively, don<span class="string">&#x27;t do anything</span></span></span><br><span class="line">case $ - in</span><br><span class="line">    *i*) ;;</span><br><span class="line">      *) return;;</span><br><span class="line">esac</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">don&#x27;</span>t put duplicate lines or lines starting with space <span class="keyword">in</span> the <span class="built_in">history</span>.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">See bash(1) <span class="keyword">for</span> more options</span></span><br><span class="line">HISTCONTROL=ignoreboth</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">append to the <span class="built_in">history</span> file, don<span class="string">&#x27;t overwrite it</span></span></span><br><span class="line">shopt -s histappend</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">for setting history length see HISTSIZE and HISTFILESIZE in bash(1)</span></span></span><br><span class="line">HISTSIZE=1000</span><br><span class="line">/home/lyd/.bashrc lines 1-19/114 15%</span><br></pre></td></tr></table></figure>
<p>less在输出的底部显示了文件名,当前行数,总行数以及所占百分比.最后可以用Q推出less程序.</p>
<p><a id="org6891801"></a></p>
<h2 id="grep-查找文件内容"><a href="#grep-查找文件内容" class="headerlink" title="grep: 查找文件内容"></a>grep: 查找文件内容</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep [OPTIONS] PATTERN [FILE...]  ## grep一般形式</span><br></pre></td></tr></table></figure>
<p>如果我们想在文件A中查找包含test的行,可以用如下命令,</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">grep <span class="built_in">test</span> A</span></span><br></pre></td></tr></table></figure>
<p>从上面的命令我们可以看出grep后面接两个不同类型的参数,第一个是被搜索的关键词,也称之为模式,第二个则是所搜索的文件.grep会将文件中出现关键词的行输出,并且grep可指定多个文件来搜索.另外我们用grep查找的是关键词,对于查找如Debian Ubunut这样的关键词,我们需要用单引号来将空格包含在关键词中,不然grep会认为关键词为Debian,在文件名为Ubuntu的文件中查找.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">grep <span class="string">&#x27;Debian Ubuntu&#x27;</span> linux  <span class="comment">##在linux文件中查找关键词 Debian Ubuntu</span></span></span><br></pre></td></tr></table></figure>
<p>我们列出一些常用的grep命令选项,</p>
<ul>
<li>-i 忽略大小写进行匹配</li>
<li>-r 进行递归查找子目录中的文件</li>
<li>-l 仅输出存在匹配的文件名</li>
<li>-c 输出匹配的行数</li>
<li>-v 反向查找,只打印不匹配的行</li>
</ul>
<p>grep实际上是以正则表达式的形式对文件进行查找,针对扩展的正则表达式,我们可以用egrep来查找.</p>
<p><a id="org676ae04"></a></p>
<h2 id="find-文件查找"><a href="#find-文件查找" class="headerlink" title="find: 文件查找"></a>find: 文件查找</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find [OPTION] [path...] [expression] ## find命令的基本语法</span><br></pre></td></tr></table></figure>
<p>find命令需要一个路径名作为查找范围,find会深入该路径中的每个子目录中寻找,如果我们指定的路径名为/,那么就会在整个文件系统中搜索.下给出一个find命令的实例,</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">find /usr/bin -name zip -<span class="built_in">print</span> <span class="comment">##在/usr/bin的目录下查找zip</span></span></span><br><span class="line">/usr/bin/zip</span><br></pre></td></tr></table></figure>
<p>这里的/usr/bin就是find的查找范围,-name指定了查找条件以文件名为基准,此处支持用通配符*和?.-print表示将结果输出到屏幕,实际上可以不需要加这个动作指令,find会默认将其输出.值得注意的是find输出的结果是文件的绝对路径.</p>
<p>我们在此罗列find常用的查找条件的参数,</p>
<ul>
<li>-name pattern: 按照文件名查找,支持使用通配符</li>
<li>-size [+-]size[cwbkMG]: 按文件大小查找,支持使用+或-来表示大于或小于指定大小,单位可以是c(字节),w(字数),b(块数),k(KB),M(MB)或G(GB).</li>
<li>-mtime days: 按修改时间查找,支持使用+或-表示在指定天数前或后,days是一个整数表示天数</li>
<li>-user username: 按照文件所有者查找</li>
<li>-group groupname: 按文件所属组查找</li>
<li>-type type: 按照文件类型查找,type的参数含义如下表所示</li>
</ul>
<div align="center">


<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">



<colgroup>
<col  class="org-left" />
</colgroup>

<colgroup>
<col  class="org-left" />
</colgroup>

<colgroup>
<col  class="org-left" />
</colgroup>

<colgroup>
<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">参数</th>
<th scope="col" class="org-left">含义</th>
<th scope="col" class="org-left">参数</th>
<th scope="col" class="org-left">含义</th>
</tr>
</thead>

<tbody>
<tr>
<td class="org-left">b</td>
<td class="org-left">块设备文件</td>
<td class="org-left">f</td>
<td class="org-left">普通文件</td>
</tr>
</tbody>

<tbody>
<tr>
<td class="org-left">c</td>
<td class="org-left">字符设备文件</td>
<td class="org-left">p</td>
<td class="org-left">命名管道</td>
</tr>
</tbody>

<tbody>
<tr>
<td class="org-left">d</td>
<td class="org-left">目录文件</td>
<td class="org-left">l</td>
<td class="org-left">符号链接</td>
</tr>
</tbody>
</table>

</div>



<p>我们介绍find对匹配到的文件执行的操作,</p>
<ul>
<li>-amin n: 查找在n分钟被访问过的文件</li>
<li>-atime n: 查找在n*24小时内被访问的文件</li>
<li>-cmin n: 查找在n分钟内状态发生变化的文件(例如权限)</li>
<li>-ctime n: 查找在n*24小时内状态发生过变化的文件(例如权限)</li>
<li>-mmin n: 查找在n分钟内被修改过的文件</li>
<li>-mtime n: 查找在n*24小时内被修改过的文件</li>
</ul>
<p>上面的参数n可以是正数,负数亦或是0.正数+n表示查找比指定时间更早的文件或目录,负数-n表示查找在指定时间内的文件或目录,0表示当天的文件或目录</p>
<p><a id="org3ded0d1"></a></p>
<h2 id="locate-快速定位文件"><a href="#locate-快速定位文件" class="headerlink" title="locate: 快速定位文件"></a>locate: 快速定位文件</h2><p>由于find在查找大批量文件中将花费大量的文件,因此我们可以用locate来代替find,在Ubuntu系统中locate并没有内置安装,因此我们先用apt包管理器下载locate,</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt-get install mlocate <span class="comment">## 下载locate命令及相关依赖</span></span></span><br></pre></td></tr></table></figure>
<p>locate的底层逻辑是并不去查找每个子目录,而是在/var/lib/slocate资料库里查找,因此locate的查找并不是及时的,需要对数据库进行更新,一般来说系统每天会自动更新一次,当然也可以用命令自己手动的更新,</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo updatedb <span class="comment">## 手动更新locate的文件名数据库</span></span></span><br></pre></td></tr></table></figure>
<p>locate查找也可以使用通配符,一些常用的locate命令参数为</p>
<ul>
<li>-c: 只输出找到的数量</li>
<li>-i: 忽略大小写进行查找</li>
<li>-n n: 至多显示n个输出</li>
<li>-h: 显示帮助</li>
</ul>
<p><a id="orgcffd121"></a></p>
<h2 id="whereis-查找特定程序"><a href="#whereis-查找特定程序" class="headerlink" title="whereis: 查找特定程序"></a>whereis: 查找特定程序</h2><p>whereis命令主要用于查找程序文件并提供该程序的二进制可执行文件,源代码文件和使用手册页存放的位置.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">whereis find <span class="comment">## 寻找find程序文件以及相关的配套文件</span></span></span><br><span class="line">find: /usr/bin/find /usr/share/man/man1/find.1.gz /usr/share/info/find.info-1.gz /usr/share/info/find.info.gz /usr/share/info/find.info-2.gz</span><br></pre></td></tr></table></figure>
<p>我们可以用-b选项来让whereis只返回该程序的二进制可执行文件,</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">whereis -b find <span class="comment">## 寻找find命令的二进制可执行文件</span></span></span><br><span class="line">find: /usr/bin/find</span><br></pre></td></tr></table></figure>
<p>同样,可以用-m选项来让whereis只返回该程序的帮助文件,</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">whereis -m find <span class="comment">## 寻找find命令的帮助文件</span></span></span><br><span class="line">find: /usr/share/man/man1/find.1.gz /usr/share/info/find.info-1.gz /usr/share/info/find.info.gz /usr/share/info/find.info-2.gz</span><br></pre></td></tr></table></figure>
<p>如果查找的文件不存在,那会返回一个空字符串,</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">find xxx</span></span><br><span class="line">xxx:</span><br></pre></td></tr></table></figure>
<p>事实上,whereis命令查找不到文件,不一定是文件不存在,而是有可能不是在whereis的查找目录中,其实whereis并没有查找全文件系统,仅查找了内置的子目录路径,这在查找精度上是一个缺陷,但对于查找的速度来说是一个显著提升.</p>
<p><a id="org99ede03"></a></p>
<h2 id="用户版本信息查看"><a href="#用户版本信息查看" class="headerlink" title="用户版本信息查看"></a>用户版本信息查看</h2><p>who可以查看当前系统有哪些人登陆使用,以及他们使用的工作台,</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"> <span class="built_in">who</span> <span class="comment">## 查看当前使用系统的用户</span></span></span><br></pre></td></tr></table></figure>
<p>whoami用来查看自己是以什么身份进入系统的</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">whoami</span> <span class="comment">## 查看自己进入系统的身份</span></span></span><br></pre></td></tr></table></figure>
<p>上面这两个命令对于PC系统的应用不大,主要是对于服务器系统的查看,因为不同的用户会有不同的权限,因此需要用这个来查看用户身份.</p>
<p>uname是用来显示当前系统的版本信息.-a选项会显示当前的操作系统的所有有用的信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">uname</span> -a <span class="comment">## 显示当前的操作系统的所有有用的信息</span></span></span><br><span class="line">Linux lyd-Lenovo-330S-14IKB 6.5.0-25-generic #25~22.04.1-Ubuntu SMP PREEMPT_DYNAMIC Tue Feb 20 16:09:15 UTC 2 x86_64 x86_64 x86_64 GNU/Linux</span><br></pre></td></tr></table></figure>
<p>如果只需要查看处理器类型,-m选项可以只输出这个结果,</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">uname</span> -m</span></span><br><span class="line">x86_64</span><br></pre></td></tr></table></figure>
<h2 id="man-寻求帮助"><a href="#man-寻求帮助" class="headerlink" title="man: 寻求帮助"></a>man: 寻求帮助</h2><p>linux可以用man命令接某个命令的名称来获取该命令的帮助文档,</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">man find <span class="comment">## 查看find的帮助文档</span></span></span><br></pre></td></tr></table></figure>
<p>man命令显示手册页用的是less程序.对于其上下移动和vim的操作一样,不再赘述.</p>
<h2 id="whatis-和-apropos-获取命令简介"><a href="#whatis-和-apropos-获取命令简介" class="headerlink" title="whatis 和 apropos: 获取命令简介"></a>whatis 和 apropos: 获取命令简介</h2><p>由于man查找的是帮助文档,因此太过冗长.我们可以用whatis命令快速得到命令的简要介绍,</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">whatis find  <span class="comment">## 获取命令的简要介绍</span></span></span><br><span class="line">find (1)             - search for files in a directory hierarchy</span><br></pre></td></tr></table></figure>
<p>但如果我们想要实现某个功能但不知道用什么命令时,我们可以选用apropos来反向查找,如</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">apropos search  <span class="comment">##反向搜索使用的命令</span></span></span><br><span class="line">apropos (1)          - search the manual page names and descriptions</span><br><span class="line">apt-patterns (7)     - Syntax and semantics of apt search patterns</span><br><span class="line">badblocks (8)        - search a device for bad blocks</span><br><span class="line">bsearch (3)          - binary search of a sorted array</span><br><span class="line">bzegrep (1)          - search possibly bzip2 compressed files for a regular e...</span><br><span class="line">bzfgrep (1)          - search possibly bzip2 compressed files for a regular e...</span><br><span class="line">bzgrep (1)           - search possibly bzip2 compressed files for a regular e...</span><br><span class="line">Data::DPath::Context (3pm) - Abstraction for a current context that enables i...</span><br><span class="line">find (1)             - search for files in a directory hierarchy</span><br><span class="line">git-bisect (1)       - Use binary search to find the commit that introduced a...</span><br><span class="line">hsearch (3)          - hash table management</span><br><span class="line">hsearch_r (3)        - hash table management</span><br><span class="line">lfind (3)            - linear search of an array</span><br></pre></td></tr></table></figure>
<p>可以发现apropos实际上是检索命令简介中包含关键词的条目罗列出,让用户选择.</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Computer Science</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Functional Analysis-Bidual Space and Orthogonality Relation</title>
    <url>/2023/08/07/functional-3/</url>
    <content><![CDATA[<h3 id="1-3-二次对偶空间和正交关系"><a href="#1-3-二次对偶空间和正交关系" class="headerlink" title="1.3 二次对偶空间和正交关系"></a>1.3 二次对偶空间和正交关系</h3><p>设 $E$ 是赋范向量空间, $E^\star$ 是其对偶空间, 其上定义的范数为</p>
<script type="math/tex; mode=display">\Vert f\Vert_{E^\star}=\sup_{x\in E,\ \Vert
x\Vert\leq1}|\langle f,x\rangle|,\ f\in E^\star</script><p>二次对偶空间 $E^{\star\star}$ 则是对偶空间 $E^\star$ 的对偶空间并且在其上定义的范数为</p>
<script type="math/tex; mode=display">\Vert \xi \Vert_{E^{\star\star}}=\sup_{f\in E^\star,\ \Vert f\Vert\leq1}|\langle\xi,f\rangle|,\ \xi\in E^{\star\star}</script><span id="more"></span>
<p>我们定义典范内射<font color='red'>(canonical injection)</font> $J:E\to E^{\star\star}$ 如下:</p>
<p>对于给定的 $x\in E$, 映射 $f\to\langle f,x\rangle$ 是 $E^\star$ 上的连续线性泛函, 因此 $x$ 是 $E^{\star\star}$ 的元素, 记作 $Jx$.</p>
<p><strong><font color='red'>Remark</font></strong> <font color='red'>对于此映射, 我们固定 $x$, 讨论 $f$ 在 $E^\star$ 上变化, 则其为 $E^\star$ 上的连续线性泛函. 反之如果固定 $f$, 令 $x$ 在 $E$ 上变化, 则其为 $E$ 上的连续线性泛函.</font></p>
<p>因此, 我们有下式成立</p>
<script type="math/tex; mode=display">\langle Jx,f\rangle_{E^{\star\star},E^\star}=\langle f,x\rangle_{E^\star,E}=f(x),\ \forall x\in E,\ f\in E^\star</script><p>显然映射 $J$ 是线性的且等距的, 即 $\Vert Jx\Vert_{E^{\star\star}}=\Vert x\Vert$. </p>
<p>对于等距性, 我们给出一定的解释, $\Vert Jx\Vert<em>{E^{\star\star}}=\sup</em>{f\in E^\star,\Vert f\Vert\leq1}|\langle f,x\rangle|=\Vert x\Vert$, 用到了前面文章中的推论.</p>
<p>我们定义的映射 $J$ 并不一定是满射, 也就是说 $J(E)\subset E^{\star\star}$ 可能只是子空间. 如果 $J$ 是满射, 那么我们就将 $E$ 称为自反的, 也就是 $E=E^{\star\star}$<font color='red'>(二者在等距同构意义之下是相同的)</font></p>
<p>我们引入一些记号, 如果 $M\subset E$ 是一个线性子空间, 那么我们记 $M^\perp={f\in E^\star|\langle f,x\rangle=0,\ \forall x\in M}\subset E^\star$, 其为 $M$ 的正交空间, 同时其在 $E^\star$ 上是闭的.<font color='red'>(该集合的含义是作用在 $M$ 上为 $0$ 的连续线性泛函的集合)</font>. 同样, 我们可以定义 $E^\star$ 的线性子空间 $N$ 的正交空间为 $N^\perp={x\in E|\langle f,x\rangle=0,\ \forall f\in E^\star}$, 同样其在 $E$ 中是闭的.</p>
<p><strong>Propsition 1</strong> 设 $M\subset E$ 是线性子空间, 则 $\left( M^\perp\right)^\perp=\overline{M}$; $N\subset E^\star$ 线性子空间, 则 $\overline{N}\subset\left(N^\perp\right)^\perp$.</p>
<p><strong>Proof</strong> 显然有 $M\subset\left( M^\perp\right)^\perp$, 又因为 $\left( M^\perp\right)^\perp$ 为闭集, 因此有 $\overline{M}\subset\left( M^\perp\right)^\perp$. 同样, 我们可以推得 $\overline{N}\subset\left( N^\perp\right)^\perp$.</p>
<p>下面我们要说明 $\left( M^\perp\right)^\perp\subset \overline{M}$. 我们采用反证法. 假设存在 $x_0$ 满足 $x_0\in\left( M^\perp\right)^\perp$ 但是 $x_0\not\in \overline{M}$. 依据H-B定理的第二几何形式知, 存在一个超平面严格分离 ${x_0}$ 和 $\overline{M}$, 即</p>
<script type="math/tex; mode=display">
\exists f\in E^\star,\ \alpha\in\mathbb{R},\ \text{使得}\ \langle f,x\rangle<\alpha<\langle f,x_0\rangle,\ \forall x\in M\Rightarrow \langle f,x\rangle=0,\ \forall x\in M.</script><p>因此 $f\in M^\perp$, 而 $\langle f,x_0\rangle&gt;0$, 又由于 $x_0\in \left( M^\perp\right)^\perp$, 应有 $\langle f,x\rangle=0$, 矛盾, 因此有 $\left( M^\perp\right)^\perp\subset \overline{M}$. 综上所述命题得证.</p>
]]></content>
      <categories>
        <category>Functional Analysis</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Functional Analysis</tag>
      </tags>
  </entry>
  <entry>
    <title>Functional Analysis—Geometric Forms</title>
    <url>/2023/07/03/functional-2/</url>
    <content><![CDATA[<h3 id="1-2-Hahn-Banach定理几何形式——凸集分离"><a href="#1-2-Hahn-Banach定理几何形式——凸集分离" class="headerlink" title="1.2 Hahn-Banach定理几何形式——凸集分离"></a>1.2 Hahn-Banach定理几何形式——凸集分离</h3><p><strong>超平面的定义</strong> </p>
<p>超平面(hyperplane)指 $H\subset E$ 且其形如 $H={x\in E|f(x)=\alpha}=[f=\alpha]$,其中 $f$ 为 $E$ 上非恒为 $0$ 的线性泛函, $\alpha\in\mathbb{R}$ 为常数,<font color='red'>($f$ 不要求连续)</font>, 此时称 $f(x)=\alpha$ 是超平面 $H$ 的方程.<br><span id="more"></span><br>我们先针对线性泛函不一定连续这个命题做一些简单的解释.</p>
<p><strong>Proposition 1</strong> 设 $E$ 是无穷维空间,那么存在 $E$ 中的Hamel基 ${e_i}$ 满足 $\Vert e_i\Vert=1$.</p>
<p><strong>Proof</strong> 我们记 $P$ 为由 $E$ 中线性无关集构成的集合.显然, $P$ 是诱导集,利用 Zorn 引理可以得到 $P$ 有极大元,不妨我们记其为 ${e<em>i}</em>{i\in I}$, 这就是我们所说的Hamel基. 此时找到的基可能不满足 $\Vert e_i\Vert\not=1$,我们只需要做一次归一化就可以.</p>
<p><strong>Proposition 2</strong> 在上述命题的基础之上，我们可以得到存在这样的函数，他线性但是他不连续。<br><strong>Proof</strong> 因为 $E$ 是无穷维空间，因此我们可以假设 $\mathbb{N}\subset I$. 那我们就可以构造一个 $E$ 上的特殊函数 $f$,</p>
<script type="math/tex; mode=display">
\begin{cases}
&f(e_i)=i,\ i\in\mathbb{N}\\
&f(e_i)=0,\ i\in I\backslash\mathbb{N}
\end{cases}</script><p><strong>Proposition 2</strong> 超平面 $H=[f=\alpha]$ 是闭的 $\Leftrightarrow$ $f$ 是连续的</p>
<p><strong>Proof</strong> 如果 $f$ 是连续的,显然有超平面 $H$ 是闭的. <br>反之如果 $H$ 是闭的,那么 $H^C$ 是开集并且非空<font color='red'>(由 $f\not\equiv0$ 保证)</font>.设 $x_0\in H^C$,则 $f(x_0)\not=\alpha$.不妨我们假设 $f(x_0)&lt;\alpha$, 我们取$r&gt;0$,使 $B(x_0,r)={x\in E|\Vert x-x_0\Vert<r\}\subset H^C$,则成立 $f(x)<\alpha,\ B(x_0,r)$.事实上,若存在 $x_1\in B(x_0,r)$,使得 $f(x_1)>\alpha$,构造线段 ${x_t=(1-t)x_0+tx_1|t\in[0,1]}$ 包含在 $B(x_0,r)$, 可以由下面的式子保证,</p>
<script type="math/tex; mode=display">
\Vert x_t-x_0\Vert=\Vert t(x_1-x_0)\Vert\leq\Vert x_1-x_0\Vert<r</script><p>因此线段上的点也满足 $f(x_t)\not=\alpha,\ \forall t\in[0,1].$</p>
<p>为了后续导出矛盾,我们选取一个特殊的 $t=\frac{\alpha-f(x_0)}{f(x_1)-f(x_0)}\in(0,1)$,那么有</p>
<script type="math/tex; mode=display">
f(x_t)=f((1-t)x_0+tx_1)=f(x_0)+t(f(x_1)-f(x_0))=\alpha</script><p>这与 $x_t\in H^C$ 矛盾. 因此有 $f(x_0+rz)\alpha,\ \forall z\in B(0,1)$,根据 $f$ 是线性的, 故$|f(z)|&lt;\frac{1}{r}(\alpha-f(x_0))$,因此 $f$ 满足 $\Vert f\Vert\leq \frac{1}{r}(\alpha-f(x_0))$.根据有界算子的特性知,有界性和连续性等价.</p>
<p><strong>Def</strong> 设 $A\subset E, B\subset E$, 称 $H=[f=\alpha]$ 分离 $A$ 和 $B$, 若满足</p>
<script type="math/tex; mode=display">
f(x)\leq\alpha,\ \forall x\in A\ \text{and}\ f(x)\geq\alpha,\ \forall x\in B.</script><p>进一步,我们称 $H$ 严格分离 $A,\ B$,则若 $\exists \epsilon&gt;0$,使 $f(x)\leq\alpha-\epsilon,\ \forall x\in A$ 且 $f(x)\geq\alpha+\epsilon,\ \forall x\in B$.</p>
<p>我们从几何上来看, $A,B$分别位于由超平面 $H$分割出的两个半平面上,如图所示<br><img src="https://cdn.jsdelivr.net/gh/LYD122504/picture@main/20240123/屏幕截图-2024-01-23-083637.8h96r3z6ve8.png" alt="屏幕截图-2024-01-23-083637"></p>
<p>在此重新明确一下凸集的定义: 如果 $x,y\in A$,则要求 $tx+(1-t)y\in A,\ t\in[0,1].$</p>
<p><strong>Thm (Hahn-Banach定理第一几何形式)</strong> 设 $A\subset E,\ B\subset E$ 为两个互不相交的非空凸集,若 $A$ 是开集, 则存在闭的超平面分离 $A,\ B$.</p>
<p>为了证明这个定理,我们先给出几个引理,</p>
<p><strong>Lemma 1</strong> 设 $C\subset E$是一个凸的开集并且 $0\in C$, 针对任意的$x\in C$, 我们定义如下泛函</p>
<script type="math/tex; mode=display">
p(x)=\inf\{\alpha>0|\alpha^{-1} x\in C\}</script><p>称其为 $C$ 的度量 (gauge), 又称其为 $C$ 的 Minkowski 泛函,则 $p(x)$ 满足下列性质</p>
<script type="math/tex; mode=display">
\begin{aligned}&1.\ p(\lambda x)=\lambda p(x),\ \forall x\in E,\ \lambda>0,\\&2.\ p(x+y)\leq p(x)+p(y),\ \forall x,y\in E,\\&3.\exists M,s.t. 0\leq p(x)\leq M\Vert x\Vert,\ \forall x\in E\\&4.C=\{x|p(x)<1\}\end{aligned}</script><p><strong>Proof</strong> 1.显然成立,即</p>
<script type="math/tex; mode=display">
p(\lambda x)=\inf\{\alpha>0|\alpha^{-1}\lambda x\in C\}=\lambda\inf\{\alpha\lambda^{-1}|(\alpha\lambda^{-1})^{-1}x\in C\}=\lambda p(x)</script><p>下面我们证明3成立,根据题目可得,设 $r&gt;0$,我们可以构造一个开球 $B(0,r)\subset C$. 显然有 $p(x)\leq\frac{1}{r}\Vert x\Vert,\ \forall x\in E$, 下面给出一定的解释.</p>
<p> 当 $x=0$, 有 $p(x)=0$.但 $x\not=0$ 时,我们可以对$x$做单位化,记$y=\frac{x}{\Vert x\Vert}$,此处我们取 $r=\sup{\delta|\delta\cdot y\in B(0,r)\subset C}$,因此 $p(y)\leq\frac{1}{r}\Rightarrow p(x)\leq\frac{1}{r}\Vert x\Vert$.</p>
<p>下证明 4 成立,设$x\in C$并且 $C$ 是开集, 故存在$\epsilon&gt;0$,使得 $(1+\epsilon)x\in C$ 成立,因此 $p(x)\leq\frac{1}{1+\epsilon}&lt;1$.反之如果有 $p(x)&lt;1$ 成立,那么有 $0&lt;\alpha&lt;1$使得 $\alpha^{-1}x\in C$.从而有 $x=\alpha(\alpha^{-1}x)+(1-\alpha)0\in C$,这由 $C$ 的凸集性质保证.</p>
<p>下说明 2 成立.设 $\forall x,\ y\in E$ 并且 $\epsilon&gt;0$,由1和4可知 $\frac{x}{p(x)+\epsilon},\frac{y}{p(y)+\epsilon}\in C$.由于C是凸集,因此 $\forall t\in[0,1]$,有 $t\frac{x}{p(x)+\epsilon}+(1-t)\frac{y}{p(y)+\epsilon}\in C$.为了给出证明,我们选取特殊的 $t$ 即 $t=\frac{p(x)+\epsilon}{p(x)+p(y)+2\epsilon}$,代入可得 $\frac{x+y}{p(x)+p(y)+2\epsilon}\in C$.因此有 $p(x+y)&lt;p(x)+p(y)+2\epsilon$,此时我们令 $\epsilon\to0$,式 2 即可证明.</p>
<p><strong>Lemma 2</strong> 设 $C\subset E$ 并且 $C$ 是一个非空凸开集.若 $x_0\in E$ 且 $x_0\not\in C$, 那么就存在 $f\in E^\star$,使得 $f(x)&lt;f(x_0),\ \forall x\in C$. 特别地, 超平面 $[f=f(x_0)]$ 分离了点 $x_0$ 和集合 $C$.</p>
<p><strong>Proof</strong> 我们假设 $0\in C$ 成立, 不然的话, 我们总可以通过平移来使得其成立, 这并不会对我们的结果造成影响,因此我们直接假设其成立即可. 我们引入 Lemma 1 中定义的 $C$ 的度量 $p(x)$. 我们考虑 $E$ 的线性子空间 $G=\mathbb{R}x_0$ 和定义在其上的线性泛函 $g(tx_0)=t,\ t\in\mathbb{R}$. 我们接下来要说明这个线性泛函是被我们前面引入的度量泛函控制的.</p>
<p>1.如果 $t&gt;0$, 根据 Lemma 1 推导的性质知, $p(tx_0)=tp(x_0)$.又根据题设知 $x_0\not\in C$ 并且 $0\in C$, 因此 $p(x_0)\geq 1,\ p(tx_0)\geq t=g(x)$</p>
<p>2.如果 $t\leq 0$, $p(x)\geq g(x)$ 是显然成立的.</p>
<p>由 Hahn-Banach 定理的解析形式, 存在 $f$ 是 $E$ 上线性泛函延拓了 $g$ 并且 $f(x)\leq p(x),\ \forall x\in E$. 因此 $f(x_0)=g(x_0)=1$. 由 Lemma 1 导出的度量泛函性质, 我们可以得到 $f$ 也是有界泛函, 即 $f(x)\leq p(x)\leq M\Vert x\Vert$, 所以 $f$ 是连续线性泛函. 根据 Lemma 1 可知, $f(x)&lt;1,\ \forall x\in C$.</p>
<p><strong>Proof of Thm</strong> 令 $C=A-B$ 且 $C$ 是凸集. 同时 $C$ 是开集, 这是因为我们可以将 $C$ 改写成 $C=\bigcup<em>{y\in B}(A-y)$<font color='red'>(题设中 $A$ 是开集在此应用)</font>, 但是 $0\not\in C$. 由 Lemma 2 可知, $\exists f\in E^\star$, 使得 $f(z)<0,\ \forall z\in C$ <font color='red'>(此处要求 $f(0)=0$,如果不成立的话,我们只需要平移 $f$ 即可)&lt;/font&gt;. 此式可得到 $f(x)&lt;f(y),\ \forall x\in A,\ y\in B$. 此时我们选取 $\alpha$ 满足 $\sup</em>{x\in A}f(x)\leq\alpha\leq\inf_{y\in B}f(y)$. 因此 $[f=\alpha]$ 分离了 $A$ 和 $B$.</p>
<p><strong>Thm (Hahn-Banach定理第二几何形式)</strong> 设 $A\subset E,\ B\subset E$ 是两个互不相交的凸集, 设 $A$ 是闭集, $B$ 是紧集, 则存在闭超平面严格分离 $A$ 和 $B$.</p>
<p><strong>Proof</strong> 令 $C=A-B$, 同样我们可以得到 $C$ 是凸集. 我们宣称 $C$ 是闭集.</p>
<p> 下面给出这个宣称的证明, 若 $c_n=a_n-b_n$ 且 $c_n\to c_0$, 我们只需要说明 $c_0\in C$ 即完成证明. 由于 $B$ 是紧集, 因此 $b_n\to b_0\in B$. $a_n=b_n+c_n\to b_0+c_0\in A$, 因此 $A$ 是闭集. 此处我们记 $a_0=b_0+c_0\in A$, 因此 $c_0=a_0-b_0\in C$.</p>
<p> 同样我们可知 $0\not\in C$, 因此 $\exists r&gt;0$, 使得 $B(0,r)\cap C=\emptyset$. 根据 Hahn-Banach 定理第一几何形式, 存在闭超平面分离了 $B(0,r)$ 和 $C$,即</p>
<script type="math/tex; mode=display">
 \exists f\in E^\star,\ f\not\equiv 0,\ f(x-y)\leq f(rz),\ \forall x\in A,\ y\in B,\ z\in B(0,1).</script><p> 故 $f(x-y)\leq -r\Vert f\Vert,\ \forall x\in A,\ y\in B.$ <font color='red'>(此式的导出基于 $|f(rz)|=r|f(z)|\leq r\Vert f\Vert$)</font>.</p>
<p> 令 $\epsilon=\frac{r}{2}\Vert f\Vert&gt;0$, 则有 $f(x)+\epsilon\leq f(y)-\epsilon,\ \forall x\in A,\ y\in B$ 成立. 因此我们选取 $\alpha$ 满足 $\sup<em>{x\in A}f(x)+\epsilon\leq\alpha\leq\inf</em>{y\in B}f(y)-\epsilon$, 所以闭超平面 $[f=\alpha]$ 严格分离 $A$ 和 $B$.</p>
<p><strong>Corollary 1</strong> 设 $F\subset E$ 是 $E$ 的线性子空间, 使得 $\overline{F}\not=E$, 那么 $\exists f\in E^\star$ 且 $f\not\equiv 0$, 使得 $\langle f,x\rangle=0,\ \forall x\in F$.</p>
<p><strong>Proof</strong> 由题设可知, $\exists x_0\in E$ 且 $x_0\not\in \overline{F}$. 我们记 $A=\overline{F},\ B={x_0}$, 显然此处的 $A$ 是闭的, 而 $B$ 则是紧的. 依托 H-B 定理的第二几何形式可知存在一个闭超平面 $[f=\alpha]$ 严格分离 $A$ 和 $B$, 即 $\langle f,x\rangle&lt;\alpha&lt;\langle f,x_0\rangle,\ \forall x\in F$. 因为 $F$ 是线性子空间, 因此有 $\lambda \langle f,x\rangle&lt;\alpha,\ \forall \lambda\in\mathbb{R}\Rightarrow \langle f,x\rangle=0,\ \forall x\in F$.</p>
<p><strong><font color='red'>Remark</font></strong>  <font color='red'>该推论一般用于判断子空间 $F\subset E$ 是否在 $E$ 上稠密. 如果稠密, 则有 $\forall f$ 满足 $\langle f,x\rangle=0,\ \forall x\in F$,  同时有 $\langle f,x\rangle\equiv0,\ \forall x\in E$</font></p>
]]></content>
      <categories>
        <category>Functional Analysis</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Functional Analysis</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux-文件目录管理</title>
    <url>/2024/04/16/linux-2/</url>
    <content><![CDATA[<h1 id="文件目录管理"><a href="#文件目录管理" class="headerlink" title="文件目录管理"></a>文件目录管理</h1><p>下表罗列了Linux文件系统中主要目录的内容</p>
<div align="center">


<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-center" />
</colgroup>

<colgroup>
<col  class="org-center" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-center">目  录</th>
<th scope="col" class="org-center">内  容</th>
</tr>
</thead>

<tbody>
<tr>
<td class="org-center">/bin</td>
<td class="org-center">构建最小系统所需要的命令(最常用的命令)</td>
</tr>
</tbody>

<tbody>
<tr>
<td class="org-center">/boot</td>
<td class="org-center">内核和启动文件</td>
</tr>
</tbody>

<tbody>
<tr>
<td class="org-center">/dev</td>
<td class="org-center">各种设备文件</td>
</tr>
</tbody>

<tbody>
<tr>
<td class="org-center">/etc</td>
<td ·class="org-center">系统软件的启动和配置文件</td>
</tr>
</tbody>

<tbody>
<tr>
<td class="org-center">/home</td>
<td class="org-center">用户的主目录(用户所有数据,极其重要)</td>
</tr>
</tbody>

<tbody>
<tr>
<td class="org-center">/lib</td>
<td class="org-center">C编译器的库</td>
</tr>
</tbody>

<tbody>
<tr>
<td class="org-center">/media</td>
<td class="org-center">可移动介质的安装点</td>
</tr>
</tbody>

<tbody>
<tr>
<td class="org-center">/opt</td>
<td class="org-center">可选的应用软件包(用deb包安装的部分软件在这)</td>
</tr>
</tbody>

<tbody>
<tr>
<td class="org-center">/proc</td>
<td class="org-center">进程的映像</td>
</tr>
</tbody>

<tbody>
<tr>
<td class="org-center">/root</td>
<td class="org-center">根用户root的主目录</td>
</tr>
</tbody>

<tbody>
<tr>
<td class="org-center">/sbin</td>
<td class="org-center">和系统操作有关的命令</td>
</tr>
</tbody>

<tbody>
<tr>
<td class="org-center">/tmp</td>
<td class="org-center">临时文件存放点</td>
</tr>
</tbody>

<tbody>
<tr>
<td class="org-center">/usr</td>
<td class="org-center">非系统的程序和命令(apt安装的位置)</td>
</tr>
</tbody>

<tbody>
<tr>
<td class="org-center">/var</td>
<td class="org-center">系统专用的数据和配置文件</td>
</tr>
</tbody>
</table>

</div>

<p><a id="org8d61c7d"></a></p>
<span id="more"></span>
<h2 id="mkdir-建立目录"><a href="#mkdir-建立目录" class="headerlink" title="mkdir: 建立目录"></a>mkdir: 建立目录</h2><p>mkdir命令可以一次建立一个或几个目录.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> document picture <span class="comment">## 新建两个目录</span></span></span><br></pre></td></tr></table></figure>
<p>这样的创建是先利用cd到你想创建的位置,再创建目录.用户也可以用绝对路径来新建目录,这样的话不需要用cd来跳转到创建的位置,在任意位置用mkdir加绝对路径即可创建目录,</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> ~/picture/temp <span class="comment">## 在主目录的picture目录下创建temp子目录</span></span></span><br></pre></td></tr></table></figure>
<p>这个命令合法是因为picture目录存在主目录下,如果用户试图在一个不存在的目录下创建新子目录,那命令会报错.为了避免这个报错,我们可以用-p选项来创建目录.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> -p /home/username <span class="comment">## 在home目录下创建username目录,如果他存在那就不去创建</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> -p ~/test1/test2 <span class="comment">## 如果主目录下没有test1,那么不会报错,而是先创建test1再在其中创建test2</span></span></span><br></pre></td></tr></table></figure>
<p><a id="orgfef9599"></a></p>
<h2 id="touch-建立一个空文件"><a href="#touch-建立一个空文件" class="headerlink" title="touch: 建立一个空文件"></a>touch: 建立一个空文件</h2><p>touch后面接文件名作为参数,可以在当前目录创建一个或多个新文件,</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">touch</span> hello <span class="comment">## 在当前目录创建文件名为hello的文件</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">touch</span> <span class="string">&#x27;hello world&#x27;</span> <span class="comment">## 在当前目录创建文件名为 &#x27;hello world&#x27; 的文件</span></span></span><br></pre></td></tr></table></figure>
<p>如果我们在上面的’hello world’中不加引号,那touch会认为创建hello和world两个文件.用touch命令创建的文件是空文件,其内不包含任何内容.</p>
<p>touch除了创建空文件的作用,其更重要的用途是更新一个文件的建立日期和时间.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l init.el~ <span class="comment">## 查看文件的时间属性</span></span></span><br><span class="line">-rw-r--r-- 1 lyd lyd 997  2月  5 21:54 init.el~ ## 原来文件时间属性是2024/2/5-21:54</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">touch</span> init.el~ <span class="comment">## 修改文件的时间属性</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l init.el~ <span class="comment">## 查看改过的文件时间属性</span></span></span><br><span class="line">-rw-r--r-- 1 lyd lyd 997  3月 20 20:52 init.el~ ## 改过以后文件时间变成了2024/3/20-20:52</span><br></pre></td></tr></table></figure>
<p>touch命令在自动备份和整理文件文件时非常有用.</p>
<p><a id="org0ba94bd"></a></p>
<h2 id="mv-移动和重命名"><a href="#mv-移动和重命名" class="headerlink" title="mv: 移动和重命名"></a>mv: 移动和重命名</h2><p>mv其实是move的缩写形式.这个命令可以用来移动文件或目录到另一个路径.这里移动到的文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mv</span> hello bin/ <span class="comment">## 把hello文件移动到bin目录下</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mv</span> Photos/ 桌面/ <span class="comment">## 把Photos目录移动到桌面目录下</span></span></span><br></pre></td></tr></table></figure>
<p>由于执行mv命令的时候并不会有任何信息显示,那么如果目标目录中有一个同名文件,不加任何选项的mv命令会强制替换文件.这一行为极其危险,容易强制替换掉一些关键文件.为了避免这种情况出现,我们可以用-i选项来控制覆盖文件与否,</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mv</span> -i hello <span class="built_in">test</span>/ <span class="comment">## 出现同名文件询问是否覆盖</span></span></span><br></pre></td></tr></table></figure>
<p>其会先询问用户是否覆盖旧文件,输入y表示直接覆盖,输入n表示取消移动操作.</p>
<p>另外一个避免强制覆盖的选项是-b,其与-i的询问不同,如果出现同名文件,那么他会在转移之前将目标目录中的同名文件的文件名后面加一个~,形成一个备份,从而避免文件覆盖情况的发生.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mv</span> -b hello <span class="built_in">test</span>/ <span class="comment">## 出现同名文件则对其备份</span></span></span><br></pre></td></tr></table></figure>
<p>Linux中不存在重命名的操作,我们可以认为重命名只不过是在同一级目录下的移动而已.因此我们可以用mv命令来实现对文件或目录的重命名.<br>如</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mv</span> hello world <span class="comment">## 在同级目录下进行重命名</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mv</span> /home/lyd/hello /home/lyd/learning/world <span class="comment">## 移动到其他目录并且重命名</span></span></span><br></pre></td></tr></table></figure>
<p>使用mv命令可能出现的一些简单情况,</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mv</span> file1 file2 <span class="comment">## 移动file1到file2</span></span></span><br></pre></td></tr></table></figure>
<p>如果file2存在,他的内容会被file1的内容覆盖.如果file2不存在,那就会创建file2.但这两种情况下,file1都不会存在.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mv</span> file1 file2 dir1/ <span class="comment">## 移动file1和file2到目录dir1中</span></span></span><br></pre></td></tr></table></figure>
<p>这个命令的前提是目录dir1必须已经存在.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mv</span> dir1/ dir2/ <span class="comment">## 移动目录dir1到目录dir2</span></span></span><br></pre></td></tr></table></figure>
<p>如果目录dir2不存在,创建目录dir2,并且移动目录dir1的内容到目录dir2中,同时删除目录dir1.如果dir2存在,移动目录dir1及他的内容到目录dir2.</p>
<p><a id="org8b9b032"></a></p>
<h2 id="cp-复制文件和目录"><a href="#cp-复制文件和目录" class="headerlink" title="cp: 复制文件和目录"></a>cp: 复制文件和目录</h2><p>cp命令用来复制文件和目录.下面的指令用来将test.php复制到test目录下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cp</span> test.php <span class="built_in">test</span>/ <span class="comment">## 复制文件到指定路径</span></span></span><br></pre></td></tr></table></figure>
<p>和mv命令一样,cp在默认情况下也会强制覆盖目标目录中的同名文件.同样我们可以用-i选项来对这种覆盖文件的情况进行提示,我们也可以用-b选项来避免询问,通过对同名文件进行一个修改命名再进行复制.这两个选项的使用和mv命令的一样,因此不再赘述.</p>
<p>如果我们希望复制一个目录到另一个目录下,而直接用cp命令进行复制,则会有如下结果</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cp</span> learning/ Downloads/ <span class="comment">## 报错的复制目录</span></span></span><br><span class="line">cp: 未指定 -r；略过目录 &#x27;learning/&#x27;</span><br></pre></td></tr></table></figure>
<p>这是因为cp命令在执行复制任务的时候会自动跳过目录.如果我们一定要连同目录及其内部的文件一块复制到另一个目录,我们需要用-r选项来实现这一操作.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cp</span> -r learning/ Downloads/ <span class="comment">##  复制目录到指定目录</span></span></span><br></pre></td></tr></table></figure>
<p>使用cp可能出现的一些简单情况,</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cp</span> file1 file2 <span class="comment">## 复制文件file1内容到文件file2</span></span></span><br></pre></td></tr></table></figure>
<p>如果file2存在,那么file2的内容会被file1的内容覆盖.如果file2不存在,那就会创建一个file2.但和mv删除file1不同,cp命令会保留file1.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cp</span> file1 file2 dir1/ <span class="comment">## 复制文件file1和file2到目录dir1</span></span></span><br></pre></td></tr></table></figure>
<p>但这里必须要求目录dir1存在.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cp</span> dir1/* dir2/ <span class="comment">## 用通配符移动文件</span></span></span><br></pre></td></tr></table></figure>
<p>与-r选项不同,用通配符来批量移动dir1中的文件,要求dir2存在并且移动只会复制dir1中的文件和子目录,不会在dir2中复制dir1这个目录.</p>
<p><a id="org9b7d339"></a></p>
<h2 id="rmdir-和-rm-删除目录和文件"><a href="#rmdir-和-rm-删除目录和文件" class="headerlink" title="rmdir 和 rm: 删除目录和文件"></a>rmdir 和 rm: 删除目录和文件</h2><p>rmdir命令可以用来删除目录.其只需要在rmdir命令后面接要删除的文件名即可.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> remove <span class="comment">##创建一个空目录</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">rmdir</span> remove <span class="comment">##删除指定的空目录</span></span></span><br></pre></td></tr></table></figure>
<p>但rmdir只能用于删除空目录,一旦试图用其删除非空目录,那么会有如下报错</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">rmdir</span> learning</span></span><br><span class="line">rmdir: 删除 &#x27;learning&#x27; 失败: 目录非空</span><br></pre></td></tr></table></figure>
<p>因此,如果我们想要用rmdir删除非空目录,我们需要先删除该目录下的所有子目录及文件.</p>
<p>对于文件的删除可以用rm命令,其实rm命令也可以针对目录,此处rm命令删除的目录是允许出现非空目录,因此rm的应用远比rmdir更为广泛.rm命令可以一次性删除单个或多个文件,</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">rm</span> <span class="built_in">test</span>/* <span class="comment">## 删除test目录下的所有文件</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">rm</span> halo <span class="comment">## 删除halo文件</span></span></span><br></pre></td></tr></table></figure>
<p>和前面的mv和cp命令一样,rm不会在运行过程中出现任何提示,利用rm命令删除的文件并不会被移入回收站,而是直接从系统中删除.因此为了安全的使用rm,我们一般用-i选项来在删除过程之前给出提示等待用户确认,与前面的mv和cp一样.但有个例外,如果我们删除只读文件,那么即便我们不使用-i选项,rm命令也会对这一操作进行询问</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">rm</span> <span class="built_in">test</span> <span class="comment">## 删除test只读文件</span></span></span><br><span class="line">rm: 是否删除有写保护的普通空文件 &#x27;test&#x27;？ </span><br></pre></td></tr></table></figure>
<p>如果对这个交互操作默认是y,且不想多次交互,我们可以用-f选项来跳过这些交互操作,rm会自动对这些交互操作回答y.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">rm</span> -f <span class="built_in">test</span> <span class="comment">## -f选项跳过交互操作</span></span> </span><br></pre></td></tr></table></figure>
<p>我们可以用带-r选项的rm命令会递归的删除指定目录下所有文件和子目录.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">rm</span> -r Photos/ <span class="comment">## 递归删除Photos目录</span></span></span><br></pre></td></tr></table></figure>
<p>关键在于使用rm -rf命令一定要注意评估删除的后果,不然可能会破坏系统的稳定性,故慎用rm -r命令.</p>
<p><a id="org1f6941e"></a></p>
<h2 id="Linux文件目录权限"><a href="#Linux文件目录权限" class="headerlink" title="Linux文件目录权限"></a>Linux文件目录权限</h2><p>Linux的文件目录权限针对三类人群:文件所有者(属主),文件属组用户,其他人.关键在于其他人的多样性,可能会对文件目录内容进行修改,从而有机会造成不可预料的信息损坏.root用户虽然应该归属于上面的其他人,但root用户显然具有对系统任意文件的查看,修改,执行权利,因为root用户拥有控制一台计算机的所有权限.</p>
<p>文件所有者一般是文件的创建者.但这并不是绝对的,root用户可以修改一个文件的属主用户.换言之,在某个用户在linux系统创建了某个文件,此时文件所有者(属主)自动是文件创建者,但后续过程中root用户可以将文件所有者进行转让,这个转让过程也仅能用root用户进行.</p>
<p>当然文件的权限也会被给予一个用户组,我们称这个用户组为文件的属组.组是一群用户组成的一个集合.文件属组中的用户按照设置对文件享有特定的权限.通常而言,当一个用户创建了一个文件,那么该文件的属主就是这个用户,而文件的属组则是有且仅有该用户的用户组.当然我们也可以设置这个文件属组是一个不包括文件属主的用户组.如果文件属主执行文件操作的时候,系统只会关注于文件属主的权限,而文件属组的权限并不会对文件属主的权限造成影响.</p>
<p>其他人则是不包括文件所有者,文件属组用户和root用户以外的其他用户.通常其他人的权限十分低,甚至于无法对文件有任何权限.</p>
<p>可以用来赋予用户的文件和目录的权限为读取(r),写入(w)和执行(x).对于文件而言,读取权限意味着可以打开并查看文件的内容,写入权限控制着对文件的修改权限,至于是否能呢更狗删除和重命名一个文件则是由其父目录的权限设置所控制.要让一个文件可执行,必须设置其执行权限.可执行文件有两类,一类是可以直接由CPU执行的二进制代码,另一类则是Shell脚本程序.</p>
<p>对目录而言,目录的执行权限其实是控制用户是否能够进入该目录,因此目录的执行权限其实上是目录的最基本的权限.而读取权限负责确定能否列出该目录的内容,写入权限则控制在目录中创建,删除和重命名文件.</p>
<p><a id="org3d640d7"></a></p>
<h2 id="ls-l-查看文件类型"><a href="#ls-l-查看文件类型" class="headerlink" title="ls -l: 查看文件类型"></a>ls -l: 查看文件类型</h2><p>前面介绍ls命令时,提到了ls -l来查看文件的属性,此处进一步解释展示的文件属性的参数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l  <span class="comment">## 列出所有文件和目录以及其对应的属性</span></span></span><br><span class="line">  总计 152</span><br><span class="line">  drwxr-xr-x  2 lyd  lyd   4096  2月  5 09:49  公共</span><br></pre></td></tr></table></figure>
<ul>
<li>第一个字段中的第一个字符表示文件类型,这个例子是d,其表示这是一个目录,具体的字符和文件类型的对应下表所示,</li>
</ul>
<div align="center">


<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">



<colgroup>
<col  class="org-left" />
</colgroup>

<colgroup>
<col  class="org-left" />
</colgroup>

<colgroup>
<col  class="org-left" />
</colgroup>

<colgroup>
<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">文件类型</th>
<th scope="col" class="org-left">符号</th>
<th scope="col" class="org-left">文件类型</th>
<th scope="col" class="org-left">符号</th>
</tr>
</thead>

<tbody>
<tr>
<td class="org-left">普通文件</td>
<td class="org-left">-</td>
<td class="org-left">本地域套接口</td>
<td class="org-left">s</td>
</tr>
</tbody>

<tbody>
<tr>
<td class="org-left">目录</td>
<td class="org-left">d</td>
<td class="org-left">有名管道</td>
<td class="org-left">p</td>
</tr>
</tbody>

<tbody>
<tr>
<td class="org-left">字符设备文件</td>
<td class="org-left">c</td>
<td class="org-left">符号链接</td>
<td class="org-left">l</td>
</tr>
</tbody>

<tbody>
<tr>
<td class="org-left">块设备文件</td>
<td class="org-left">b</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>

<p>&lt;/div&gt;<br>其中具体的含义大概解释如下,Linux一般用设备文件来表示一个特定的硬件设备.Linux中有两类设备文件:字符设备文件和块设备文件.其中字符设备指的是能从他那读取成字符序列的设备,如磁带和串行设备;块设备则是指用来存储数据并对其各部分内容提供同等访问权的设备,如磁盘.一般我们可以称字符设备为顺序访问设备,块设备则为随机访问设备.这是因为块设备可以从硬盘的任何随机位置获取数据,而字符设备则必须按照数据发送的顺序从串行线路上获得.但是系统中存在设备文件,并不代表着他一定链接着相应的硬件设备,而是表示其具有处理对应硬件设备的能力.</p>
<p>关于本地域套接口和有名管道这两个文件涉及到了进程间通信,日常使用并不常见.</p>
<p>符号链接会在后续的ln里介绍,类似于windows系统的快捷方式.</p>
<ul>
<li>接下来的rwxr-xr-x则是三组权限位,断句如下rwx,r-x,r-x,分别代表着属主,属组,其他用户的权限.r表示可读取,w表示可写入,x表示可执行,如果某个权限被禁用,那么其会用短横线-取代.</li>
<li>紧跟着三组权限位的数字表示文件的链接树木.此处是2.表示该目录存在两个链接,关于链接后续会给出介绍.</li>
<li>后面第三个字段和第四个字段表示文件的属主和属组.</li>
</ul>
<p>ls -l可以用来查看某个特定文件的属性,但是如果我们需要查看目录的属性则需要用ls -ld命令来查看.</p>
<p><a id="orgaef0396"></a></p>
<h2 id="chown-和-chgrp-改变文件所有权"><a href="#chown-和-chgrp-改变文件所有权" class="headerlink" title="chown 和 chgrp: 改变文件所有权"></a>chown 和 chgrp: 改变文件所有权</h2><p>chown命令用于改变文件的所有权.chown命令的基本语法为:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chown [OPTION] ... [OWNER][:[GROUP]] FILE... ## chown语法基本结构</span><br></pre></td></tr></table></figure>
<p>这条命令可以将文件FILE的属主更改为OWNER,属组更改为GROUP. 下面命令给出了一个示例,其将文件的属主更改为LYD,同时将文件属组更改为root组,</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo <span class="built_in">chown</span> LYD:root file <span class="comment">## 修改文件file的属主为LYD,同时修改属组为root组</span></span></span><br></pre></td></tr></table></figure>
<p>如果我们只需要修改文件的属主,那么我们只需要输入OWNER,不需要输入:GROUP.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo <span class="built_in">chown</span> LYD file <span class="comment">## 修改文件file的属主为LYD,但不对属组进行修改</span></span></span><br></pre></td></tr></table></figure>
<p>同样,我们只修改文件属组的话,只需要输入:GROUP,但这里要注意的是冒号:并不是可省略的,省略参数OWNER即可,</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo <span class="built_in">chown</span> :root file <span class="comment">## 修改文件file的属组为root,但不对属主进行操作</span></span></span><br></pre></td></tr></table></figure>
<p>我们在前面用chown修改单个文件的属组和属组.实际上我们可以用chown来修改目录文件的属主和属组,但是显然如果我们只修改目录文件的属主和属组的话,并没有什么意义.因此我们可以利用chown命令的-R选项,用于改变一个目录及其下所有文件(包括子目录)的所有权设置.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo <span class="built_in">chown</span> -R LYD:root iso/ <span class="comment">## 递归修改iso文件及其下的所有文件(包括子目录)的所有权</span></span></span><br></pre></td></tr></table></figure>
<p>由于chown可以更改文件的属主和属组属性,但实际上Linux系统提供了另一个命令chgrp,其专门用来修改文件的属组.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">chgrp</span> nogroup days <span class="comment">## 更改文件属组</span></span></span><br></pre></td></tr></table></figure>
<p>同样和chown一样,我们也可以用-R选项来递归的更改目录及其下所有文件和子目录的属组.但是这里chgrp和chown有一个关键区别在于,chown修改文件属组需要用root用户权限,然而对于chgrp,其只需要修改的用户在文件的属组就可以修改文件的属组.</p>
<p><a id="orgad5e953"></a></p>
<h2 id="chmod-改变文件权限"><a href="#chmod-改变文件权限" class="headerlink" title="chmod: 改变文件权限"></a>chmod: 改变文件权限</h2><p>chmod用来改变一个文件的权限.其修改删除权限的模式是用户组+/-权限的表达式.具体而言,用户组分为文件属主(u),文件属组(g),其他人(o),以及所有人(a).权限则表示读取(r),写入(w)和执行(x).</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">chmod</span> u+x days <span class="comment">## 为days文件属主提供文件执行权限</span></span></span><br></pre></td></tr></table></figure>
<p>chmod可以用a来同时指定包括文件属主,文件属组和其他人的三类人,我们可以利用以此同时给全部人员增加或删除权限.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">chmod</span> a+w days <span class="comment">## 为days文件的所有人同时提供文件的写入权限</span></span></span><br></pre></td></tr></table></figure>
<p>如果我们需要同时给三类人增删权限,除了用a来表示所有人以外,实际上我们可以不加任何用户组标记,直接用+/-权限的形式,同样可以给全部人员增加或删除权限</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">chmod</span> +rw file <span class="comment">## 为文件file的所有用户增加读取权限和写入权限</span></span></span><br></pre></td></tr></table></figure>
<p>这个命令中我们通过+rw同时给所有用户添加了读取权限和写入权限,这也就是说我们可以在一个命令中同时给用户添加或删除一个或多个权限.进一步我们可以利用逗号来分隔不同的两个修改权限操作</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">chmod</span> u+r,go-w file <span class="comment">## 为文件file的属主添加读取权限,属组和其他人则删除写入权限</span></span></span><br></pre></td></tr></table></figure>
<p>在这里,我们用了一个go来同时对属组和其他人进行修改权限操作,因此实际上我们可以看出来前面用的所有人标识符a和ugo等价.上面我们用逗号分隔符来分隔对不同用户的修改权限操作,实际上我们也可以用逗号分隔符来分隔对同一用户做的不同修改操作.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">chmod</span> u+r,u-w file <span class="comment">## 为文件file的属主添加读取权限的同时,删除文件属主的写入权限</span></span></span><br></pre></td></tr></table></figure>
<p>如果用上面的添加或删除操作修改用户的权限来达到预期会极其复杂,中间也可能需要多次用ls -l查看文件属性.因此chmod还存在一个规则:用户组=权限来直接设置文件权限.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">chmod</span> ug=rw,o=r file <span class="comment">## 文件的属主和属组权限更改为读取权限和写入权限,而其他人的权限更改为读取权限</span></span></span><br></pre></td></tr></table></figure>
<p>如果文件本身就有一个默认设定的权限,=这种规则会先重置需要修改的用户组的默认规则,然后按照=设定的权限重新赋予.虽然我们举了对所有用户用=修改权限的例子,但实际上,=规则是可以只对其中部分进行修改的.</p>
<p>最后最为常用的是用户组1=用户组2,其的作用在于将用户组1的权限和用户组2的权限设置成一样.明确来说,他的作用是将用户组2的权限覆盖用户组1的权限.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">chmod</span> o=u file <span class="comment">## 将文件file的其他人权限设置成文件属主的权限</span></span></span><br></pre></td></tr></table></figure>
<p>最为关键的一点是只有文件的属主和root用户才可以修改文件的权限.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">chmod</span> u+r file1 file2 <span class="comment">## 为文件file1和file2的属主增加读取权限</span></span></span><br></pre></td></tr></table></figure>
<p>但这里要注意这样的修改要么在root用户下进行,要么两个文件的属主是同一个用户</p>
<p>虽然我们前面已经将权限用三个字母来表示,但这对批量修改文件的权限十分麻烦,因此我们可以用八进制来代表设置权限.由于对于任意的权限而言,其只存在两种状态:设置(1)和不设置(0).所以我们可以得到任意一组权限设置的八进制表示,如’rwx’的二进制为111,八进制为7;’r-x’的二进制为101,八进制为5.这样我们就可以将完整的9位权限位用3个八进制数来表示,例如’rwxr-x-w-‘分别对应的三个三位二进制为111/101/010,其对应的三个八进制数752.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">chmod</span> 752 file <span class="comment">## 将文件权限设置为 rwx/ r-x/ -w-</span></span> </span><br></pre></td></tr></table></figure>
<p><a id="orgece5a30"></a></p>
<h2 id="ln-建立链接"><a href="#ln-建立链接" class="headerlink" title="ln: 建立链接"></a>ln: 建立链接</h2><p>ln命令是用来为某个文件在另一个位置创建一个同步的链接.链接主要分为符号链接(软链接)和硬链接两大类.无论硬链接还是软链接,他们都不会重新复制原来的文件,他们只会占用非常少量的磁盘空间.</p>
<p>符号链接,也被称为软链接,其用ln -s命令来创建生成.软链接具有如下的特点,</p>
<ol>
<li><p>软链接以路径的形式存在,类似于windows系统的快捷方式</p>
</li>
<li><p>软链接可以跨越不同的文件系统</p>
</li>
<li><p>软链接可以对一个不存在的文件名进行链接</p>
</li>
<li><p>软链接还可以对目录文件进行链接7</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ln</span> -s TARGET LINKNAME <span class="comment">## 为文件TARGET创建了一个别名LINKNAME</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l LINKNAME <span class="comment">## 查看LINK_NAME的属性</span></span></span><br><span class="line">lrwxrwxrwx 1 lyd lyd 6  4月 15 11:31 LINK_NAME -&gt; TARGET</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>从这里我们可以看出这个文件被指向TARGET文件,因此访问LINK_NAME就相当于访问TARGET.需要注意的是,这里的LINKNAME只是提供了访问TARGET的一个路径,因此我们删除LINKNAME并不会影响TARGET的正常运行,反之我们删除TARGET,虽然不会同时删除LINKNAME,但是其存在已经没有任何意义了.</p>
<p>同样符号链接还可用于目录,</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ln</span> -s learning/ LINK <span class="comment">## 为目录learning创建一个别名LINK</span></span></span><br></pre></td></tr></table></figure>
<p>此外,对于软链接而言,其还存在删除和修改操作如下,</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">rm</span> -rf LINKNAME <span class="comment">## 删除软链接</span></span></span><br></pre></td></tr></table></figure>
<p>切记不要在软链接后面加/,不然如果软链接对应的是目录文件,可能会直接把目录文件里的内容全部删除.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ln</span> -snf NEWTARGET LINK <span class="comment">## 将LINK链接的文件从原文件更改到新文件NEWTARGET</span></span></span><br></pre></td></tr></table></figure>
<p>这里的修改操作,不止允许同一类型之间文件的链接相互更改,还可以把普通文件的链接文件链接到目录文件,亦或反之.</p>
<p>Linux中的另一种链接称为硬链接.其将两个独立的文件联系在一起,因此硬链接和软链接的本质区别是,硬链接是直接引用,而软链接是通过名称进行引用.</p>
<p>硬链接具有的特性如下,</p>
<ol>
<li>以文件副本的形式存在,但不占用实际空间</li>
<li>不允许给目录创建硬链接</li>
<li>硬链接不能跨越文件系统创建,只能在同一个文件系统里创建</li>
</ol>
<p>硬链接和软链接不同,硬链接用不带-s选项的ln命令直接创建,</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ln</span> world worldlink <span class="comment">## 创建world的硬链接文件worldlink</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l worldlink <span class="comment">## 查看硬链接文件的属性</span></span></span><br><span class="line">-r----xrw- 2 lyd lyd 4  4月  8 07:39 world_link</span><br></pre></td></tr></table></figure>
<p>根据上述查看的文件属性,我们得知这两个文件是独立的,但是会被联系在一起而已.</p>
<p>无论软链接还是硬链接,只是对目标文件的一个访问渠道而已,因此我们在任何一类链接文件上修改都会导致目标文件的变化.</p>
<p><a id="org898ec68"></a></p>
<h2 id="输入输出重定向和管道"><a href="#输入输出重定向和管道" class="headerlink" title="输入输出重定向和管道"></a>输入输出重定向和管道</h2><p>重定向和管道操作是Linux的Shell命令里的一种高级特性,其允许用户修改程序获取输入或者生成输出的位置.</p>
<p>在默认情况下程序输出结果的位置称之为标准输出.通常来说,标准输出位都是显示器.输出重定向的作用是将程序的输出转移到另一个地方去,</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> &gt; ~/ls_out <span class="comment">## 将输出结果定向到ls_out文件</span></span></span><br></pre></td></tr></table></figure>
<p>如果指定文件不存在,那么这个命令会创建这个文件,反之如果这个文件是存在的,那么他会直接覆盖文件原有的内容.如果我们希望能够保留原来文件中的内容,那么我们可以用输出重定向符号&gt;&gt;,</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">date</span> &gt; date_out <span class="comment">## 将date命令的输出重定向到date_out文件</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> date_out <span class="comment">## 查看date_out文件</span></span></span><br><span class="line">2024年 04月 16日 星期二 21:15:39 CST</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">uname</span> -r &gt;&gt; date_out <span class="comment">## 将输出结果重定向至date_out文件,并且仅在末尾输出,不覆盖原文件</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> date_out <span class="comment">## 再次查看date_out文件</span></span></span><br><span class="line">2024年 04月 16日 星期二 21:15:39 CST</span><br><span class="line">6.5.0-26-generic</span><br></pre></td></tr></table></figure>
<p>类似于标准输出的定义,程序默认情况下接受输入的地方称之为标准输入.通常来说,标准输入指向键盘.如果使用不带任何参数的cat命令,cat不会执行而是等待从标准输入来获取数据,用户可以输入一行会直接输出在屏幕上,直到Ctrl+D用来给cat命令输入一个文件结束符.<br>在此,我们罗列一下基于shell的常用快捷键及其含义</p>
<ol>
<li>Ctrl+c 终止当前正在执行的程序</li>
<li>Ctrl+z 中断当前进程,但不是终止进程,只是将进程挂起,我们可以用fg命令来重新调用进程(后续介绍)</li>
<li>Ctrl+l 清空屏幕</li>
<li>Ctrl+d 输入特殊的二进制值,表示EOF,作为文件的结束</li>
</ol>
<p>通过使用输入重定向符号&lt;可以让程序从一个文件中获取输入,</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> &lt; file <span class="comment">## 输出file里的内容</span></span></span><br></pre></td></tr></table></figure>
<p>显然cat可以直接接受参数来显示文件内容,因此输入重定向对这类命令并没有优势,故其使用比较少.</p>
<p>类似,其也存在另一种重定向符号&lt;&lt;,被称之为立即文档.立即文档告诉shell从键盘接受输入,并传递给程序,</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> &lt;&lt; <span class="string">EOF ## 立即文档作为输入,EOF</span>用来输入文档终止</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">Hello</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">,</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">world</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">!</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">EOF</span></span><br><span class="line">Hello</span><br><span class="line">,</span><br><span class="line">world</span><br><span class="line">!</span><br></pre></td></tr></table></figure>
<p>这里的EOF只是代用常见的终止缩写,实际上是可以随意使用的,只需要保证输入的内容中不会出终止代号即可.进一步,上面提到的两个重定向符号是可以在同一个命令中出现的.</p>
<p>管道符号|的出现则进一步使输出重定向的功能变灵活.通过一条竖线,将一个命令的输出作为下一个命令的输入,</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> | grep ld <span class="comment">##罗列文件列表以后查找文件名包含ld的文件</span></span></span><br><span class="line">world</span><br><span class="line">worldlink</span><br></pre></td></tr></table></figure>
<p>当然管道可以继续叠加使用,虽然会十分复杂但是运行起来会很高效.</p>
<p><a id="org86fc6aa"></a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Computer Science</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>SVD-Matrix Approximation</title>
    <url>/2024/04/19/svd-2/</url>
    <content><![CDATA[<p>The SVD allows us to decompose data matrix <span
class="math inline">\(X\)</span> as the product of three matrices, <span
class="math inline">\(U,\ V^T,\ \Sigma\)</span>, where essentially <span
class="math inline">\(U\)</span> contains information about the column
space of <span class="math inline">\(X\)</span>, <span
class="math inline">\(V\)</span> contains information about the row
space of <span class="math inline">\(X\)</span> and <span
class="math inline">\(\Sigma\)</span> is a hierarchically ordered
diagonal matrix, which tells you how important the various columns of
<span class="math inline">\(U\)</span> and <span
class="math inline">\(V\)</span> are.</p>
<span id="more"></span>
<p>In fact, the data matrix <span class="math inline">\(X\)</span> has
only <span class="math inline">\(m\)</span> columns, it means there are
at most <span class="math inline">\(m\)</span> linearly independence
columns in this <span class="math inline">\(n\)</span>-dimensional
vector space.So the first <span class="math inline">\(m\)</span> columns
of <span class="math inline">\(U\)</span> are important in representing
this data matrix. To explain this fact more deeply, we try to represent
expansion as a sum of rank-1 matrices.</p>
<p>Based on the Singular Value Decomposition,we can get the following
equation, <span class="math display">\[
X=U\Sigma V^T=\begin{bmatrix}\vdots&amp;\vdots&amp;\
&amp;\vdots\\u_1&amp;u_2&amp;\cdots&amp;u_m\\\vdots&amp;\vdots&amp;\
&amp;\vdots\end{bmatrix}\begin{bmatrix}\sigma_1&amp;\ &amp;\ &amp;\ \\\
&amp;\sigma_2&amp;\ &amp;\ \\\ &amp;\ &amp;\ddots&amp;\ \\
\ &amp;\ &amp;\ &amp;\sigma_m\\\ &amp;\ &amp;\ &amp;\ \\\ &amp;\ &amp;\
&amp;\ \\\ &amp;\ &amp;\ &amp;\
\end{bmatrix}\begin{bmatrix}\cdots&amp;v_1^{T}&amp;\cdots\\\cdots&amp;v_2^T&amp;\cdots\\\
&amp;\vdots&amp;\ \\\cdots&amp;v_m^T&amp;\cdots\end{bmatrix}^T
\]</span> Since <span class="math inline">\(\Sigma\)</span> is a
diagnoal matrix, we can expand the above equation as follow, <span
class="math display">\[
X=U\Sigma
V^T=\sigma_1u_1v_1^T+\sigma_2u_2v_2^T+\cdots+\sigma_mu_mv_m^T=\begin{bmatrix}\vdots&amp;\vdots&amp;\
&amp;\vdots\\u_1&amp;u_2&amp;\cdots&amp;u_m\\\vdots&amp;\vdots&amp;\
&amp;\vdots\end{bmatrix}\begin{bmatrix}\sigma_1&amp;\ &amp;\ &amp;\ \\\
&amp;\sigma_2&amp;\ &amp;\ \\\ &amp;\ &amp;\ddots&amp;\ \\
\ &amp;\ &amp;\
&amp;\sigma_m\end{bmatrix}\begin{bmatrix}\cdots&amp;v_1^{T}&amp;\cdots\\\cdots&amp;v_2^T&amp;\cdots\\\
&amp;\vdots&amp;\
\\\cdots&amp;v_m^T&amp;\cdots\end{bmatrix}^T=\hat{U}\hat{\Sigma}V^T
\]</span> Even though <span class="math inline">\(U\)</span> is a
massive <span class="math inline">\(n\times n\)</span> matrix, there are
only at most <span class="math inline">\(m\)</span> non-zeros singular
values in <span class="math inline">\(\Sigma\)</span> that means the
rank of data matrix <span class="math inline">\(X\)</span> satisfies
<span class="math inline">\(rank(X)\leq m\)</span>. Actually,I can
selcet the first <span class="math inline">\(m\)</span> columns of <span
class="math inline">\(U\)</span>, the first <span
class="math inline">\(m\times m\)</span> block of <span
class="math inline">\(\Sigma\)</span> and the original <span
class="math inline">\(V\)</span> to represent the data matrix <span
class="math inline">\(X\)</span>. We always call <span
class="math inline">\(X=\hat{U}\hat{\Sigma}V^T\)</span> as the economy
SVD and <span class="math inline">\(X=U\Sigma V^T\)</span> as the full
SVD. Since we consider the case of <span class="math inline">\(n\gg
m\)</span>, <span class="math inline">\(\hat{U}\in \mathbb{R}^{n\times
m}\)</span> and <span class="math inline">\(\hat{\Sigma}\in
\mathbb{R}^{m\times m}\)</span> need lower storage.</p>
<p>Therefore, we can give another explanation about SVD: we can
decompose the data matrix X into the orthogonal basis <span
class="math inline">\(U\)</span> and <span
class="math inline">\(V\)</span>, where essentially you can rewrite this
as a sum of rank-1 matrices, which increasingly improve the
approximation of <span class="math inline">\(X\)</span>. According to
this explanation, we can give out some interesting results like, the
best rank-1 matrix that we can make to approximate <span
class="math inline">\(X\)</span> is <span
class="math inline">\(\sigma_1u_1v_1^T\)</span>; the best rank-2 matrix
that we can make to approximate <span class="math inline">\(X\)</span>
is <span
class="math inline">\(\sigma_1u_1v_1^T+\sigma_2u_2v_2^T\)</span> and so
on and so forth.</p>
<p>Since we hope to use less data storage to approximate the real data
as much as possible in practice, we often truncate at rank r. Oftentimes
we have a lot of negligibly small singular values like <span
class="math inline">\(\sigma_{r+1},\
\sigma_{r+2},\cdots,\sigma_m\)</span> , it means that most of the
information of <span class="math inline">\(X\)</span> is captured in the
first <span class="math inline">\(r\)</span> singular values and the
first <span class="math inline">\(r\)</span> singular vectors. So we can
throw away all of low singular values and singular vectors and only keep
the first <span class="math inline">\(r\)</span> columns of <span
class="math inline">\(U\)</span> and <span
class="math inline">\(V\)</span> and the first <span
class="math inline">\(r\times r\)</span> submatrix in <span
class="math inline">\(\Sigma\)</span>. Then we are going to define this
truncated SVD as follows, <span class="math display">\[
X\approx\begin{bmatrix}\vdots&amp;\vdots&amp;\
&amp;\vdots\\u_1&amp;u_2&amp;\cdots&amp;u_r\\\vdots&amp;\vdots&amp;\
&amp;\vdots\end{bmatrix}\begin{bmatrix}\sigma_1&amp;\ &amp;\ &amp;\ \\\
&amp;\sigma_2&amp;\ &amp;\ \\\ &amp;\ &amp;\ddots&amp;\ \\
\ &amp;\ &amp;\
&amp;\sigma_r\end{bmatrix}\begin{bmatrix}\cdots&amp;v_1^{T}&amp;\cdots\\\cdots&amp;v_2^T&amp;\cdots\\\
&amp;\vdots&amp;\
\\\cdots&amp;v_r^T&amp;\cdots\end{bmatrix}^T=\tilde{U}\tilde{\Sigma}\tilde{V}^T
\]</span> Here we find that the truncated SVD <span
class="math inline">\(\tilde{U}\tilde{\Sigma}\tilde{V}^T\)</span> is the
best rank-<span class="math inline">\(r\)</span> matrix approximating
the data matrix <span class="math inline">\(X\)</span>.Thus,
high-dimensional data may be well described by a few dominant patterns
given by the columns of <span class="math inline">\(\tilde{U}\)</span>
and <span class="math inline">\(\tilde{V}\)</span>.Like the mentioned in
the first section,we realize that the truncated singular vectors <span
class="math inline">\(\tilde{U}\)</span> provides a coordinate
transformation from the high-dimensional measurement space into a
low-dimensional pattern space.</p>
<p>The Eckart-Young theorem states that the absolute best approximation
to the matrix <span class="math inline">\(X\)</span> of rank r,
Theorem(Eckart-Young) The optimal rank-r approximation to <span
class="math inline">\(X\)</span>, in a least-squares sense, is given by
the rank-r SVD truncation <span
class="math inline">\(\tilde{X}\)</span>, <span class="math display">\[
argmin_{\tilde{X},\ s.t.\ rank(\tilde{X})=r}\left\Vert
X-\tilde{X}\right\Vert_F=\tilde{U}\tilde{\Sigma}\tilde{V}^T
\]</span> The Ecakrt-Young theorem guarantees that the best possible
matrix approximation to <span class="math inline">\(X\)</span> of rank
<span class="math inline">\(r\)</span> is given by the firsr <span
class="math inline">\(r\)</span> truncated SVD.</p>
<p>Finally,we should mention an important point. At beginning of
discussing the SVD, we define the matrices <span
class="math inline">\(U\)</span> and <span
class="math inline">\(V\)</span> are unitary. However,if we truncated at
rank r,the truncated matrices <span
class="math inline">\(\tilde{U}\)</span> and <span
class="math inline">\(\tilde{V}\)</span> are no longer square matrices,
so they are not unitary matrix again. They satisfy that <span
class="math inline">\(\tilde{U}^T\tilde{U}=\tilde{V}^TV=I,\
\tilde{U}\tilde{U}^T\not=I\)</span></p>
]]></content>
      <categories>
        <category>Reduced Order Model</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>SVD-Mathematical Overview</title>
    <url>/2024/04/18/svd-1/</url>
    <content><![CDATA[<p>​    Firstly, we consider a large data matrix $X\in \mathbb{C}^{n\times m}$:</p>
<script type="math/tex; mode=display">
X=\begin{bmatrix}\vdots&\vdots&\ &\vdots\\x_1&x_2&\cdots&x_m\\\vdots&\vdots&\ &\vdots\end{bmatrix}</script><p>The column $x_k\in \mathbb{C}^n$ is obtained from simulations or experiments. Here,we always consider the column vectors may also represent the state of a physical system that is evolving in time.The column are often called snapshots and $m$ is the number of snapshots in $X$.</p>
<p>The Singular Value Decomposition allows us to decompose any complex-valued matrix as the product of three other matrices,</p>
<span id="more"></span>
<script type="math/tex; mode=display">
X=U\Sigma V^T=\begin{bmatrix}\vdots&\vdots&\ &\vdots\\u_1&u_2&\cdots&u_n\\\vdots&\vdots&\ &\vdots\end{bmatrix}\begin{bmatrix}\sigma_1&\ &\ &\ \\\ &\sigma_2&\ &\ \\\ &\ &\ddots&\ \\
\ &\ &\ &\sigma_m\\\ &\ &\ &\ \\\ &\ &\ &\ \\\ &\ &\ &\ \end{bmatrix}\begin{bmatrix}\vdots&\vdots&\ &\vdots\\v_1&v_2&\cdots&v_m\\\vdots&\vdots&\ &\vdots\end{bmatrix}^T</script><p>where $U\in \mathbb{C}^{n\times n}$ and $V\in\mathbb{C}^{m\times m}$ are unitary matrices. If a square matrix $U$ satisfies $U^{\star}U=UU^{\star}=I$, we call it unitary matrix. Here * denotes the complex conjugate transpose. For real-valued matrices, it is the same as the regular transpose, $X^{\star}=X^T$. So if $U$ and $V$ are real-valued matrices, we call them orthogonal matrices. Since the conclusions of real-valued and complex-valued $U$ and $V$ are parallel, we will only discuss the real-valued case in the following.  $\Sigma\in \mathbb{R}^{n\times m}$ is a diagonal matrix, which means real,non-zero entries on thediagonal and zeros off the diagonal.</p>
<p>​    These column of $U$ have the same shape as a column of $X$. The columns of $U$ describe the eigen of the data in $X$. So in the case of faces, these mean eigenfaces and in the case of flow fields, these mean eigenflow fields. Furthermore, the columns of $U$ are hierarchically arranged in terms of their ability to describe the variance in the column of $X$. In other words, $u_1$ is somehow more important than $u_2$ and so on and so forth.</p>
<p>​    $U$ gives me a basis, based on which we can represent each column of original data in $X$.Actually, these basis have great properties. Since $U$ is an unitary matrix, it means the column of $U$ are orthonormal. So these column are all orthogonal , have unit length and provide a complete basis for n-dimensional subspace where the column of data matrix lives.</p>
<p>​    $\Sigma$ is not only a diagnol matrix, but also non-negative and hierarchically ordered matrix. So we have $\sigma_1\geq\sigma_2\geq\sigma_3\geq\cdots\geq\sigma_m\geq0$. They are all non-negative, although some of them could be zero. According to the matrix multiplication, we can find that $\sigma_1$ correspond to the first columns of $U$ and $V$.Since $\sigma_1\geq\sigma_2$, it means that the first columns are somehow important than the second ones when we describe the information of $X$. In other words, the sigular value provides the relative imporatance of these corresponding columns of $U$ and $V$. Finally, we say that the sigular values are ordered by importance.</p>
<p>​    Here we will start in the case of flow fields. The columns of $U$ will be eigen flows hierarchically organized. We call the first column of $V$ as $v_1$. So $v_1$ would be the time series for how this first eigen mode $u_1$ evolves in this flow.</p>
<p>The matrix $U$ is called left sigular column and the columns are called left singular vectors. $V$ is similar to $U$. The diagonal elements of $\Sigma$ are called sigular values.The rank of X is equal to the number of non-zero sigular value.</p>
]]></content>
      <categories>
        <category>Reduced Order Model</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>SVD-Eckart-Young-Mirsky theorem</title>
    <url>/2024/05/28/svd-3/</url>
    <content><![CDATA[<p>Firstly, we introduce three different kinds of matrix norms and based
on singular value decomposition, verify that these norms are only
related to singular values.</p>
<ol type="1">
<li>2-norm (Spectral norm)</li>
</ol>
<p><span class="math display">\[
\left\Vert
A\right\Vert_2=\sqrt{\lambda_{max}(A^TA)}=\sqrt{\lambda_{max}(U\Sigma
V^TV\Sigma U^T)}=\sqrt{\lambda_{max}(\Sigma^2)}=\sigma_1
\]</span></p>
<ol type="1">
<li>Frobenius norm</li>
</ol>
<p><span class="math display">\[
\left\Vert A\right\Vert_F=\sqrt{tr(A^TA)}=\sqrt{tr(U\Sigma V^TV\Sigma
U^T)}=\sqrt{tr(\Sigma^2)}=\sqrt{\sum_{i=1}^m\sigma_i^2}
\]</span></p>
<ol type="1">
<li>Nuclear norm</li>
</ol>
<p><span class="math display">\[
\left\Vert
A\right\Vert_N=\sigma_1+\sigma_2+\dots+\sigma_m=\sum_{i=1}^m\sigma_i
\]</span></p>
<span id="more"></span>
<p>Based on the results of matrix norms, we realize that the above three
matrix norms only depend on the singular values of the matrix <span
class="math inline">\(A\)</span>. Now we claim that the product with
orthogonal matrices will not change the singular values of the original
matrix. For simplicity, we call the left orthogonal matrix and right
orthogonal matrix as <span class="math inline">\(P\)</span> and <span
class="math inline">\(Q\)</span>, respectively. Based on the singular
value decomposition of <span class="math inline">\(A\)</span>, we can
derive the following results about the product of matrix <span
class="math inline">\(A\)</span> and orthogonal matrices <span
class="math inline">\(P,\ Q\)</span>, <span class="math display">\[
PAQ=PU\Sigma V^TQ=U_1\Sigma V_1^T,\ U_1=PU,\ V_1=Q^TV
\]</span> where <span
class="math inline">\(U_1U_1^T=PUU^TP^T=I=U_1^TU_1\)</span> means <span
class="math inline">\(U_1\)</span> is an orthogonal matrix. The same is
true for <span class="math inline">\(V_1\)</span>. We claim that the
singular values of <span class="math inline">\(PAQ\)</span> is the same
as the singular values of <span class="math inline">\(A\)</span>. So we
realize that the product with orthogonal matrices does not affect matrix
norm.</p>
<p><strong>Thm(Eckart-Young-Mirsky Theorem)</strong> The optimal rank-r
approximation to <span class="math inline">\(A\)</span>, under the
spectral norm and the Frobenius norm, respectively, is given by the
rank-r SVD truncation <span class="math inline">\(\tilde{A}\)</span>,
<span class="math display">\[
argmin_{\hat{A},\ s.t.\ rank(\hat{A})=r}\left\Vert
A-\hat{A}\right\Vert_F=\tilde{A}\quad argmin_{\hat{A},\ s.t.\
rank(\hat{A})=r}\left\Vert A-\hat{A}\right\Vert_2=\tilde{A}
\]</span> where <span
class="math inline">\(\tilde{A}=\tilde{U}\tilde{\Sigma}\tilde{V}^T\)</span>
is the rank-r SVD truncation of <span class="math inline">\(A\)</span>.
Again, <span class="math inline">\(\tilde{U}\)</span> and <span
class="math inline">\(\tilde{V}\)</span> denote the first <span
class="math inline">\(r\)</span> leading columns of <span
class="math inline">\(U\)</span> and <span
class="math inline">\(V\)</span>, respectively, and <span
class="math inline">\(\tilde{\Sigma}\)</span> is the <span
class="math inline">\(r\times r\)</span> leading submatrix of <span
class="math inline">\(\Sigma\)</span>.</p>
<p>Proof.</p>
<ol type="1">
<li><p>One needs to show that if we have a matrix approximation <span
class="math inline">\(B\)</span> whose rank is <span
class="math inline">\(r\)</span> and size is <span
class="math inline">\(n\times m\)</span>, then <span
class="math inline">\(\left\Vert A-B\right\Vert_2\geq \left\Vert
A-\tilde{A}\right\Vert_2\)</span> holds. This can be done as
follows.</p>
<p>Here we introduce the concept of matrix kernel before the discussion.
The kernel of matrix <span class="math inline">\(A\)</span> is defined
as <span class="math display">\[
   \mathcal{N}(A)=\{x\in \mathbb{R}^n:Ax=0\}
\]</span> Therefore, we realize that the kernel of matrix <span
class="math inline">\(\mathcal{N}(A)\)</span> actually means the
solution space of the linear equation <span
class="math inline">\(Ax=0\)</span>. Based on the linear equation
theory, we know that when the rank of matrix <span
class="math inline">\(B\)</span> is <span
class="math inline">\(r\)</span>, the dimension of <span
class="math inline">\(\mathcal{N}(B)\)</span> is <span
class="math inline">\(n-r\)</span>. Here we consider the linear space
<span class="math inline">\(V_{r+1}\)</span> spanned by the first <span
class="math inline">\(r+1\)</span> leading right singular vectors <span
class="math inline">\(v_1,\ v_2,\dots,v_{r+1}\)</span>, whose dimension
is <span class="math inline">\(r+1\)</span>. Based on the dimensional
formula, we derive that <span class="math display">\[
   dim(\mathcal{N}(B)\cap
V_{r+1})=dim(\mathcal{N}(B))+dim(V_{r+1})-dim(\mathcal{N}(B)+V_{r+1})=n+1-dim(\mathcal{N}(B)+V_{r+1})\geq1
\]</span> which means that <span
class="math inline">\(\mathcal{N}(B)\cap V_{r+1}\not=\empty\)</span>.
Therefore, we have that there exists an vector <span
class="math inline">\(x=\gamma_1v_1+\cdots+\gamma_{r+1}v_{r+1}\)</span>
such that <span class="math display">\[
   x\in \mathcal{N}(B)\cap V_{r+1},\ \left\Vert x\right\Vert_2=1
\]</span> Based on the definition of 2-norm, we can derive that <span
class="math display">\[
   \left\Vert A-B\right\Vert_2\geq \left\Vert
(A-B)x\right\Vert_2=\left\Vert
Ax\right\Vert_2=\gamma_1^2\sigma_1^2+\cdots+\gamma_{r+1}^2\sigma_{r+1}^2\geq
\sigma_{r+1}^2=\left\Vert A-\tilde{A}\right\Vert_2
\]</span> which means that the optimal rank-r approximation to <span
class="math inline">\(A\)</span> under the 2-norm is given by the rank-r
SVD truncation <span class="math inline">\(\tilde{A}\)</span>.</p></li>
<li><p>Now we claim that the best rank <span
class="math inline">\(r\)</span> approximation to <span
class="math inline">\(A\)</span> in the Frobenius norm, denoted by <span
class="math inline">\(\Vert\cdot\Vert_F\)</span>, is given by <span
class="math display">\[
A_r=U_r\Sigma_rV_r^T=\sum_{i=1}^r\sigma_iu_iv_i^T
\]</span> First, note that we have <span class="math display">\[
\left\Vert A-A_k\right\Vert_F^2=\left\Vert
\sum_{i=r+1}^m\sigma_iu_iv_i^T\right\Vert_F^2=\sum_{i=r+1}^m\sigma_i^2
\]</span> Hence, we need to show that if <span
class="math inline">\(B_r\)</span> is any rank-<span
class="math inline">\(r\)</span> matrix, then, <span
class="math display">\[
\left\Vert A-B_r\right\Vert_F^2\geq \sum_{i=r+1}^m\sigma_i^2
\]</span> Based on the triangle inequality with the spectral norm, if
<span class="math inline">\(A=A&#39;+A&#39;&#39;\)</span>, then <span
class="math inline">\(\sigma_1(A)\leq\sigma_1(A&#39;)+\sigma_1(A&#39;&#39;)\)</span>.
Suppose <span class="math inline">\(A_r&#39;\)</span> and <span
class="math inline">\(A_r&#39;&#39;\)</span> denote the rank <span
class="math inline">\(r\)</span> approximation to <span
class="math inline">\(A&#39;\)</span> and <span
class="math inline">\(A&#39;&#39;\)</span> by SVD method described
above, respectively. Then, for any <span
class="math inline">\(i,j\geq1\)</span> <span class="math display">\[
\begin{aligned}
\sigma_i(A&#39;)+\sigma_j(A&#39;&#39;)&amp;=\sigma_1(A&#39;-A_{i-1}&#39;)+\sigma_1(A&#39;&#39;-A_{j-1}&#39;&#39;)\\
&amp;\geq\sigma_1(A&#39;-A_{i-1}&#39;+A&#39;&#39;-A_{j-1}&#39;&#39;)\\
&amp;\geq\sigma_1(A-A_{i-1}&#39;-A_{j-1}&#39;&#39;)\\
\end{aligned}
\]</span> Here we know that <span
class="math inline">\(rank(A_{i-1}&#39;+A_{j-1}&#39;&#39;)\leq
i+j-2\)</span>, we can derive that</p></li>
</ol>
<p><span class="math display">\[
\begin{aligned}
\sigma_i(A&#39;)+\sigma_j(A&#39;&#39;)&amp;\geq\sigma_1(A-A_{i+j-2})\\
&amp;=\sigma_{i+j-1}(A)
\end{aligned}
\]</span> Since <span
class="math inline">\(\sigma_{r+1}(B_r)=0\)</span>, when <span
class="math inline">\(A&#39;=A-B_r\)</span> and <span
class="math inline">\(A&#39;&#39;=B_r\)</span>, we conclude that for
<span class="math inline">\(i\geq1,\ j=r+1\)</span> <span
class="math display">\[
\sigma_i(A-B_r)= \sigma_i(A-B_r)+\sigma_{r+1}(B_r)\geq\sigma_{i+r}(A)
\]</span> Therefore, we have <span class="math display">\[
\left\Vert
A-B_r\right\Vert_F^2=\sum_{i=1}^m\sigma_i(A-B_r)^2\geq\sum_{i=r+1}^m\sigma_i(A)^2=\left\Vert
A-A_r\right\Vert_F^2
\]</span></p>
]]></content>
      <categories>
        <category>Reduced Order Model</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>SVD-Dominnant Correlation</title>
    <url>/2024/06/05/svd-4/</url>
    <content><![CDATA[<p>Here we introduce one of the most useful interpretation of the SVD. It is in terms of correlations among the columns of $X$ and correlations among the rows of $X$. We claim that the matrix $U$ and $V$ given by the SVD can be seen as the eigenvectors of a correlation matrix given by $XX^T$ or $X^TX$. Now we try to explain this claim.</p>
<span id="more"></span>
<p>We consider the structure of the correlation matrix $X^TX$ firstly. Since the size of the data matrix $X$ is $n\times m$, the size of the correlation matrix $X^TX$ is $m\times m$.</p>
<script type="math/tex; mode=display">
X^TX=\begin{bmatrix}\cdots&x_1^T&\cdots\\\cdots&x_2^T&\cdots\\\ &\vdots&\ \\\cdots&x_m^T&\cdots\end{bmatrix}\begin{bmatrix}\vdots&\vdots&\ &\vdots\\x_1&x_2&\cdots&x_m\\\vdots&\vdots&\ &\vdots\end{bmatrix}=\begin{bmatrix}x_1^Tx_1&x_1^Tx_2&\cdots&x_1^Tx_m\\x_2^Tx_1&x_2^Tx_2&\cdots&x_2^Tx_m\\\vdots&\vdots&\ &\vdots\\x_m^Tx_1&x_m^Tx_2&\cdots&x_m^Tx_m\end{bmatrix}</script><p>Based on the definition of $X^TX$, we realize that $X^TX$ is a correlation matrix among the columns of $X$. All entries of $X^TX$ are essentially an inner product between two columns of the data matrix $X$. Interestingly, if the entry $x_i^Tx_j$ is a large number, it means that the columns $x_i$ and $x_j$ are highly correlated. However, if this number is very small, it means that the columns $x_i$ and $x_j$ are nearly orthogonal, which means that the columns $x_i$ and $x_j$ are almost different. Therefore, the correlation matrix $X^TX$ can be seen as a matrix that measures the correlation among the columns of $X$.</p>
<p>Based on the structure of the correlation matrix $X^TX$, $X^TX$ is a symmetric and positive semi-definite matrix. It guarantees that we have non negative real eigenvalues, which have a direct correspondence on the singular values of the data matrix $X$. Now we assume that the matrix $X$ have the singular value decomposition $X=U\Sigma V^T$. We can derive that</p>
<script type="math/tex; mode=display">
X^TX=V\Sigma^TU^TU\Sigma V^T=V\Sigma^2 V^T\Rightarrow X^TXV=V\Sigma^2</script><p>which means that the columns of $V$ are the eigenvectors of the correlation matrix $X^TX$. The eigenvalues of the correlation matrix $X^TX$ are the squares of the singular values of the data matrix $X$. The same is true for the correlation matrix $XX^T$. We can derive that</p>
<script type="math/tex; mode=display">
XX^T=U\Sigma V^TV\Sigma U^{T}=U\Sigma^2 U^T\Rightarrow X^TXU=U\Sigma^2</script><p>which means that the columns of $U$ are the eigenvectors of the correlation matrix $XX^T$. The eigenvalues of the correlation matrix $XX^T$ are the squares of the singular values of the data matrix $X$. Therefore, we can conclude that the singular matrix $U$ and $V$ given by the SVD of the data matrix $X$ can be seen as the eigenvectors of the correlation matrix $X^TX$ or $XX^T$. The importance of this columns of $U$ and $V$ is quantified by eigenvalues of $X^TX$ or $XX^T$, which are the squares of the singular values of the data matrix $X$.</p>
]]></content>
      <categories>
        <category>Reduced Order Model</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>SVD=Unitary Transformation and Geometry</title>
    <url>/2024/06/16/svd-5/</url>
    <content><![CDATA[<p>In the singular value decomposition of the data matrix <span
class="math inline">\(X\)</span>, we have the two unitary matrices <span
class="math inline">\(U\)</span> and <span
class="math inline">\(V\)</span>. We have introduced that the unitary
matrices satisfy <span class="math inline">\(U^TU=UU^T=I\)</span> and
<span class="math inline">\(VV^T=V^TV=I\)</span>. Here these identity
matrices have different size.</p>
<p>Actually, unitary matrices preserve the angle between any two vectors
in the vector space. Since the inverse of the unitary matrix is its own
transpose, it can not only preserve the angles between vectors, but also
preserve the length of the vectors. Essentially, unitary transformation
is a coordinate transformation into a new representation. It just takes
all of those vectors and rotates them into a new representation. It will
not change the length of any vector and angles between any two
vectors.</p>
<p>Here you will find that we just consider the real-valued case.
However, when we consider the data matrix <span
class="math inline">\(X\)</span> is a complex-valued matrix, the
singular vectors <span class="math inline">\(U\)</span> and <span
class="math inline">\(V\)</span> are complex-valued matrices. Compared
with the real-valued matrix, the most important difference is that the
transpose of a complex-valued matrix is actually a conjugate
transpose.</p>
<p>To sum up, we give the mathematical form of unitary transformation
here. For any two vectors <span class="math inline">\(x\)</span> and
<span class="math inline">\(y\)</span> in vector space, then we have
<span class="math display">\[
(x,y)=(Ux,Uy)
\]</span> where <span class="math inline">\((\cdot,\cdot)\)</span> is
the inner product of two vectors and the operator <span
class="math inline">\(U\)</span> means the unitary transformation, which
in a unitary matrix in discrete case. Based on this mathematical form,
we realize that the inner product of <span
class="math inline">\(x\)</span> and <span
class="math inline">\(y\)</span> is unchanged when we transform <span
class="math inline">\(x\)</span> and <span
class="math inline">\(y\)</span> by unitary transformation.</p>
<p>Since we have introduced the unitary transform in the vector space,
we interpret singular vector decomposition geometrically. Here we
consider the size of data matrix is <span class="math inline">\(n\times
m\)</span>. Now we consider any vector <span
class="math inline">\(\vec{v}\)</span> in space <span
class="math inline">\(\mathbb{R}^m\)</span> and vector <span
class="math inline">\(\vec{v}\)</span> is palced on the unit sphere. As
we all know, the matrix is a linear transformation about the vector.
Therefore, we consider the transformed vector <span
class="math inline">\(X\vec{v}\)</span>, which is placed on the
ellipsoid in the vector space <span
class="math inline">\(\mathbb{R}^n\)</span>. Here the gemoetric
interpretation of the singular value decomposition can be given. The
length of these principal axes are specially given by the singular
values of the data matrix <span class="math inline">\(X\)</span>. The
orientation of this ellipsoid is somehow given by these left singular
vectors in <span class="math inline">\(U\)</span>. Like the
interpretation of linear transformation, <span
class="math inline">\(X\)</span> multiplies the vector on the left side
or on the right side, which corresponds to a change to a rotation of
space. Finally, <span class="math inline">\(X\)</span> is not a square
matrix, so the rotation of the corresponding space is actually a change
in dimensionality.</p>
]]></content>
      <categories>
        <category>Reduced Order Model</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
</search>
